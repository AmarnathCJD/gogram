// Code generated by TLParser; DO NOT EDIT. (c) @amarnathcjd

package telegram

import (
	errors "github.com/pkg/errors"
	"reflect"
)

type AccountAcceptAuthorizationParams struct {
	BotID       int64
	Scope       string
	PublicKey   string
	ValueHashes []*SecureValueHash
	Credentials *SecureCredentialsEncrypted
}

func (*AccountAcceptAuthorizationParams) CRC() uint32 {
	return 0xf3ed4c73
}

// Sends a Telegram Passport authorization form, effectively sharing data with the service
func (c *Client) AccountAcceptAuthorization(botID int64, scope, publicKey string, valueHashes []*SecureValueHash, credentials *SecureCredentialsEncrypted) (bool, error) {
	responseData, err := c.MakeRequest(&AccountAcceptAuthorizationParams{
		BotID:       botID,
		Credentials: credentials,
		PublicKey:   publicKey,
		Scope:       scope,
		ValueHashes: valueHashes,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountAcceptAuthorization")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountCancelPasswordEmailParams struct{}

func (*AccountCancelPasswordEmailParams) CRC() uint32 {
	return 0xc1cbd5b6
}

// Cancel the code that was sent to verify an email to use as 2FA recovery method.
func (c *Client) AccountCancelPasswordEmail() (bool, error) {
	responseData, err := c.MakeRequest(&AccountCancelPasswordEmailParams{})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountCancelPasswordEmail")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountChangeAuthorizationSettingsParams struct {
	Confirmed                 bool `tl:"flag:3,encoded_in_bitflags"`
	Hash                      int64
	EncryptedRequestsDisabled bool `tl:"flag:0"`
	CallRequestsDisabled      bool `tl:"flag:1"`
}

func (*AccountChangeAuthorizationSettingsParams) CRC() uint32 {
	return 0x40f48462
}

func (*AccountChangeAuthorizationSettingsParams) FlagIndex() int {
	return 0
}

// Change settings related to a session.
func (c *Client) AccountChangeAuthorizationSettings(confirmed bool, hash int64, encryptedRequestsDisabled, callRequestsDisabled bool) (bool, error) {
	responseData, err := c.MakeRequest(&AccountChangeAuthorizationSettingsParams{
		CallRequestsDisabled:      callRequestsDisabled,
		Confirmed:                 confirmed,
		EncryptedRequestsDisabled: encryptedRequestsDisabled,
		Hash:                      hash,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountChangeAuthorizationSettings")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountChangePhoneParams struct {
	PhoneNumber   string
	PhoneCodeHash string
	PhoneCode     string
}

func (*AccountChangePhoneParams) CRC() uint32 {
	return 0x70c32edb
}

// Change the phone number of the current account
func (c *Client) AccountChangePhone(phoneNumber, phoneCodeHash, phoneCode string) (User, error) {
	responseData, err := c.MakeRequest(&AccountChangePhoneParams{
		PhoneCode:     phoneCode,
		PhoneCodeHash: phoneCodeHash,
		PhoneNumber:   phoneNumber,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountChangePhone")
	}

	resp, ok := responseData.(User)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountCheckUsernameParams struct {
	Username string
}

func (*AccountCheckUsernameParams) CRC() uint32 {
	return 0x2714d86c
}

// Validates a username and checks availability.
func (c *Client) AccountCheckUsername(username string) (bool, error) {
	responseData, err := c.MakeRequest(&AccountCheckUsernameParams{Username: username})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountCheckUsername")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountClearRecentEmojiStatusesParams struct{}

func (*AccountClearRecentEmojiStatusesParams) CRC() uint32 {
	return 0x18201aae
}

// Clears list of recently used emoji statuses
func (c *Client) AccountClearRecentEmojiStatuses() (bool, error) {
	responseData, err := c.MakeRequest(&AccountClearRecentEmojiStatusesParams{})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountClearRecentEmojiStatuses")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountConfirmPasswordEmailParams struct {
	Code string
}

func (*AccountConfirmPasswordEmailParams) CRC() uint32 {
	return 0x8fdf1920
}

// Verify an email to use as 2FA recovery method.
func (c *Client) AccountConfirmPasswordEmail(code string) (bool, error) {
	responseData, err := c.MakeRequest(&AccountConfirmPasswordEmailParams{Code: code})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountConfirmPasswordEmail")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountConfirmPhoneParams struct {
	PhoneCodeHash string
	PhoneCode     string
}

func (*AccountConfirmPhoneParams) CRC() uint32 {
	return 0x5f2178c3
}

// Confirm a phone number to cancel account deletion, for more info click here »
func (c *Client) AccountConfirmPhone(phoneCodeHash, phoneCode string) (bool, error) {
	responseData, err := c.MakeRequest(&AccountConfirmPhoneParams{
		PhoneCode:     phoneCode,
		PhoneCodeHash: phoneCodeHash,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountConfirmPhone")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountCreateBusinessChatLinkParams struct {
	Link *InputBusinessChatLink
}

func (*AccountCreateBusinessChatLinkParams) CRC() uint32 {
	return 0x8851e68e
}

// Create a business chat deep link ».
func (c *Client) AccountCreateBusinessChatLink(link *InputBusinessChatLink) (*BusinessChatLink, error) {
	responseData, err := c.MakeRequest(&AccountCreateBusinessChatLinkParams{Link: link})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountCreateBusinessChatLink")
	}

	resp, ok := responseData.(*BusinessChatLink)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountCreateThemeParams struct {
	Slug     string
	Title    string
	Document InputDocument         `tl:"flag:2"`
	Settings []*InputThemeSettings `tl:"flag:3"`
}

func (*AccountCreateThemeParams) CRC() uint32 {
	return 0x652e4400
}

func (*AccountCreateThemeParams) FlagIndex() int {
	return 0
}

// Create a theme
func (c *Client) AccountCreateTheme(slug, title string, document InputDocument, settings []*InputThemeSettings) (*Theme, error) {
	responseData, err := c.MakeRequest(&AccountCreateThemeParams{
		Document: document,
		Settings: settings,
		Slug:     slug,
		Title:    title,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountCreateTheme")
	}

	resp, ok := responseData.(*Theme)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountDeclinePasswordResetParams struct{}

func (*AccountDeclinePasswordResetParams) CRC() uint32 {
	return 0x4c9409f6
}

// Abort a pending 2FA password reset, see here for more info »
func (c *Client) AccountDeclinePasswordReset() (bool, error) {
	responseData, err := c.MakeRequest(&AccountDeclinePasswordResetParams{})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountDeclinePasswordReset")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountDeleteAccountParams struct {
	Reason   string
	Password InputCheckPasswordSRP `tl:"flag:0"`
}

func (*AccountDeleteAccountParams) CRC() uint32 {
	return 0xa2c0cf74
}

func (*AccountDeleteAccountParams) FlagIndex() int {
	return 0
}

// Delete the user's account from the telegram servers.
func (c *Client) AccountDeleteAccount(reason string, password InputCheckPasswordSRP) (bool, error) {
	responseData, err := c.MakeRequest(&AccountDeleteAccountParams{
		Password: password,
		Reason:   reason,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountDeleteAccount")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountDeleteAutoSaveExceptionsParams struct{}

func (*AccountDeleteAutoSaveExceptionsParams) CRC() uint32 {
	return 0x53bc0020
}

// Clear all peer-specific autosave settings.
func (c *Client) AccountDeleteAutoSaveExceptions() (bool, error) {
	responseData, err := c.MakeRequest(&AccountDeleteAutoSaveExceptionsParams{})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountDeleteAutoSaveExceptions")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountDeleteBusinessChatLinkParams struct {
	Slug string
}

func (*AccountDeleteBusinessChatLinkParams) CRC() uint32 {
	return 0x60073674
}

// Delete a business chat deep link ».
func (c *Client) AccountDeleteBusinessChatLink(slug string) (bool, error) {
	responseData, err := c.MakeRequest(&AccountDeleteBusinessChatLinkParams{Slug: slug})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountDeleteBusinessChatLink")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountDeleteSecureValueParams struct {
	Types []SecureValueType
}

func (*AccountDeleteSecureValueParams) CRC() uint32 {
	return 0xb880bc4b
}

// Delete stored Telegram Passport documents, for more info see the passport docs »
func (c *Client) AccountDeleteSecureValue(types []SecureValueType) (bool, error) {
	responseData, err := c.MakeRequest(&AccountDeleteSecureValueParams{Types: types})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountDeleteSecureValue")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountDisablePeerConnectedBotParams struct {
	Peer InputPeer
}

func (*AccountDisablePeerConnectedBotParams) CRC() uint32 {
	return 0x5e437ed9
}

// Permanently disconnect a specific chat from all business bots » (equivalent to specifying it in `recipients.exclude_users` during initial configuration with account.updateConnectedBot »); to reconnect of a chat disconnected using this method the user must reconnect the entire bot by invoking account.updateConnectedBot ».
func (c *Client) AccountDisablePeerConnectedBot(peer InputPeer) (bool, error) {
	responseData, err := c.MakeRequest(&AccountDisablePeerConnectedBotParams{Peer: peer})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountDisablePeerConnectedBot")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountEditBusinessChatLinkParams struct {
	Slug string
	Link *InputBusinessChatLink
}

func (*AccountEditBusinessChatLinkParams) CRC() uint32 {
	return 0x8c3410af
}

// Edit a created business chat deep link ».
func (c *Client) AccountEditBusinessChatLink(slug string, link *InputBusinessChatLink) (*BusinessChatLink, error) {
	responseData, err := c.MakeRequest(&AccountEditBusinessChatLinkParams{
		Link: link,
		Slug: slug,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountEditBusinessChatLink")
	}

	resp, ok := responseData.(*BusinessChatLink)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountFinishTakeoutSessionParams struct {
	Success bool `tl:"flag:0,encoded_in_bitflags"`
}

func (*AccountFinishTakeoutSessionParams) CRC() uint32 {
	return 0x1d2652ee
}

func (*AccountFinishTakeoutSessionParams) FlagIndex() int {
	return 0
}

// Terminate a takeout session, see here » for more info.
func (c *Client) AccountFinishTakeoutSession(success bool) (bool, error) {
	responseData, err := c.MakeRequest(&AccountFinishTakeoutSessionParams{Success: success})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountFinishTakeoutSession")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetAccountTtlParams struct{}

func (*AccountGetAccountTtlParams) CRC() uint32 {
	return 0x8fc711d
}

// Get days to live of account
func (c *Client) AccountGetAccountTtl() (*AccountDaysTtl, error) {
	responseData, err := c.MakeRequest(&AccountGetAccountTtlParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetAccountTtl")
	}

	resp, ok := responseData.(*AccountDaysTtl)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetAllSecureValuesParams struct{}

func (*AccountGetAllSecureValuesParams) CRC() uint32 {
	return 0xb288bc7d
}

// Get all saved Telegram Passport documents, for more info see the passport docs »
func (c *Client) AccountGetAllSecureValues() ([]*SecureValue, error) {
	responseData, err := c.MakeRequest(&AccountGetAllSecureValuesParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetAllSecureValues")
	}

	resp, ok := responseData.([]*SecureValue)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetAuthorizationFormParams struct {
	BotID     int64
	Scope     string
	PublicKey string
}

func (*AccountGetAuthorizationFormParams) CRC() uint32 {
	return 0xa929597a
}

// Returns a Telegram Passport authorization form for sharing data with a service
func (c *Client) AccountGetAuthorizationForm(botID int64, scope, publicKey string) (*AccountAuthorizationForm, error) {
	responseData, err := c.MakeRequest(&AccountGetAuthorizationFormParams{
		BotID:     botID,
		PublicKey: publicKey,
		Scope:     scope,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetAuthorizationForm")
	}

	resp, ok := responseData.(*AccountAuthorizationForm)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetAuthorizationsParams struct{}

func (*AccountGetAuthorizationsParams) CRC() uint32 {
	return 0xe320c158
}

// Get logged-in sessions
func (c *Client) AccountGetAuthorizations() (*AccountAuthorizations, error) {
	responseData, err := c.MakeRequest(&AccountGetAuthorizationsParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetAuthorizations")
	}

	resp, ok := responseData.(*AccountAuthorizations)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetAutoDownloadSettingsParams struct{}

func (*AccountGetAutoDownloadSettingsParams) CRC() uint32 {
	return 0x56da0b3f
}

// Get media autodownload settings
func (c *Client) AccountGetAutoDownloadSettings() (*AccountAutoDownloadSettings, error) {
	responseData, err := c.MakeRequest(&AccountGetAutoDownloadSettingsParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetAutoDownloadSettings")
	}

	resp, ok := responseData.(*AccountAutoDownloadSettings)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetAutoSaveSettingsParams struct{}

func (*AccountGetAutoSaveSettingsParams) CRC() uint32 {
	return 0xadcbbcda
}

// Get autosave settings
func (c *Client) AccountGetAutoSaveSettings() (*AccountAutoSaveSettings, error) {
	responseData, err := c.MakeRequest(&AccountGetAutoSaveSettingsParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetAutoSaveSettings")
	}

	resp, ok := responseData.(*AccountAutoSaveSettings)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetBotBusinessConnectionParams struct {
	ConnectionID string
}

func (*AccountGetBotBusinessConnectionParams) CRC() uint32 {
	return 0x76a86270
}

/*
Bots may invoke this method to re-fetch the updateBotBusinessConnect constructor associated with a specific <a href="/api/business#connected-bots">business `connection_id`, see here »</a> for more info on connected business bots.<br>
This is needed for example for freshly logged in bots that are receiving some updateBotNewBusinessMessage, etc. updates because some users have already connected to the bot before it could login.<br>
In this case, the bot is receiving messages from the business connection, but it hasn't cached the associated updateBotBusinessConnect with info about the connection (can it reply to messages? etc.) yet, and cannot receive the old ones because they were sent when the bot wasn't logged into the session yet.<br>
This method can be used to fetch info about a not-yet-cached business connection, and should not be invoked if the info is already cached or to fetch changes, as eventual changes will automatically be sent as new updateBotBusinessConnect updates to the bot using the usual update delivery methods ».
*/
func (c *Client) AccountGetBotBusinessConnection(connectionID string) (Updates, error) {
	responseData, err := c.MakeRequest(&AccountGetBotBusinessConnectionParams{ConnectionID: connectionID})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetBotBusinessConnection")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetBusinessChatLinksParams struct{}

func (*AccountGetBusinessChatLinksParams) CRC() uint32 {
	return 0x6f70dde1
}

// List all created business chat deep links ».
func (c *Client) AccountGetBusinessChatLinks() (*AccountBusinessChatLinks, error) {
	responseData, err := c.MakeRequest(&AccountGetBusinessChatLinksParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetBusinessChatLinks")
	}

	resp, ok := responseData.(*AccountBusinessChatLinks)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetChannelDefaultEmojiStatusesParams struct {
	Hash int64
}

func (*AccountGetChannelDefaultEmojiStatusesParams) CRC() uint32 {
	return 0x7727a7d5
}

// Get a list of default suggested channel emoji statuses.
func (c *Client) AccountGetChannelDefaultEmojiStatuses(hash int64) (AccountEmojiStatuses, error) {
	responseData, err := c.MakeRequest(&AccountGetChannelDefaultEmojiStatusesParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetChannelDefaultEmojiStatuses")
	}

	resp, ok := responseData.(AccountEmojiStatuses)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetChannelRestrictedStatusEmojisParams struct {
	Hash int64
}

func (*AccountGetChannelRestrictedStatusEmojisParams) CRC() uint32 {
	return 0x35a9e0d5
}

// Returns fetch the full list of custom emoji IDs » that cannot be used in channel emoji statuses ».
func (c *Client) AccountGetChannelRestrictedStatusEmojis(hash int64) (EmojiList, error) {
	responseData, err := c.MakeRequest(&AccountGetChannelRestrictedStatusEmojisParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetChannelRestrictedStatusEmojis")
	}

	resp, ok := responseData.(EmojiList)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetChatThemesParams struct {
	Hash int64
}

func (*AccountGetChatThemesParams) CRC() uint32 {
	return 0xd638de89
}

// Get all available chat themes ».
func (c *Client) AccountGetChatThemes(hash int64) (AccountThemes, error) {
	responseData, err := c.MakeRequest(&AccountGetChatThemesParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetChatThemes")
	}

	resp, ok := responseData.(AccountThemes)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetCollectibleEmojiStatusesParams struct {
	Hash int64
}

func (*AccountGetCollectibleEmojiStatusesParams) CRC() uint32 {
	return 0x2e7b4543
}

func (c *Client) AccountGetCollectibleEmojiStatuses(hash int64) (AccountEmojiStatuses, error) {
	responseData, err := c.MakeRequest(&AccountGetCollectibleEmojiStatusesParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetCollectibleEmojiStatuses")
	}

	resp, ok := responseData.(AccountEmojiStatuses)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetConnectedBotsParams struct{}

func (*AccountGetConnectedBotsParams) CRC() uint32 {
	return 0x4ea4c80f
}

// List all currently connected business bots »
func (c *Client) AccountGetConnectedBots() (*AccountConnectedBots, error) {
	responseData, err := c.MakeRequest(&AccountGetConnectedBotsParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetConnectedBots")
	}

	resp, ok := responseData.(*AccountConnectedBots)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetContactSignUpNotificationParams struct{}

func (*AccountGetContactSignUpNotificationParams) CRC() uint32 {
	return 0x9f07c728
}

// Whether the user will receive notifications when contacts sign up
func (c *Client) AccountGetContactSignUpNotification() (bool, error) {
	responseData, err := c.MakeRequest(&AccountGetContactSignUpNotificationParams{})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountGetContactSignUpNotification")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetContentSettingsParams struct{}

func (*AccountGetContentSettingsParams) CRC() uint32 {
	return 0x8b9b4dae
}

// Get sensitive content settings
func (c *Client) AccountGetContentSettings() (*AccountContentSettings, error) {
	responseData, err := c.MakeRequest(&AccountGetContentSettingsParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetContentSettings")
	}

	resp, ok := responseData.(*AccountContentSettings)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetDefaultBackgroundEmojisParams struct {
	Hash int64
}

func (*AccountGetDefaultBackgroundEmojisParams) CRC() uint32 {
	return 0xa60ab9ce
}

// Get a set of suggested custom emoji stickers that can be used in an accent color pattern.
func (c *Client) AccountGetDefaultBackgroundEmojis(hash int64) (EmojiList, error) {
	responseData, err := c.MakeRequest(&AccountGetDefaultBackgroundEmojisParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetDefaultBackgroundEmojis")
	}

	resp, ok := responseData.(EmojiList)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetDefaultEmojiStatusesParams struct {
	Hash int64
}

func (*AccountGetDefaultEmojiStatusesParams) CRC() uint32 {
	return 0xd6753386
}

// Get a list of default suggested emoji statuses
func (c *Client) AccountGetDefaultEmojiStatuses(hash int64) (AccountEmojiStatuses, error) {
	responseData, err := c.MakeRequest(&AccountGetDefaultEmojiStatusesParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetDefaultEmojiStatuses")
	}

	resp, ok := responseData.(AccountEmojiStatuses)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetDefaultGroupPhotoEmojisParams struct {
	Hash int64
}

func (*AccountGetDefaultGroupPhotoEmojisParams) CRC() uint32 {
	return 0x915860ae
}

// Get a set of suggested custom emoji stickers that can be used as group picture
func (c *Client) AccountGetDefaultGroupPhotoEmojis(hash int64) (EmojiList, error) {
	responseData, err := c.MakeRequest(&AccountGetDefaultGroupPhotoEmojisParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetDefaultGroupPhotoEmojis")
	}

	resp, ok := responseData.(EmojiList)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetDefaultProfilePhotoEmojisParams struct {
	Hash int64
}

func (*AccountGetDefaultProfilePhotoEmojisParams) CRC() uint32 {
	return 0xe2750328
}

// Get a set of suggested custom emoji stickers that can be used as profile picture
func (c *Client) AccountGetDefaultProfilePhotoEmojis(hash int64) (EmojiList, error) {
	responseData, err := c.MakeRequest(&AccountGetDefaultProfilePhotoEmojisParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetDefaultProfilePhotoEmojis")
	}

	resp, ok := responseData.(EmojiList)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetGlobalPrivacySettingsParams struct{}

func (*AccountGetGlobalPrivacySettingsParams) CRC() uint32 {
	return 0xeb2b4cf6
}

// Get global privacy settings
func (c *Client) AccountGetGlobalPrivacySettings() (*GlobalPrivacySettings, error) {
	responseData, err := c.MakeRequest(&AccountGetGlobalPrivacySettingsParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetGlobalPrivacySettings")
	}

	resp, ok := responseData.(*GlobalPrivacySettings)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetMultiWallPapersParams struct {
	Wallpapers []InputWallPaper
}

func (*AccountGetMultiWallPapersParams) CRC() uint32 {
	return 0x65ad71dc
}

// Get info about multiple wallpapers
func (c *Client) AccountGetMultiWallPapers(wallpapers []InputWallPaper) ([]WallPaper, error) {
	responseData, err := c.MakeRequest(&AccountGetMultiWallPapersParams{Wallpapers: wallpapers})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetMultiWallPapers")
	}

	resp, ok := responseData.([]WallPaper)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetNotifyExceptionsParams struct {
	CompareSound   bool            `tl:"flag:1,encoded_in_bitflags"`
	CompareStories bool            `tl:"flag:2,encoded_in_bitflags"`
	Peer           InputNotifyPeer `tl:"flag:0"`
}

func (*AccountGetNotifyExceptionsParams) CRC() uint32 {
	return 0x53577479
}

func (*AccountGetNotifyExceptionsParams) FlagIndex() int {
	return 0
}

// Returns list of chats with non-default notification settings
func (c *Client) AccountGetNotifyExceptions(compareSound, compareStories bool, peer InputNotifyPeer) (Updates, error) {
	responseData, err := c.MakeRequest(&AccountGetNotifyExceptionsParams{
		CompareSound:   compareSound,
		CompareStories: compareStories,
		Peer:           peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetNotifyExceptions")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetNotifySettingsParams struct {
	Peer InputNotifyPeer
}

func (*AccountGetNotifySettingsParams) CRC() uint32 {
	return 0x12b3ad31
}

// Gets current notification settings for a given user/group, from all users/all groups.
func (c *Client) AccountGetNotifySettings(peer InputNotifyPeer) (*PeerNotifySettings, error) {
	responseData, err := c.MakeRequest(&AccountGetNotifySettingsParams{Peer: peer})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetNotifySettings")
	}

	resp, ok := responseData.(*PeerNotifySettings)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetPasswordParams struct{}

func (*AccountGetPasswordParams) CRC() uint32 {
	return 0x548a30f5
}

// Obtain configuration for two-factor authorization with password
func (c *Client) AccountGetPassword() (*AccountPassword, error) {
	responseData, err := c.MakeRequest(&AccountGetPasswordParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetPassword")
	}

	resp, ok := responseData.(*AccountPassword)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetPasswordSettingsParams struct {
	Password InputCheckPasswordSRP
}

func (*AccountGetPasswordSettingsParams) CRC() uint32 {
	return 0x9cd4eaf9
}

// Get private info associated to the password info (recovery email, telegram passport info &amp; so on)
func (c *Client) AccountGetPasswordSettings(password InputCheckPasswordSRP) (*AccountPasswordSettings, error) {
	responseData, err := c.MakeRequest(&AccountGetPasswordSettingsParams{Password: password})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetPasswordSettings")
	}

	resp, ok := responseData.(*AccountPasswordSettings)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetPrivacyParams struct {
	Key InputPrivacyKey
}

func (*AccountGetPrivacyParams) CRC() uint32 {
	return 0xdadbc950
}

// Get privacy settings of current account
func (c *Client) AccountGetPrivacy(key InputPrivacyKey) (*AccountPrivacyRules, error) {
	responseData, err := c.MakeRequest(&AccountGetPrivacyParams{Key: key})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetPrivacy")
	}

	resp, ok := responseData.(*AccountPrivacyRules)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetReactionsNotifySettingsParams struct{}

func (*AccountGetReactionsNotifySettingsParams) CRC() uint32 {
	return 0x6dd654c
}

// Get the current reaction notification settings ».
func (c *Client) AccountGetReactionsNotifySettings() (*ReactionsNotifySettings, error) {
	responseData, err := c.MakeRequest(&AccountGetReactionsNotifySettingsParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetReactionsNotifySettings")
	}

	resp, ok := responseData.(*ReactionsNotifySettings)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetRecentEmojiStatusesParams struct {
	Hash int64
}

func (*AccountGetRecentEmojiStatusesParams) CRC() uint32 {
	return 0xf578105
}

// Get recently used emoji statuses
func (c *Client) AccountGetRecentEmojiStatuses(hash int64) (AccountEmojiStatuses, error) {
	responseData, err := c.MakeRequest(&AccountGetRecentEmojiStatusesParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetRecentEmojiStatuses")
	}

	resp, ok := responseData.(AccountEmojiStatuses)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetSavedRingtonesParams struct {
	Hash int64
}

func (*AccountGetSavedRingtonesParams) CRC() uint32 {
	return 0xe1902288
}

// Fetch saved notification sounds
func (c *Client) AccountGetSavedRingtones(hash int64) (AccountSavedRingtones, error) {
	responseData, err := c.MakeRequest(&AccountGetSavedRingtonesParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetSavedRingtones")
	}

	resp, ok := responseData.(AccountSavedRingtones)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetSecureValueParams struct {
	Types []SecureValueType
}

func (*AccountGetSecureValueParams) CRC() uint32 {
	return 0x73665bc2
}

// Get saved Telegram Passport document, for more info see the passport docs »
func (c *Client) AccountGetSecureValue(types []SecureValueType) ([]*SecureValue, error) {
	responseData, err := c.MakeRequest(&AccountGetSecureValueParams{Types: types})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetSecureValue")
	}

	resp, ok := responseData.([]*SecureValue)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetThemeParams struct {
	Format string
	Theme  InputTheme
}

func (*AccountGetThemeParams) CRC() uint32 {
	return 0x3a5869ec
}

// Get theme information
func (c *Client) AccountGetTheme(format string, theme InputTheme) (*Theme, error) {
	responseData, err := c.MakeRequest(&AccountGetThemeParams{
		Format: format,
		Theme:  theme,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetTheme")
	}

	resp, ok := responseData.(*Theme)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetThemesParams struct {
	Format string
	Hash   int64
}

func (*AccountGetThemesParams) CRC() uint32 {
	return 0x7206e458
}

// Get installed themes
func (c *Client) AccountGetThemes(format string, hash int64) (AccountThemes, error) {
	responseData, err := c.MakeRequest(&AccountGetThemesParams{
		Format: format,
		Hash:   hash,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetThemes")
	}

	resp, ok := responseData.(AccountThemes)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetTmpPasswordParams struct {
	Password InputCheckPasswordSRP
	Period   int32
}

func (*AccountGetTmpPasswordParams) CRC() uint32 {
	return 0x449e0b51
}

// Get temporary payment password
func (c *Client) AccountGetTmpPassword(password InputCheckPasswordSRP, period int32) (*AccountTmpPassword, error) {
	responseData, err := c.MakeRequest(&AccountGetTmpPasswordParams{
		Password: password,
		Period:   period,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetTmpPassword")
	}

	resp, ok := responseData.(*AccountTmpPassword)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetWallPaperParams struct {
	Wallpaper InputWallPaper
}

func (*AccountGetWallPaperParams) CRC() uint32 {
	return 0xfc8ddbea
}

// Get info about a certain wallpaper
func (c *Client) AccountGetWallPaper(wallpaper InputWallPaper) (WallPaper, error) {
	responseData, err := c.MakeRequest(&AccountGetWallPaperParams{Wallpaper: wallpaper})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetWallPaper")
	}

	resp, ok := responseData.(WallPaper)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetWallPapersParams struct {
	Hash int64
}

func (*AccountGetWallPapersParams) CRC() uint32 {
	return 0x7967d36
}

// Returns a list of available wallpapers.
func (c *Client) AccountGetWallPapers(hash int64) (AccountWallPapers, error) {
	responseData, err := c.MakeRequest(&AccountGetWallPapersParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetWallPapers")
	}

	resp, ok := responseData.(AccountWallPapers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountGetWebAuthorizationsParams struct{}

func (*AccountGetWebAuthorizationsParams) CRC() uint32 {
	return 0x182e6d6f
}

// Get web login widget authorizations
func (c *Client) AccountGetWebAuthorizations() (*AccountWebAuthorizations, error) {
	responseData, err := c.MakeRequest(&AccountGetWebAuthorizationsParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountGetWebAuthorizations")
	}

	resp, ok := responseData.(*AccountWebAuthorizations)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountInitTakeoutSessionParams struct {
	Contacts          bool  `tl:"flag:0,encoded_in_bitflags"`
	MessageUsers      bool  `tl:"flag:1,encoded_in_bitflags"`
	MessageChats      bool  `tl:"flag:2,encoded_in_bitflags"`
	MessageMegagroups bool  `tl:"flag:3,encoded_in_bitflags"`
	MessageChannels   bool  `tl:"flag:4,encoded_in_bitflags"`
	Files             bool  `tl:"flag:5,encoded_in_bitflags"`
	FileMaxSize       int64 `tl:"flag:5"`
}

func (*AccountInitTakeoutSessionParams) CRC() uint32 {
	return 0x8ef3eab0
}

func (*AccountInitTakeoutSessionParams) FlagIndex() int {
	return 0
}

// Initialize a takeout session, see here » for more info.
func (c *Client) AccountInitTakeoutSession(params *AccountInitTakeoutSessionParams) (*AccountTakeout, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountInitTakeoutSession")
	}

	resp, ok := responseData.(*AccountTakeout)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountInstallThemeParams struct {
	Dark      bool       `tl:"flag:0,encoded_in_bitflags"`
	Theme     InputTheme `tl:"flag:1"`
	Format    string     `tl:"flag:2"`
	BaseTheme BaseTheme  `tl:"flag:3"`
}

func (*AccountInstallThemeParams) CRC() uint32 {
	return 0xc727bb3b
}

func (*AccountInstallThemeParams) FlagIndex() int {
	return 0
}

// Install a theme
func (c *Client) AccountInstallTheme(dark bool, theme InputTheme, format string, baseTheme BaseTheme) (bool, error) {
	responseData, err := c.MakeRequest(&AccountInstallThemeParams{
		BaseTheme: baseTheme,
		Dark:      dark,
		Format:    format,
		Theme:     theme,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountInstallTheme")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountInstallWallPaperParams struct {
	Wallpaper InputWallPaper
	Settings  *WallPaperSettings
}

func (*AccountInstallWallPaperParams) CRC() uint32 {
	return 0xfeed5769
}

// Install wallpaper
func (c *Client) AccountInstallWallPaper(wallpaper InputWallPaper, settings *WallPaperSettings) (bool, error) {
	responseData, err := c.MakeRequest(&AccountInstallWallPaperParams{
		Settings:  settings,
		Wallpaper: wallpaper,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountInstallWallPaper")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountInvalidateSignInCodesParams struct {
	Codes []string
}

func (*AccountInvalidateSignInCodesParams) CRC() uint32 {
	return 0xca8ae8ba
}

// Invalidate the specified login codes, see here » for more info.
func (c *Client) AccountInvalidateSignInCodes(codes []string) (bool, error) {
	responseData, err := c.MakeRequest(&AccountInvalidateSignInCodesParams{Codes: codes})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountInvalidateSignInCodes")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountRegisterDeviceParams struct {
	NoMuted    bool `tl:"flag:0,encoded_in_bitflags"`
	TokenType  int32
	Token      string
	AppSandbox bool
	Secret     []byte
	OtherUids  []int64
}

func (*AccountRegisterDeviceParams) CRC() uint32 {
	return 0xec86017a
}

func (*AccountRegisterDeviceParams) FlagIndex() int {
	return 0
}

// Register device to receive PUSH notifications
func (c *Client) AccountRegisterDevice(params *AccountRegisterDeviceParams) (bool, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return false, errors.Wrap(err, "sending AccountRegisterDevice")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountReorderUsernamesParams struct {
	Order []string
}

func (*AccountReorderUsernamesParams) CRC() uint32 {
	return 0xef500eab
}

// Reorder usernames associated with the currently logged-in user.
func (c *Client) AccountReorderUsernames(order []string) (bool, error) {
	responseData, err := c.MakeRequest(&AccountReorderUsernamesParams{Order: order})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountReorderUsernames")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountReportPeerParams struct {
	Peer    InputPeer
	Reason  ReportReason
	Message string
}

func (*AccountReportPeerParams) CRC() uint32 {
	return 0xc5ba3d86
}

// Report a peer for violation of telegram's Terms of Service
func (c *Client) AccountReportPeer(peer InputPeer, reason ReportReason, message string) (bool, error) {
	responseData, err := c.MakeRequest(&AccountReportPeerParams{
		Message: message,
		Peer:    peer,
		Reason:  reason,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountReportPeer")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountReportProfilePhotoParams struct {
	Peer    InputPeer
	PhotoID InputPhoto
	Reason  ReportReason
	Message string
}

func (*AccountReportProfilePhotoParams) CRC() uint32 {
	return 0xfa8cc6f5
}

// Report a profile photo of a dialog
func (c *Client) AccountReportProfilePhoto(peer InputPeer, photoID InputPhoto, reason ReportReason, message string) (bool, error) {
	responseData, err := c.MakeRequest(&AccountReportProfilePhotoParams{
		Message: message,
		Peer:    peer,
		PhotoID: photoID,
		Reason:  reason,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountReportProfilePhoto")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountResendPasswordEmailParams struct{}

func (*AccountResendPasswordEmailParams) CRC() uint32 {
	return 0x7a7f2a15
}

// Resend the code to verify an email to use as 2FA recovery method.
func (c *Client) AccountResendPasswordEmail() (bool, error) {
	responseData, err := c.MakeRequest(&AccountResendPasswordEmailParams{})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountResendPasswordEmail")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountResetAuthorizationParams struct {
	Hash int64
}

func (*AccountResetAuthorizationParams) CRC() uint32 {
	return 0xdf77f3bc
}

// Log out an active authorized session by its hash
func (c *Client) AccountResetAuthorization(hash int64) (bool, error) {
	responseData, err := c.MakeRequest(&AccountResetAuthorizationParams{Hash: hash})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountResetAuthorization")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountResetNotifySettingsParams struct{}

func (*AccountResetNotifySettingsParams) CRC() uint32 {
	return 0xdb7e1747
}

// Resets all notification settings from users and groups.
func (c *Client) AccountResetNotifySettings() (bool, error) {
	responseData, err := c.MakeRequest(&AccountResetNotifySettingsParams{})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountResetNotifySettings")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountResetPasswordParams struct{}

func (*AccountResetPasswordParams) CRC() uint32 {
	return 0x9308ce1b
}

// Initiate a 2FA password reset: can only be used if the user is already logged-in, see here for more info »
func (c *Client) AccountResetPassword() (AccountResetPasswordResult, error) {
	responseData, err := c.MakeRequest(&AccountResetPasswordParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountResetPassword")
	}

	resp, ok := responseData.(AccountResetPasswordResult)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountResetWallPapersParams struct{}

func (*AccountResetWallPapersParams) CRC() uint32 {
	return 0xbb3b9804
}

// Delete all installed wallpapers, reverting to the default wallpaper set.
func (c *Client) AccountResetWallPapers() (bool, error) {
	responseData, err := c.MakeRequest(&AccountResetWallPapersParams{})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountResetWallPapers")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountResetWebAuthorizationParams struct {
	Hash int64
}

func (*AccountResetWebAuthorizationParams) CRC() uint32 {
	return 0x2d01b9ef
}

// Log out an active web telegram login session
func (c *Client) AccountResetWebAuthorization(hash int64) (bool, error) {
	responseData, err := c.MakeRequest(&AccountResetWebAuthorizationParams{Hash: hash})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountResetWebAuthorization")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountResetWebAuthorizationsParams struct{}

func (*AccountResetWebAuthorizationsParams) CRC() uint32 {
	return 0x682d2594
}

// Reset all active web telegram login sessions
func (c *Client) AccountResetWebAuthorizations() (bool, error) {
	responseData, err := c.MakeRequest(&AccountResetWebAuthorizationsParams{})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountResetWebAuthorizations")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountResolveBusinessChatLinkParams struct {
	Slug string
}

func (*AccountResolveBusinessChatLinkParams) CRC() uint32 {
	return 0x5492e5ee
}

// Resolve a business chat deep link ».
func (c *Client) AccountResolveBusinessChatLink(slug string) (*AccountResolvedBusinessChatLinks, error) {
	responseData, err := c.MakeRequest(&AccountResolveBusinessChatLinkParams{Slug: slug})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountResolveBusinessChatLink")
	}

	resp, ok := responseData.(*AccountResolvedBusinessChatLinks)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSaveAutoDownloadSettingsParams struct {
	Low      bool `tl:"flag:0,encoded_in_bitflags"`
	High     bool `tl:"flag:1,encoded_in_bitflags"`
	Settings *AutoDownloadSettings
}

func (*AccountSaveAutoDownloadSettingsParams) CRC() uint32 {
	return 0x76f36233
}

func (*AccountSaveAutoDownloadSettingsParams) FlagIndex() int {
	return 0
}

// Change media autodownload settings
func (c *Client) AccountSaveAutoDownloadSettings(low, high bool, settings *AutoDownloadSettings) (bool, error) {
	responseData, err := c.MakeRequest(&AccountSaveAutoDownloadSettingsParams{
		High:     high,
		Low:      low,
		Settings: settings,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountSaveAutoDownloadSettings")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSaveAutoSaveSettingsParams struct {
	Users      bool      `tl:"flag:0,encoded_in_bitflags"`
	Chats      bool      `tl:"flag:1,encoded_in_bitflags"`
	Broadcasts bool      `tl:"flag:2,encoded_in_bitflags"`
	Peer       InputPeer `tl:"flag:3"`
	Settings   *AutoSaveSettings
}

func (*AccountSaveAutoSaveSettingsParams) CRC() uint32 {
	return 0xd69b8361
}

func (*AccountSaveAutoSaveSettingsParams) FlagIndex() int {
	return 0
}

// Modify autosave settings
func (c *Client) AccountSaveAutoSaveSettings(params *AccountSaveAutoSaveSettingsParams) (bool, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return false, errors.Wrap(err, "sending AccountSaveAutoSaveSettings")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSaveRingtoneParams struct {
	ID     InputDocument
	Unsave bool
}

func (*AccountSaveRingtoneParams) CRC() uint32 {
	return 0x3dea5b03
}

// Save or remove saved notification sound.
func (c *Client) AccountSaveRingtone(id InputDocument, unsave bool) (AccountSavedRingtone, error) {
	responseData, err := c.MakeRequest(&AccountSaveRingtoneParams{
		ID:     id,
		Unsave: unsave,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountSaveRingtone")
	}

	resp, ok := responseData.(AccountSavedRingtone)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSaveSecureValueParams struct {
	Value          *InputSecureValue
	SecureSecretID int64
}

func (*AccountSaveSecureValueParams) CRC() uint32 {
	return 0x899fe31d
}

// Securely save Telegram Passport document, for more info see the passport docs »
func (c *Client) AccountSaveSecureValue(value *InputSecureValue, secureSecretID int64) (*SecureValue, error) {
	responseData, err := c.MakeRequest(&AccountSaveSecureValueParams{
		SecureSecretID: secureSecretID,
		Value:          value,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountSaveSecureValue")
	}

	resp, ok := responseData.(*SecureValue)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSaveThemeParams struct {
	Theme  InputTheme
	Unsave bool
}

func (*AccountSaveThemeParams) CRC() uint32 {
	return 0xf257106c
}

// Save a theme
func (c *Client) AccountSaveTheme(theme InputTheme, unsave bool) (bool, error) {
	responseData, err := c.MakeRequest(&AccountSaveThemeParams{
		Theme:  theme,
		Unsave: unsave,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountSaveTheme")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSaveWallPaperParams struct {
	Wallpaper InputWallPaper
	Unsave    bool
	Settings  *WallPaperSettings
}

func (*AccountSaveWallPaperParams) CRC() uint32 {
	return 0x6c5a5b37
}

// Install/uninstall wallpaper
func (c *Client) AccountSaveWallPaper(wallpaper InputWallPaper, unsave bool, settings *WallPaperSettings) (bool, error) {
	responseData, err := c.MakeRequest(&AccountSaveWallPaperParams{
		Settings:  settings,
		Unsave:    unsave,
		Wallpaper: wallpaper,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountSaveWallPaper")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSendChangePhoneCodeParams struct {
	PhoneNumber string
	Settings    *CodeSettings
}

func (*AccountSendChangePhoneCodeParams) CRC() uint32 {
	return 0x82574ae5
}

// Verify a new phone number to associate to the current account
func (c *Client) AccountSendChangePhoneCode(phoneNumber string, settings *CodeSettings) (AuthSentCode, error) {
	responseData, err := c.MakeRequest(&AccountSendChangePhoneCodeParams{
		PhoneNumber: phoneNumber,
		Settings:    settings,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountSendChangePhoneCode")
	}

	resp, ok := responseData.(AuthSentCode)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSendConfirmPhoneCodeParams struct {
	Hash     string
	Settings *CodeSettings
}

func (*AccountSendConfirmPhoneCodeParams) CRC() uint32 {
	return 0x1b3faa88
}

// Send confirmation code to cancel account deletion, for more info click here »
func (c *Client) AccountSendConfirmPhoneCode(hash string, settings *CodeSettings) (AuthSentCode, error) {
	responseData, err := c.MakeRequest(&AccountSendConfirmPhoneCodeParams{
		Hash:     hash,
		Settings: settings,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountSendConfirmPhoneCode")
	}

	resp, ok := responseData.(AuthSentCode)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSendVerifyEmailCodeParams struct {
	Purpose EmailVerifyPurpose
	Email   string
}

func (*AccountSendVerifyEmailCodeParams) CRC() uint32 {
	return 0x98e037bb
}

// Send an email verification code.
func (c *Client) AccountSendVerifyEmailCode(purpose EmailVerifyPurpose, email string) (*AccountSentEmailCode, error) {
	responseData, err := c.MakeRequest(&AccountSendVerifyEmailCodeParams{
		Email:   email,
		Purpose: purpose,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountSendVerifyEmailCode")
	}

	resp, ok := responseData.(*AccountSentEmailCode)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSendVerifyPhoneCodeParams struct {
	PhoneNumber string
	Settings    *CodeSettings
}

func (*AccountSendVerifyPhoneCodeParams) CRC() uint32 {
	return 0xa5a356f9
}

// Send the verification phone code for telegram passport.
func (c *Client) AccountSendVerifyPhoneCode(phoneNumber string, settings *CodeSettings) (AuthSentCode, error) {
	responseData, err := c.MakeRequest(&AccountSendVerifyPhoneCodeParams{
		PhoneNumber: phoneNumber,
		Settings:    settings,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountSendVerifyPhoneCode")
	}

	resp, ok := responseData.(AuthSentCode)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSetAccountTtlParams struct {
	Ttl *AccountDaysTtl
}

func (*AccountSetAccountTtlParams) CRC() uint32 {
	return 0x2442485e
}

// Set account self-destruction period
func (c *Client) AccountSetAccountTtl(ttl *AccountDaysTtl) (bool, error) {
	responseData, err := c.MakeRequest(&AccountSetAccountTtlParams{Ttl: ttl})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountSetAccountTtl")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSetAuthorizationTtlParams struct {
	AuthorizationTtlDays int32
}

func (*AccountSetAuthorizationTtlParams) CRC() uint32 {
	return 0xbf899aa0
}

// Set time-to-live of current session
func (c *Client) AccountSetAuthorizationTtl(authorizationTtlDays int32) (bool, error) {
	responseData, err := c.MakeRequest(&AccountSetAuthorizationTtlParams{AuthorizationTtlDays: authorizationTtlDays})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountSetAuthorizationTtl")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSetContactSignUpNotificationParams struct {
	Silent bool
}

func (*AccountSetContactSignUpNotificationParams) CRC() uint32 {
	return 0xcff43f61
}

// Toggle contact sign up notifications
func (c *Client) AccountSetContactSignUpNotification(silent bool) (bool, error) {
	responseData, err := c.MakeRequest(&AccountSetContactSignUpNotificationParams{Silent: silent})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountSetContactSignUpNotification")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSetContentSettingsParams struct {
	SensitiveEnabled bool `tl:"flag:0,encoded_in_bitflags"`
}

func (*AccountSetContentSettingsParams) CRC() uint32 {
	return 0xb574b16b
}

func (*AccountSetContentSettingsParams) FlagIndex() int {
	return 0
}

// Set sensitive content settings (for viewing or hiding NSFW content)
func (c *Client) AccountSetContentSettings(sensitiveEnabled bool) (bool, error) {
	responseData, err := c.MakeRequest(&AccountSetContentSettingsParams{SensitiveEnabled: sensitiveEnabled})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountSetContentSettings")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSetGlobalPrivacySettingsParams struct {
	Settings *GlobalPrivacySettings
}

func (*AccountSetGlobalPrivacySettingsParams) CRC() uint32 {
	return 0x1edaaac2
}

// Set global privacy settings
func (c *Client) AccountSetGlobalPrivacySettings(settings *GlobalPrivacySettings) (*GlobalPrivacySettings, error) {
	responseData, err := c.MakeRequest(&AccountSetGlobalPrivacySettingsParams{Settings: settings})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountSetGlobalPrivacySettings")
	}

	resp, ok := responseData.(*GlobalPrivacySettings)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSetPrivacyParams struct {
	Key   InputPrivacyKey
	Rules []InputPrivacyRule
}

func (*AccountSetPrivacyParams) CRC() uint32 {
	return 0xc9f81ce8
}

// Change privacy settings of current account
func (c *Client) AccountSetPrivacy(key InputPrivacyKey, rules []InputPrivacyRule) (*AccountPrivacyRules, error) {
	responseData, err := c.MakeRequest(&AccountSetPrivacyParams{
		Key:   key,
		Rules: rules,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountSetPrivacy")
	}

	resp, ok := responseData.(*AccountPrivacyRules)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountSetReactionsNotifySettingsParams struct {
	Settings *ReactionsNotifySettings
}

func (*AccountSetReactionsNotifySettingsParams) CRC() uint32 {
	return 0x316ce548
}

// Change the reaction notification settings ».
func (c *Client) AccountSetReactionsNotifySettings(settings *ReactionsNotifySettings) (*ReactionsNotifySettings, error) {
	responseData, err := c.MakeRequest(&AccountSetReactionsNotifySettingsParams{Settings: settings})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountSetReactionsNotifySettings")
	}

	resp, ok := responseData.(*ReactionsNotifySettings)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountToggleConnectedBotPausedParams struct {
	Peer   InputPeer
	Paused bool
}

func (*AccountToggleConnectedBotPausedParams) CRC() uint32 {
	return 0x646e1097
}

// Pause or unpause a specific chat, temporarily disconnecting it from all business bots ».
func (c *Client) AccountToggleConnectedBotPaused(peer InputPeer, paused bool) (bool, error) {
	responseData, err := c.MakeRequest(&AccountToggleConnectedBotPausedParams{
		Paused: paused,
		Peer:   peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountToggleConnectedBotPaused")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountToggleSponsoredMessagesParams struct {
	Enabled bool
}

func (*AccountToggleSponsoredMessagesParams) CRC() uint32 {
	return 0xb9d9a38d
}

// Disable or re-enable Telegram ads for the current Premium account.
func (c *Client) AccountToggleSponsoredMessages(enabled bool) (bool, error) {
	responseData, err := c.MakeRequest(&AccountToggleSponsoredMessagesParams{Enabled: enabled})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountToggleSponsoredMessages")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountToggleUsernameParams struct {
	Username string
	Active   bool
}

func (*AccountToggleUsernameParams) CRC() uint32 {
	return 0x58d6b376
}

// Activate or deactivate a purchased fragment.com username associated to the currently logged-in user.
func (c *Client) AccountToggleUsername(username string, active bool) (bool, error) {
	responseData, err := c.MakeRequest(&AccountToggleUsernameParams{
		Active:   active,
		Username: username,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountToggleUsername")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUnregisterDeviceParams struct {
	TokenType int32
	Token     string
	OtherUids []int64
}

func (*AccountUnregisterDeviceParams) CRC() uint32 {
	return 0x6a0d3206
}

// Deletes a device by its token, stops sending PUSH-notifications to it.
func (c *Client) AccountUnregisterDevice(tokenType int32, token string, otherUids []int64) (bool, error) {
	responseData, err := c.MakeRequest(&AccountUnregisterDeviceParams{
		OtherUids: otherUids,
		Token:     token,
		TokenType: tokenType,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountUnregisterDevice")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdateBirthdayParams struct {
	Birthday *Birthday `tl:"flag:0"`
}

func (*AccountUpdateBirthdayParams) CRC() uint32 {
	return 0xcc6e0c11
}

func (*AccountUpdateBirthdayParams) FlagIndex() int {
	return 0
}

// Update our birthday, see here » for more info.
func (c *Client) AccountUpdateBirthday(birthday *Birthday) (bool, error) {
	responseData, err := c.MakeRequest(&AccountUpdateBirthdayParams{Birthday: birthday})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountUpdateBirthday")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdateBusinessAwayMessageParams struct {
	Message *InputBusinessAwayMessage `tl:"flag:0"`
}

func (*AccountUpdateBusinessAwayMessageParams) CRC() uint32 {
	return 0xa26a7fa5
}

func (*AccountUpdateBusinessAwayMessageParams) FlagIndex() int {
	return 0
}

// Set a list of Telegram Business away messages.
func (c *Client) AccountUpdateBusinessAwayMessage(message *InputBusinessAwayMessage) (bool, error) {
	responseData, err := c.MakeRequest(&AccountUpdateBusinessAwayMessageParams{Message: message})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountUpdateBusinessAwayMessage")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdateBusinessGreetingMessageParams struct {
	Message *InputBusinessGreetingMessage `tl:"flag:0"`
}

func (*AccountUpdateBusinessGreetingMessageParams) CRC() uint32 {
	return 0x66cdafc4
}

func (*AccountUpdateBusinessGreetingMessageParams) FlagIndex() int {
	return 0
}

// Set a list of Telegram Business greeting messages.
func (c *Client) AccountUpdateBusinessGreetingMessage(message *InputBusinessGreetingMessage) (bool, error) {
	responseData, err := c.MakeRequest(&AccountUpdateBusinessGreetingMessageParams{Message: message})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountUpdateBusinessGreetingMessage")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdateBusinessIntroParams struct {
	Intro *InputBusinessIntro `tl:"flag:0"`
}

func (*AccountUpdateBusinessIntroParams) CRC() uint32 {
	return 0xa614d034
}

func (*AccountUpdateBusinessIntroParams) FlagIndex() int {
	return 0
}

// Set or remove the Telegram Business introduction ».
func (c *Client) AccountUpdateBusinessIntro(intro *InputBusinessIntro) (bool, error) {
	responseData, err := c.MakeRequest(&AccountUpdateBusinessIntroParams{Intro: intro})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountUpdateBusinessIntro")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdateBusinessLocationParams struct {
	GeoPoint InputGeoPoint `tl:"flag:1"`
	Address  string        `tl:"flag:0"`
}

func (*AccountUpdateBusinessLocationParams) CRC() uint32 {
	return 0x9e6b131a
}

func (*AccountUpdateBusinessLocationParams) FlagIndex() int {
	return 0
}

// Businesses » may advertise their location using this method, see here » for more info.
func (c *Client) AccountUpdateBusinessLocation(geoPoint InputGeoPoint, address string) (bool, error) {
	responseData, err := c.MakeRequest(&AccountUpdateBusinessLocationParams{
		Address:  address,
		GeoPoint: geoPoint,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountUpdateBusinessLocation")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdateBusinessWorkHoursParams struct {
	BusinessWorkHours *BusinessWorkHours `tl:"flag:0"`
}

func (*AccountUpdateBusinessWorkHoursParams) CRC() uint32 {
	return 0x4b00e066
}

func (*AccountUpdateBusinessWorkHoursParams) FlagIndex() int {
	return 0
}

/*
Specify a set of Telegram Business opening hours.<br>
This info will be contained in userFull.`business_work_hours`.
*/
func (c *Client) AccountUpdateBusinessWorkHours(businessWorkHours *BusinessWorkHours) (bool, error) {
	responseData, err := c.MakeRequest(&AccountUpdateBusinessWorkHoursParams{BusinessWorkHours: businessWorkHours})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountUpdateBusinessWorkHours")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdateColorParams struct {
	ForProfile        bool  `tl:"flag:1,encoded_in_bitflags"`
	Color             int32 `tl:"flag:2"`
	BackgroundEmojiID int64 `tl:"flag:0"`
}

func (*AccountUpdateColorParams) CRC() uint32 {
	return 0x7cefa15d
}

func (*AccountUpdateColorParams) FlagIndex() int {
	return 0
}

// Update the accent color and background custom emoji » of the current account.
func (c *Client) AccountUpdateColor(forProfile bool, color int32, backgroundEmojiID int64) (bool, error) {
	responseData, err := c.MakeRequest(&AccountUpdateColorParams{
		BackgroundEmojiID: backgroundEmojiID,
		Color:             color,
		ForProfile:        forProfile,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountUpdateColor")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdateConnectedBotParams struct {
	CanReply   bool `tl:"flag:0,encoded_in_bitflags"`
	Deleted    bool `tl:"flag:1,encoded_in_bitflags"`
	Bot        InputUser
	Recipients *InputBusinessBotRecipients
}

func (*AccountUpdateConnectedBotParams) CRC() uint32 {
	return 0x43d8521d
}

func (*AccountUpdateConnectedBotParams) FlagIndex() int {
	return 0
}

// Connect a business bot » to the current account, or to change the current connection settings.
func (c *Client) AccountUpdateConnectedBot(canReply, deleted bool, bot InputUser, recipients *InputBusinessBotRecipients) (Updates, error) {
	responseData, err := c.MakeRequest(&AccountUpdateConnectedBotParams{
		Bot:        bot,
		CanReply:   canReply,
		Deleted:    deleted,
		Recipients: recipients,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountUpdateConnectedBot")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdateDeviceLockedParams struct {
	Period int32
}

func (*AccountUpdateDeviceLockedParams) CRC() uint32 {
	return 0x38df3532
}

// When client-side passcode lock feature is enabled, will not show message texts in incoming PUSH notifications.
func (c *Client) AccountUpdateDeviceLocked(period int32) (bool, error) {
	responseData, err := c.MakeRequest(&AccountUpdateDeviceLockedParams{Period: period})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountUpdateDeviceLocked")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdateEmojiStatusParams struct {
	EmojiStatus EmojiStatus
}

func (*AccountUpdateEmojiStatusParams) CRC() uint32 {
	return 0xfbd3de6b
}

// Set an emoji status
func (c *Client) AccountUpdateEmojiStatus(emojiStatus EmojiStatus) (bool, error) {
	responseData, err := c.MakeRequest(&AccountUpdateEmojiStatusParams{EmojiStatus: emojiStatus})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountUpdateEmojiStatus")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdateNotifySettingsParams struct {
	Peer     InputNotifyPeer
	Settings *InputPeerNotifySettings
}

func (*AccountUpdateNotifySettingsParams) CRC() uint32 {
	return 0x84be5b93
}

// Edits notification settings from a given user/group, from all users/all groups.
func (c *Client) AccountUpdateNotifySettings(peer InputNotifyPeer, settings *InputPeerNotifySettings) (bool, error) {
	responseData, err := c.MakeRequest(&AccountUpdateNotifySettingsParams{
		Peer:     peer,
		Settings: settings,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountUpdateNotifySettings")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdatePasswordSettingsParams struct {
	Password    InputCheckPasswordSRP
	NewSettings *AccountPasswordInputSettings
}

func (*AccountUpdatePasswordSettingsParams) CRC() uint32 {
	return 0xa59b102f
}

// Set a new 2FA password
func (c *Client) AccountUpdatePasswordSettings(password InputCheckPasswordSRP, newSettings *AccountPasswordInputSettings) (bool, error) {
	responseData, err := c.MakeRequest(&AccountUpdatePasswordSettingsParams{
		NewSettings: newSettings,
		Password:    password,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountUpdatePasswordSettings")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdatePersonalChannelParams struct {
	Channel InputChannel
}

func (*AccountUpdatePersonalChannelParams) CRC() uint32 {
	return 0xd94305e0
}

// Associate (or remove) a personal channel », that will be listed on our personal profile page ».
func (c *Client) AccountUpdatePersonalChannel(channel InputChannel) (bool, error) {
	responseData, err := c.MakeRequest(&AccountUpdatePersonalChannelParams{Channel: channel})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountUpdatePersonalChannel")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdateProfileParams struct {
	FirstName string `tl:"flag:0"`
	LastName  string `tl:"flag:1"`
	About     string `tl:"flag:2"`
}

func (*AccountUpdateProfileParams) CRC() uint32 {
	return 0x78515775
}

func (*AccountUpdateProfileParams) FlagIndex() int {
	return 0
}

// Updates user profile.
func (c *Client) AccountUpdateProfile(firstName, lastName, about string) (User, error) {
	responseData, err := c.MakeRequest(&AccountUpdateProfileParams{
		About:     about,
		FirstName: firstName,
		LastName:  lastName,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountUpdateProfile")
	}

	resp, ok := responseData.(User)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdateStatusParams struct {
	Offline bool
}

func (*AccountUpdateStatusParams) CRC() uint32 {
	return 0x6628562c
}

// Updates online user status.
func (c *Client) AccountUpdateStatus(offline bool) (bool, error) {
	responseData, err := c.MakeRequest(&AccountUpdateStatusParams{Offline: offline})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountUpdateStatus")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdateThemeParams struct {
	Format   string
	Theme    InputTheme
	Slug     string                `tl:"flag:0"`
	Title    string                `tl:"flag:1"`
	Document InputDocument         `tl:"flag:2"`
	Settings []*InputThemeSettings `tl:"flag:3"`
}

func (*AccountUpdateThemeParams) CRC() uint32 {
	return 0x2bf40ccc
}

func (*AccountUpdateThemeParams) FlagIndex() int {
	return 0
}

// Update theme
func (c *Client) AccountUpdateTheme(params *AccountUpdateThemeParams) (*Theme, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountUpdateTheme")
	}

	resp, ok := responseData.(*Theme)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUpdateUsernameParams struct {
	Username string
}

func (*AccountUpdateUsernameParams) CRC() uint32 {
	return 0x3e0bdd7c
}

// Changes username for the current user.
func (c *Client) AccountUpdateUsername(username string) (User, error) {
	responseData, err := c.MakeRequest(&AccountUpdateUsernameParams{Username: username})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountUpdateUsername")
	}

	resp, ok := responseData.(User)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUploadRingtoneParams struct {
	File     InputFile
	FileName string
	MimeType string
}

func (*AccountUploadRingtoneParams) CRC() uint32 {
	return 0x831a83a2
}

// Upload notification sound, use account.saveRingtone to convert it and add it to the list of saved notification sounds.
func (c *Client) AccountUploadRingtone(file InputFile, fileName, mimeType string) (Document, error) {
	responseData, err := c.MakeRequest(&AccountUploadRingtoneParams{
		File:     file,
		FileName: fileName,
		MimeType: mimeType,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountUploadRingtone")
	}

	resp, ok := responseData.(Document)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUploadThemeParams struct {
	File     InputFile
	Thumb    InputFile `tl:"flag:0"`
	FileName string
	MimeType string
}

func (*AccountUploadThemeParams) CRC() uint32 {
	return 0x1c3db333
}

func (*AccountUploadThemeParams) FlagIndex() int {
	return 0
}

// Upload theme
func (c *Client) AccountUploadTheme(file, thumb InputFile, fileName, mimeType string) (Document, error) {
	responseData, err := c.MakeRequest(&AccountUploadThemeParams{
		File:     file,
		FileName: fileName,
		MimeType: mimeType,
		Thumb:    thumb,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountUploadTheme")
	}

	resp, ok := responseData.(Document)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountUploadWallPaperParams struct {
	ForChat  bool `tl:"flag:0,encoded_in_bitflags"`
	File     InputFile
	MimeType string
	Settings *WallPaperSettings
}

func (*AccountUploadWallPaperParams) CRC() uint32 {
	return 0xe39a8f03
}

func (*AccountUploadWallPaperParams) FlagIndex() int {
	return 0
}

// Create and upload a new wallpaper
func (c *Client) AccountUploadWallPaper(forChat bool, file InputFile, mimeType string, settings *WallPaperSettings) (WallPaper, error) {
	responseData, err := c.MakeRequest(&AccountUploadWallPaperParams{
		File:     file,
		ForChat:  forChat,
		MimeType: mimeType,
		Settings: settings,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountUploadWallPaper")
	}

	resp, ok := responseData.(WallPaper)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountVerifyEmailParams struct {
	Purpose      EmailVerifyPurpose
	Verification EmailVerification
}

func (*AccountVerifyEmailParams) CRC() uint32 {
	return 0x32da4cf
}

// Verify an email address.
func (c *Client) AccountVerifyEmail(purpose EmailVerifyPurpose, verification EmailVerification) (AccountEmailVerified, error) {
	responseData, err := c.MakeRequest(&AccountVerifyEmailParams{
		Purpose:      purpose,
		Verification: verification,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AccountVerifyEmail")
	}

	resp, ok := responseData.(AccountEmailVerified)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AccountVerifyPhoneParams struct {
	PhoneNumber   string
	PhoneCodeHash string
	PhoneCode     string
}

func (*AccountVerifyPhoneParams) CRC() uint32 {
	return 0x4dd3a7f6
}

// Verify a phone number for telegram passport.
func (c *Client) AccountVerifyPhone(phoneNumber, phoneCodeHash, phoneCode string) (bool, error) {
	responseData, err := c.MakeRequest(&AccountVerifyPhoneParams{
		PhoneCode:     phoneCode,
		PhoneCodeHash: phoneCodeHash,
		PhoneNumber:   phoneNumber,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AccountVerifyPhone")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthAcceptLoginTokenParams struct {
	Token []byte
}

func (*AuthAcceptLoginTokenParams) CRC() uint32 {
	return 0xe894ad4d
}

// Accept QR code login token, logging in the app that generated it.
func (c *Client) AuthAcceptLoginToken(token []byte) (*Authorization, error) {
	responseData, err := c.MakeRequest(&AuthAcceptLoginTokenParams{Token: token})
	if err != nil {
		return nil, errors.Wrap(err, "sending AuthAcceptLoginToken")
	}

	resp, ok := responseData.(*Authorization)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthBindTempAuthKeyParams struct {
	PermAuthKeyID    int64
	Nonce            int64
	ExpiresAt        int32
	EncryptedMessage []byte
}

func (*AuthBindTempAuthKeyParams) CRC() uint32 {
	return 0xcdd42a05
}

// Binds a temporary authorization key `temp_auth_key_id` to the permanent authorization key `perm_auth_key_id`. Each permanent key may only be bound to one temporary key at a time, binding a new temporary key overwrites the previous one.
func (c *Client) AuthBindTempAuthKey(permAuthKeyID, nonce int64, expiresAt int32, encryptedMessage []byte) (bool, error) {
	responseData, err := c.MakeRequest(&AuthBindTempAuthKeyParams{
		EncryptedMessage: encryptedMessage,
		ExpiresAt:        expiresAt,
		Nonce:            nonce,
		PermAuthKeyID:    permAuthKeyID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AuthBindTempAuthKey")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthCancelCodeParams struct {
	PhoneNumber   string
	PhoneCodeHash string
}

func (*AuthCancelCodeParams) CRC() uint32 {
	return 0x1f040578
}

// Cancel the login verification code
func (c *Client) AuthCancelCode(phoneNumber, phoneCodeHash string) (bool, error) {
	responseData, err := c.MakeRequest(&AuthCancelCodeParams{
		PhoneCodeHash: phoneCodeHash,
		PhoneNumber:   phoneNumber,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AuthCancelCode")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthCheckPasswordParams struct {
	Password InputCheckPasswordSRP
}

func (*AuthCheckPasswordParams) CRC() uint32 {
	return 0xd18b4d16
}

// Try logging to an account protected by a 2FA password.
func (c *Client) AuthCheckPassword(password InputCheckPasswordSRP) (AuthAuthorization, error) {
	responseData, err := c.MakeRequest(&AuthCheckPasswordParams{Password: password})
	if err != nil {
		return nil, errors.Wrap(err, "sending AuthCheckPassword")
	}

	resp, ok := responseData.(AuthAuthorization)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthCheckRecoveryPasswordParams struct {
	Code string
}

func (*AuthCheckRecoveryPasswordParams) CRC() uint32 {
	return 0xd36bf79
}

// Check if the 2FA recovery code sent using auth.requestPasswordRecovery is valid, before passing it to auth.recoverPassword.
func (c *Client) AuthCheckRecoveryPassword(code string) (bool, error) {
	responseData, err := c.MakeRequest(&AuthCheckRecoveryPasswordParams{Code: code})
	if err != nil {
		return false, errors.Wrap(err, "sending AuthCheckRecoveryPassword")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthDropTempAuthKeysParams struct {
	ExceptAuthKeys []int64
}

func (*AuthDropTempAuthKeysParams) CRC() uint32 {
	return 0x8e48a188
}

// Delete all temporary authorization keys <strong>except for</strong> the ones specified
func (c *Client) AuthDropTempAuthKeys(exceptAuthKeys []int64) (bool, error) {
	responseData, err := c.MakeRequest(&AuthDropTempAuthKeysParams{ExceptAuthKeys: exceptAuthKeys})
	if err != nil {
		return false, errors.Wrap(err, "sending AuthDropTempAuthKeys")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthExportAuthorizationParams struct {
	DcID int32
}

func (*AuthExportAuthorizationParams) CRC() uint32 {
	return 0xe5bfffcd
}

// Returns data for copying authorization to another data-center.
func (c *Client) AuthExportAuthorization(dcID int32) (*AuthExportedAuthorization, error) {
	responseData, err := c.MakeRequest(&AuthExportAuthorizationParams{DcID: dcID})
	if err != nil {
		return nil, errors.Wrap(err, "sending AuthExportAuthorization")
	}

	resp, ok := responseData.(*AuthExportedAuthorization)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthExportLoginTokenParams struct {
	APIID     int32
	APIHash   string
	ExceptIds []int64
}

func (*AuthExportLoginTokenParams) CRC() uint32 {
	return 0xb7e085fe
}

/*
Generate a login token, for login via QR code.<br>
The generated login token should be encoded using base64url, then shown as a `tg://login?token=base64encodedtoken` deep link » in the QR code.
*/
func (c *Client) AuthExportLoginToken(apiID int32, apiHash string, exceptIds []int64) (AuthLoginToken, error) {
	responseData, err := c.MakeRequest(&AuthExportLoginTokenParams{
		APIHash:   apiHash,
		APIID:     apiID,
		ExceptIds: exceptIds,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AuthExportLoginToken")
	}

	resp, ok := responseData.(AuthLoginToken)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthImportAuthorizationParams struct {
	ID    int64
	Bytes []byte
}

func (*AuthImportAuthorizationParams) CRC() uint32 {
	return 0xa57a7dad
}

// Logs in a user using a key transmitted from his native data-center.
func (c *Client) AuthImportAuthorization(id int64, bytes []byte) (AuthAuthorization, error) {
	responseData, err := c.MakeRequest(&AuthImportAuthorizationParams{
		Bytes: bytes,
		ID:    id,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AuthImportAuthorization")
	}

	resp, ok := responseData.(AuthAuthorization)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthImportBotAuthorizationParams struct {
	Flags        int32
	APIID        int32
	APIHash      string
	BotAuthToken string
}

func (*AuthImportBotAuthorizationParams) CRC() uint32 {
	return 0x67a3ff2c
}

// Login as a bot
func (c *Client) AuthImportBotAuthorization(flags, apiID int32, apiHash, botAuthToken string) (AuthAuthorization, error) {
	responseData, err := c.MakeRequest(&AuthImportBotAuthorizationParams{
		APIHash:      apiHash,
		APIID:        apiID,
		BotAuthToken: botAuthToken,
		Flags:        flags,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AuthImportBotAuthorization")
	}

	resp, ok := responseData.(AuthAuthorization)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthImportLoginTokenParams struct {
	Token []byte
}

func (*AuthImportLoginTokenParams) CRC() uint32 {
	return 0x95ac5ce4
}

// Login using a redirected login token, generated in case of DC mismatch during QR code login.
func (c *Client) AuthImportLoginToken(token []byte) (AuthLoginToken, error) {
	responseData, err := c.MakeRequest(&AuthImportLoginTokenParams{Token: token})
	if err != nil {
		return nil, errors.Wrap(err, "sending AuthImportLoginToken")
	}

	resp, ok := responseData.(AuthLoginToken)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthImportWebTokenAuthorizationParams struct {
	APIID        int32
	APIHash      string
	WebAuthToken string
}

func (*AuthImportWebTokenAuthorizationParams) CRC() uint32 {
	return 0x2db873a9
}

// Login by importing an authorization token
func (c *Client) AuthImportWebTokenAuthorization(apiID int32, apiHash, webAuthToken string) (AuthAuthorization, error) {
	responseData, err := c.MakeRequest(&AuthImportWebTokenAuthorizationParams{
		APIHash:      apiHash,
		APIID:        apiID,
		WebAuthToken: webAuthToken,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AuthImportWebTokenAuthorization")
	}

	resp, ok := responseData.(AuthAuthorization)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthLogOutParams struct{}

func (*AuthLogOutParams) CRC() uint32 {
	return 0x3e72ba19
}

// Logs out the user.
func (c *Client) AuthLogOut() (*AuthLoggedOut, error) {
	responseData, err := c.MakeRequest(&AuthLogOutParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending AuthLogOut")
	}

	resp, ok := responseData.(*AuthLoggedOut)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthRecoverPasswordParams struct {
	Code        string
	NewSettings *AccountPasswordInputSettings `tl:"flag:0"`
}

func (*AuthRecoverPasswordParams) CRC() uint32 {
	return 0x37096c70
}

func (*AuthRecoverPasswordParams) FlagIndex() int {
	return 0
}

// Reset the 2FA password using the recovery code sent using auth.requestPasswordRecovery.
func (c *Client) AuthRecoverPassword(code string, newSettings *AccountPasswordInputSettings) (AuthAuthorization, error) {
	responseData, err := c.MakeRequest(&AuthRecoverPasswordParams{
		Code:        code,
		NewSettings: newSettings,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AuthRecoverPassword")
	}

	resp, ok := responseData.(AuthAuthorization)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthReportMissingCodeParams struct {
	PhoneNumber   string
	PhoneCodeHash string
	Mnc           string
}

func (*AuthReportMissingCodeParams) CRC() uint32 {
	return 0xcb9deff6
}

// Official apps only, reports that the SMS authentication code wasn't delivered.
func (c *Client) AuthReportMissingCode(phoneNumber, phoneCodeHash, mnc string) (bool, error) {
	responseData, err := c.MakeRequest(&AuthReportMissingCodeParams{
		Mnc:           mnc,
		PhoneCodeHash: phoneCodeHash,
		PhoneNumber:   phoneNumber,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending AuthReportMissingCode")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthRequestFirebaseSmsParams struct {
	PhoneNumber        string
	PhoneCodeHash      string
	SafetyNetToken     string `tl:"flag:0"`
	PlayIntegrityToken string `tl:"flag:2"`
	IosPushSecret      string `tl:"flag:1"`
}

func (*AuthRequestFirebaseSmsParams) CRC() uint32 {
	return 0x8e39261e
}

func (*AuthRequestFirebaseSmsParams) FlagIndex() int {
	return 0
}

// Request an SMS code via Firebase.
func (c *Client) AuthRequestFirebaseSms(params *AuthRequestFirebaseSmsParams) (bool, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return false, errors.Wrap(err, "sending AuthRequestFirebaseSms")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthRequestPasswordRecoveryParams struct{}

func (*AuthRequestPasswordRecoveryParams) CRC() uint32 {
	return 0xd897bc66
}

// Request recovery code of a 2FA password, only for accounts with a recovery email configured.
func (c *Client) AuthRequestPasswordRecovery() (*AuthPasswordRecovery, error) {
	responseData, err := c.MakeRequest(&AuthRequestPasswordRecoveryParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending AuthRequestPasswordRecovery")
	}

	resp, ok := responseData.(*AuthPasswordRecovery)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthResendCodeParams struct {
	PhoneNumber   string
	PhoneCodeHash string
	Reason        string `tl:"flag:0"`
}

func (*AuthResendCodeParams) CRC() uint32 {
	return 0xcae47523
}

func (*AuthResendCodeParams) FlagIndex() int {
	return 0
}

// Resend the login code via another medium, the phone code type is determined by the return value of the previous auth.sendCode/auth.resendCode: see login for more info.
func (c *Client) AuthResendCode(phoneNumber, phoneCodeHash, reason string) (AuthSentCode, error) {
	responseData, err := c.MakeRequest(&AuthResendCodeParams{
		PhoneCodeHash: phoneCodeHash,
		PhoneNumber:   phoneNumber,
		Reason:        reason,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AuthResendCode")
	}

	resp, ok := responseData.(AuthSentCode)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthResetAuthorizationsParams struct{}

func (*AuthResetAuthorizationsParams) CRC() uint32 {
	return 0x9fab0d1a
}

// Terminates all user's authorized sessions except for the current one.
func (c *Client) AuthResetAuthorizations() (bool, error) {
	responseData, err := c.MakeRequest(&AuthResetAuthorizationsParams{})
	if err != nil {
		return false, errors.Wrap(err, "sending AuthResetAuthorizations")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthResetLoginEmailParams struct {
	PhoneNumber   string
	PhoneCodeHash string
}

func (*AuthResetLoginEmailParams) CRC() uint32 {
	return 0x7e960193
}

// Reset the login email ».
func (c *Client) AuthResetLoginEmail(phoneNumber, phoneCodeHash string) (AuthSentCode, error) {
	responseData, err := c.MakeRequest(&AuthResetLoginEmailParams{
		PhoneCodeHash: phoneCodeHash,
		PhoneNumber:   phoneNumber,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AuthResetLoginEmail")
	}

	resp, ok := responseData.(AuthSentCode)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthSendCodeParams struct {
	PhoneNumber string
	APIID       int32
	APIHash     string
	Settings    *CodeSettings
}

func (*AuthSendCodeParams) CRC() uint32 {
	return 0xa677244f
}

// Send the verification code for login
func (c *Client) AuthSendCode(phoneNumber string, apiID int32, apiHash string, settings *CodeSettings) (AuthSentCode, error) {
	responseData, err := c.MakeRequest(&AuthSendCodeParams{
		APIHash:     apiHash,
		APIID:       apiID,
		PhoneNumber: phoneNumber,
		Settings:    settings,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AuthSendCode")
	}

	resp, ok := responseData.(AuthSentCode)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthSignInParams struct {
	PhoneNumber       string
	PhoneCodeHash     string
	PhoneCode         string            `tl:"flag:0"`
	EmailVerification EmailVerification `tl:"flag:1"`
}

func (*AuthSignInParams) CRC() uint32 {
	return 0x8d52a951
}

func (*AuthSignInParams) FlagIndex() int {
	return 0
}

// Signs in a user with a validated phone number.
func (c *Client) AuthSignIn(phoneNumber, phoneCodeHash, phoneCode string, emailVerification EmailVerification) (AuthAuthorization, error) {
	responseData, err := c.MakeRequest(&AuthSignInParams{
		EmailVerification: emailVerification,
		PhoneCode:         phoneCode,
		PhoneCodeHash:     phoneCodeHash,
		PhoneNumber:       phoneNumber,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending AuthSignIn")
	}

	resp, ok := responseData.(AuthAuthorization)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type AuthSignUpParams struct {
	NoJoinedNotifications bool `tl:"flag:0,encoded_in_bitflags"`
	PhoneNumber           string
	PhoneCodeHash         string
	FirstName             string
	LastName              string
}

func (*AuthSignUpParams) CRC() uint32 {
	return 0xaac7b717
}

func (*AuthSignUpParams) FlagIndex() int {
	return 0
}

// Registers a validated phone number in the system.
func (c *Client) AuthSignUp(params *AuthSignUpParams) (AuthAuthorization, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending AuthSignUp")
	}

	resp, ok := responseData.(AuthAuthorization)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsAddPreviewMediaParams struct {
	Bot      InputUser
	LangCode string
	Media    InputMedia
}

func (*BotsAddPreviewMediaParams) CRC() uint32 {
	return 0x17aeb75a
}

// Add a main mini app preview, see here » for more info.
func (c *Client) BotsAddPreviewMedia(bot InputUser, langCode string, media InputMedia) (*BotPreviewMedia, error) {
	responseData, err := c.MakeRequest(&BotsAddPreviewMediaParams{
		Bot:      bot,
		LangCode: langCode,
		Media:    media,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending BotsAddPreviewMedia")
	}

	resp, ok := responseData.(*BotPreviewMedia)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsAllowSendMessageParams struct {
	Bot InputUser
}

func (*BotsAllowSendMessageParams) CRC() uint32 {
	return 0xf132e3ef
}

// Allow the specified bot to send us messages
func (c *Client) BotsAllowSendMessage(bot InputUser) (Updates, error) {
	responseData, err := c.MakeRequest(&BotsAllowSendMessageParams{Bot: bot})
	if err != nil {
		return nil, errors.Wrap(err, "sending BotsAllowSendMessage")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsAnswerWebhookJsonQueryParams struct {
	QueryID int64
	Data    *DataJson
}

func (*BotsAnswerWebhookJsonQueryParams) CRC() uint32 {
	return 0xe6213f4d
}

// Answers a custom query; for bots only
func (c *Client) BotsAnswerWebhookJsonQuery(queryID int64, data *DataJson) (bool, error) {
	responseData, err := c.MakeRequest(&BotsAnswerWebhookJsonQueryParams{
		Data:    data,
		QueryID: queryID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending BotsAnswerWebhookJsonQuery")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsCanSendMessageParams struct {
	Bot InputUser
}

func (*BotsCanSendMessageParams) CRC() uint32 {
	return 0x1359f4e6
}

// Check whether the specified bot can send us messages
func (c *Client) BotsCanSendMessage(bot InputUser) (bool, error) {
	responseData, err := c.MakeRequest(&BotsCanSendMessageParams{Bot: bot})
	if err != nil {
		return false, errors.Wrap(err, "sending BotsCanSendMessage")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsCheckDownloadFileParamsParams struct {
	Bot      InputUser
	FileName string
	URL      string
}

func (*BotsCheckDownloadFileParamsParams) CRC() uint32 {
	return 0x50077589
}

// Check if a mini app can request the download of a specific file: called when handling web_app_request_file_download events »
func (c *Client) BotsCheckDownloadFileParams(bot InputUser, fileName, url string) (bool, error) {
	responseData, err := c.MakeRequest(&BotsCheckDownloadFileParamsParams{
		Bot:      bot,
		FileName: fileName,
		URL:      url,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending BotsCheckDownloadFileParams")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsDeletePreviewMediaParams struct {
	Bot      InputUser
	LangCode string
	Media    []InputMedia
}

func (*BotsDeletePreviewMediaParams) CRC() uint32 {
	return 0x2d0135b3
}

// Delete a main mini app preview, see here » for more info.
func (c *Client) BotsDeletePreviewMedia(bot InputUser, langCode string, media []InputMedia) (bool, error) {
	responseData, err := c.MakeRequest(&BotsDeletePreviewMediaParams{
		Bot:      bot,
		LangCode: langCode,
		Media:    media,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending BotsDeletePreviewMedia")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsEditPreviewMediaParams struct {
	Bot      InputUser
	LangCode string
	Media    InputMedia
	NewMedia InputMedia
}

func (*BotsEditPreviewMediaParams) CRC() uint32 {
	return 0x8525606f
}

// Edit a main mini app preview, see here » for more info.
func (c *Client) BotsEditPreviewMedia(bot InputUser, langCode string, media, newMedia InputMedia) (*BotPreviewMedia, error) {
	responseData, err := c.MakeRequest(&BotsEditPreviewMediaParams{
		Bot:      bot,
		LangCode: langCode,
		Media:    media,
		NewMedia: newMedia,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending BotsEditPreviewMedia")
	}

	resp, ok := responseData.(*BotPreviewMedia)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsGetAdminedBotsParams struct{}

func (*BotsGetAdminedBotsParams) CRC() uint32 {
	return 0xb0711d83
}

// Get a list of bots owned by the current user
func (c *Client) BotsGetAdminedBots() ([]User, error) {
	responseData, err := c.MakeRequest(&BotsGetAdminedBotsParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending BotsGetAdminedBots")
	}

	resp, ok := responseData.([]User)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsGetBotCommandsParams struct {
	Scope    BotCommandScope
	LangCode string
}

func (*BotsGetBotCommandsParams) CRC() uint32 {
	return 0xe34c0dd6
}

// Obtain a list of bot commands for the specified bot scope and language code
func (c *Client) BotsGetBotCommands(scope BotCommandScope, langCode string) ([]*BotCommand, error) {
	responseData, err := c.MakeRequest(&BotsGetBotCommandsParams{
		LangCode: langCode,
		Scope:    scope,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending BotsGetBotCommands")
	}

	resp, ok := responseData.([]*BotCommand)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsGetBotInfoParams struct {
	Bot      InputUser `tl:"flag:0"`
	LangCode string
}

func (*BotsGetBotInfoParams) CRC() uint32 {
	return 0xdcd914fd
}

func (*BotsGetBotInfoParams) FlagIndex() int {
	return 0
}

// Get localized name, about text and description of a bot (or of the current account, if called by a bot).
func (c *Client) BotsGetBotInfo(bot InputUser, langCode string) (*BotsBotInfo, error) {
	responseData, err := c.MakeRequest(&BotsGetBotInfoParams{
		Bot:      bot,
		LangCode: langCode,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending BotsGetBotInfo")
	}

	resp, ok := responseData.(*BotsBotInfo)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsGetBotMenuButtonParams struct {
	UserID InputUser
}

func (*BotsGetBotMenuButtonParams) CRC() uint32 {
	return 0x9c60eb28
}

// Gets the menu button action for a given user or for all users, previously set using bots.setBotMenuButton; users can see this information in the botInfo constructor.
func (c *Client) BotsGetBotMenuButton(userID InputUser) (BotMenuButton, error) {
	responseData, err := c.MakeRequest(&BotsGetBotMenuButtonParams{UserID: userID})
	if err != nil {
		return nil, errors.Wrap(err, "sending BotsGetBotMenuButton")
	}

	resp, ok := responseData.(BotMenuButton)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsGetBotRecommendationsParams struct {
	Bot InputUser
}

func (*BotsGetBotRecommendationsParams) CRC() uint32 {
	return 0xa1b70815
}

func (c *Client) BotsGetBotRecommendations(bot InputUser) (UsersUsers, error) {
	responseData, err := c.MakeRequest(&BotsGetBotRecommendationsParams{Bot: bot})
	if err != nil {
		return nil, errors.Wrap(err, "sending BotsGetBotRecommendations")
	}

	resp, ok := responseData.(UsersUsers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsGetPopularAppBotsParams struct {
	Offset string
	Limit  int32
}

func (*BotsGetPopularAppBotsParams) CRC() uint32 {
	return 0xc2510192
}

// Fetch popular Main Mini Apps, to be used in the apps tab of global search ».
func (c *Client) BotsGetPopularAppBots(offset string, limit int32) (*BotsPopularAppBots, error) {
	responseData, err := c.MakeRequest(&BotsGetPopularAppBotsParams{
		Limit:  limit,
		Offset: offset,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending BotsGetPopularAppBots")
	}

	resp, ok := responseData.(*BotsPopularAppBots)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsGetPreviewInfoParams struct {
	Bot      InputUser
	LangCode string
}

func (*BotsGetPreviewInfoParams) CRC() uint32 {
	return 0x423ab3ad
}

// Bot owners only, fetch main mini app preview information, see here » for more info.
func (c *Client) BotsGetPreviewInfo(bot InputUser, langCode string) (*BotsPreviewInfo, error) {
	responseData, err := c.MakeRequest(&BotsGetPreviewInfoParams{
		Bot:      bot,
		LangCode: langCode,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending BotsGetPreviewInfo")
	}

	resp, ok := responseData.(*BotsPreviewInfo)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsGetPreviewMediasParams struct {
	Bot InputUser
}

func (*BotsGetPreviewMediasParams) CRC() uint32 {
	return 0xa2a5594d
}

// Fetch main mini app previews, see here » for more info.
func (c *Client) BotsGetPreviewMedias(bot InputUser) ([]*BotPreviewMedia, error) {
	responseData, err := c.MakeRequest(&BotsGetPreviewMediasParams{Bot: bot})
	if err != nil {
		return nil, errors.Wrap(err, "sending BotsGetPreviewMedias")
	}

	resp, ok := responseData.([]*BotPreviewMedia)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsInvokeWebViewCustomMethodParams struct {
	Bot          InputUser
	CustomMethod string
	Params       *DataJson
}

func (*BotsInvokeWebViewCustomMethodParams) CRC() uint32 {
	return 0x87fc5e7
}

// Send a custom request from a mini bot app, triggered by a web_app_invoke_custom_method event ».
func (c *Client) BotsInvokeWebViewCustomMethod(bot InputUser, customMethod string, params *DataJson) (*DataJson, error) {
	responseData, err := c.MakeRequest(&BotsInvokeWebViewCustomMethodParams{
		Bot:          bot,
		CustomMethod: customMethod,
		Params:       params,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending BotsInvokeWebViewCustomMethod")
	}

	resp, ok := responseData.(*DataJson)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsReorderPreviewMediasParams struct {
	Bot      InputUser
	LangCode string
	Order    []InputMedia
}

func (*BotsReorderPreviewMediasParams) CRC() uint32 {
	return 0xb627f3aa
}

// Reorder a main mini app previews, see here » for more info.
func (c *Client) BotsReorderPreviewMedias(bot InputUser, langCode string, order []InputMedia) (bool, error) {
	responseData, err := c.MakeRequest(&BotsReorderPreviewMediasParams{
		Bot:      bot,
		LangCode: langCode,
		Order:    order,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending BotsReorderPreviewMedias")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsReorderUsernamesParams struct {
	Bot   InputUser
	Order []string
}

func (*BotsReorderUsernamesParams) CRC() uint32 {
	return 0x9709b1c2
}

// Reorder usernames associated to a bot we own.
func (c *Client) BotsReorderUsernames(bot InputUser, order []string) (bool, error) {
	responseData, err := c.MakeRequest(&BotsReorderUsernamesParams{
		Bot:   bot,
		Order: order,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending BotsReorderUsernames")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsResetBotCommandsParams struct {
	Scope    BotCommandScope
	LangCode string
}

func (*BotsResetBotCommandsParams) CRC() uint32 {
	return 0x3d8de0f9
}

// Clear bot commands for the specified bot scope and language code
func (c *Client) BotsResetBotCommands(scope BotCommandScope, langCode string) (bool, error) {
	responseData, err := c.MakeRequest(&BotsResetBotCommandsParams{
		LangCode: langCode,
		Scope:    scope,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending BotsResetBotCommands")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsSendCustomRequestParams struct {
	CustomMethod string
	Params       *DataJson
}

func (*BotsSendCustomRequestParams) CRC() uint32 {
	return 0xaa2769ed
}

// Sends a custom request; for bots only
func (c *Client) BotsSendCustomRequest(customMethod string, params *DataJson) (*DataJson, error) {
	responseData, err := c.MakeRequest(&BotsSendCustomRequestParams{
		CustomMethod: customMethod,
		Params:       params,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending BotsSendCustomRequest")
	}

	resp, ok := responseData.(*DataJson)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsSetBotBroadcastDefaultAdminRightsParams struct {
	AdminRights *ChatAdminRights
}

func (*BotsSetBotBroadcastDefaultAdminRightsParams) CRC() uint32 {
	return 0x788464e1
}

// Set the default suggested admin rights for bots being added as admins to channels, see here for more info on how to handle them ».
func (c *Client) BotsSetBotBroadcastDefaultAdminRights(adminRights *ChatAdminRights) (bool, error) {
	responseData, err := c.MakeRequest(&BotsSetBotBroadcastDefaultAdminRightsParams{AdminRights: adminRights})
	if err != nil {
		return false, errors.Wrap(err, "sending BotsSetBotBroadcastDefaultAdminRights")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsSetBotCommandsParams struct {
	Scope    BotCommandScope
	LangCode string
	Commands []*BotCommand
}

func (*BotsSetBotCommandsParams) CRC() uint32 {
	return 0x517165a
}

// Set bot command list
func (c *Client) BotsSetBotCommands(scope BotCommandScope, langCode string, commands []*BotCommand) (bool, error) {
	responseData, err := c.MakeRequest(&BotsSetBotCommandsParams{
		Commands: commands,
		LangCode: langCode,
		Scope:    scope,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending BotsSetBotCommands")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsSetBotGroupDefaultAdminRightsParams struct {
	AdminRights *ChatAdminRights
}

func (*BotsSetBotGroupDefaultAdminRightsParams) CRC() uint32 {
	return 0x925ec9ea
}

// Set the default suggested admin rights for bots being added as admins to groups, see here for more info on how to handle them ».
func (c *Client) BotsSetBotGroupDefaultAdminRights(adminRights *ChatAdminRights) (bool, error) {
	responseData, err := c.MakeRequest(&BotsSetBotGroupDefaultAdminRightsParams{AdminRights: adminRights})
	if err != nil {
		return false, errors.Wrap(err, "sending BotsSetBotGroupDefaultAdminRights")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsSetBotInfoParams struct {
	Bot         InputUser `tl:"flag:2"`
	LangCode    string
	Name        string `tl:"flag:3"`
	About       string `tl:"flag:0"`
	Description string `tl:"flag:1"`
}

func (*BotsSetBotInfoParams) CRC() uint32 {
	return 0x10cf3123
}

func (*BotsSetBotInfoParams) FlagIndex() int {
	return 0
}

// Set localized name, about text and description of a bot (or of the current account, if called by a bot).
func (c *Client) BotsSetBotInfo(params *BotsSetBotInfoParams) (bool, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return false, errors.Wrap(err, "sending BotsSetBotInfo")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsSetBotMenuButtonParams struct {
	UserID InputUser
	Button BotMenuButton
}

func (*BotsSetBotMenuButtonParams) CRC() uint32 {
	return 0x4504d54f
}

// Sets the menu button action » for a given user or for all users
func (c *Client) BotsSetBotMenuButton(userID InputUser, button BotMenuButton) (bool, error) {
	responseData, err := c.MakeRequest(&BotsSetBotMenuButtonParams{
		Button: button,
		UserID: userID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending BotsSetBotMenuButton")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsSetCustomVerificationParams struct {
	Enabled           bool      `tl:"flag:1,encoded_in_bitflags"`
	Bot               InputUser `tl:"flag:0"`
	Peer              InputPeer
	CustomDescription string `tl:"flag:2"`
}

func (*BotsSetCustomVerificationParams) CRC() uint32 {
	return 0x8b89dfbd
}

func (*BotsSetCustomVerificationParams) FlagIndex() int {
	return 0
}

func (c *Client) BotsSetCustomVerification(enabled bool, bot InputUser, peer InputPeer, customDescription string) (bool, error) {
	responseData, err := c.MakeRequest(&BotsSetCustomVerificationParams{
		Bot:               bot,
		CustomDescription: customDescription,
		Enabled:           enabled,
		Peer:              peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending BotsSetCustomVerification")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsToggleUserEmojiStatusPermissionParams struct {
	Bot     InputUser
	Enabled bool
}

func (*BotsToggleUserEmojiStatusPermissionParams) CRC() uint32 {
	return 0x6de6392
}

// Allow or prevent a bot from changing our emoji status »
func (c *Client) BotsToggleUserEmojiStatusPermission(bot InputUser, enabled bool) (bool, error) {
	responseData, err := c.MakeRequest(&BotsToggleUserEmojiStatusPermissionParams{
		Bot:     bot,
		Enabled: enabled,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending BotsToggleUserEmojiStatusPermission")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsToggleUsernameParams struct {
	Bot      InputUser
	Username string
	Active   bool
}

func (*BotsToggleUsernameParams) CRC() uint32 {
	return 0x53ca973
}

// Activate or deactivate a purchased fragment.com username associated to a bot we own.
func (c *Client) BotsToggleUsername(bot InputUser, username string, active bool) (bool, error) {
	responseData, err := c.MakeRequest(&BotsToggleUsernameParams{
		Active:   active,
		Bot:      bot,
		Username: username,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending BotsToggleUsername")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsUpdateStarRefProgramParams struct {
	Bot                InputUser
	CommissionPermille int32
	DurationMonths     int32 `tl:"flag:0"`
}

func (*BotsUpdateStarRefProgramParams) CRC() uint32 {
	return 0x778b5ab3
}

func (*BotsUpdateStarRefProgramParams) FlagIndex() int {
	return 0
}

// Create, edit or delete the affiliate program of a bot we own
func (c *Client) BotsUpdateStarRefProgram(bot InputUser, commissionPermille, durationMonths int32) (*StarRefProgram, error) {
	responseData, err := c.MakeRequest(&BotsUpdateStarRefProgramParams{
		Bot:                bot,
		CommissionPermille: commissionPermille,
		DurationMonths:     durationMonths,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending BotsUpdateStarRefProgram")
	}

	resp, ok := responseData.(*StarRefProgram)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type BotsUpdateUserEmojiStatusParams struct {
	UserID      InputUser
	EmojiStatus EmojiStatus
}

func (*BotsUpdateUserEmojiStatusParams) CRC() uint32 {
	return 0xed9f30c5
}

// Change the emoji status of a user (invoked by bots, see here » for more info on the full flow)
func (c *Client) BotsUpdateUserEmojiStatus(userID InputUser, emojiStatus EmojiStatus) (bool, error) {
	responseData, err := c.MakeRequest(&BotsUpdateUserEmojiStatusParams{
		EmojiStatus: emojiStatus,
		UserID:      userID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending BotsUpdateUserEmojiStatus")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsCheckUsernameParams struct {
	Channel  InputChannel
	Username string
}

func (*ChannelsCheckUsernameParams) CRC() uint32 {
	return 0x10e6bd2c
}

// Check if a username is free and can be assigned to a channel/supergroup
func (c *Client) ChannelsCheckUsername(channel InputChannel, username string) (bool, error) {
	responseData, err := c.MakeRequest(&ChannelsCheckUsernameParams{
		Channel:  channel,
		Username: username,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ChannelsCheckUsername")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsConvertToGigagroupParams struct {
	Channel InputChannel
}

func (*ChannelsConvertToGigagroupParams) CRC() uint32 {
	return 0xb290c69
}

// Convert a supergroup to a gigagroup, when requested by channel suggestions.
func (c *Client) ChannelsConvertToGigagroup(channel InputChannel) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsConvertToGigagroupParams{Channel: channel})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsConvertToGigagroup")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsCreateChannelParams struct {
	Broadcast bool `tl:"flag:0,encoded_in_bitflags"`
	Megagroup bool `tl:"flag:1,encoded_in_bitflags"`
	ForImport bool `tl:"flag:3,encoded_in_bitflags"`
	Forum     bool `tl:"flag:5,encoded_in_bitflags"`
	Title     string
	About     string
	GeoPoint  InputGeoPoint `tl:"flag:2"`
	Address   string        `tl:"flag:2"`
	TtlPeriod int32         `tl:"flag:4"`
}

func (*ChannelsCreateChannelParams) CRC() uint32 {
	return 0x91006707
}

func (*ChannelsCreateChannelParams) FlagIndex() int {
	return 0
}

// Create a supergroup/channel.
func (c *Client) ChannelsCreateChannel(params *ChannelsCreateChannelParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsCreateChannel")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsCreateForumTopicParams struct {
	Channel     InputChannel
	Title       string
	IconColor   int32 `tl:"flag:0"`
	IconEmojiID int64 `tl:"flag:3"`
	RandomID    int64
	SendAs      InputPeer `tl:"flag:2"`
}

func (*ChannelsCreateForumTopicParams) CRC() uint32 {
	return 0xf40c0224
}

func (*ChannelsCreateForumTopicParams) FlagIndex() int {
	return 0
}

// Create a forum topic; requires <a href="/api/rights">`manage_topics` rights</a>.
func (c *Client) ChannelsCreateForumTopic(params *ChannelsCreateForumTopicParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsCreateForumTopic")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsDeactivateAllUsernamesParams struct {
	Channel InputChannel
}

func (*ChannelsDeactivateAllUsernamesParams) CRC() uint32 {
	return 0xa245dd3
}

// Disable all purchased usernames of a supergroup or channel
func (c *Client) ChannelsDeactivateAllUsernames(channel InputChannel) (bool, error) {
	responseData, err := c.MakeRequest(&ChannelsDeactivateAllUsernamesParams{Channel: channel})
	if err != nil {
		return false, errors.Wrap(err, "sending ChannelsDeactivateAllUsernames")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsDeleteChannelParams struct {
	Channel InputChannel
}

func (*ChannelsDeleteChannelParams) CRC() uint32 {
	return 0xc0111fe3
}

// Delete a channel/supergroup
func (c *Client) ChannelsDeleteChannel(channel InputChannel) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsDeleteChannelParams{Channel: channel})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsDeleteChannel")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsDeleteHistoryParams struct {
	ForEveryone bool `tl:"flag:0,encoded_in_bitflags"`
	Channel     InputChannel
	MaxID       int32
}

func (*ChannelsDeleteHistoryParams) CRC() uint32 {
	return 0x9baa9647
}

func (*ChannelsDeleteHistoryParams) FlagIndex() int {
	return 0
}

// Delete the history of a supergroup
func (c *Client) ChannelsDeleteHistory(forEveryone bool, channel InputChannel, maxID int32) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsDeleteHistoryParams{
		Channel:     channel,
		ForEveryone: forEveryone,
		MaxID:       maxID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsDeleteHistory")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsDeleteMessagesParams struct {
	Channel InputChannel
	ID      []int32
}

func (*ChannelsDeleteMessagesParams) CRC() uint32 {
	return 0x84c1fd4e
}

// Delete messages in a channel/supergroup
func (c *Client) ChannelsDeleteMessages(channel InputChannel, id []int32) (*MessagesAffectedMessages, error) {
	responseData, err := c.MakeRequest(&ChannelsDeleteMessagesParams{
		Channel: channel,
		ID:      id,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsDeleteMessages")
	}

	resp, ok := responseData.(*MessagesAffectedMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsDeleteParticipantHistoryParams struct {
	Channel     InputChannel
	Participant InputPeer
}

func (*ChannelsDeleteParticipantHistoryParams) CRC() uint32 {
	return 0x367544db
}

// Delete all messages sent by a specific participant of a given supergroup
func (c *Client) ChannelsDeleteParticipantHistory(channel InputChannel, participant InputPeer) (*MessagesAffectedHistory, error) {
	responseData, err := c.MakeRequest(&ChannelsDeleteParticipantHistoryParams{
		Channel:     channel,
		Participant: participant,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsDeleteParticipantHistory")
	}

	resp, ok := responseData.(*MessagesAffectedHistory)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsDeleteTopicHistoryParams struct {
	Channel  InputChannel
	TopMsgID int32
}

func (*ChannelsDeleteTopicHistoryParams) CRC() uint32 {
	return 0x34435f2d
}

// Delete message history of a forum topic
func (c *Client) ChannelsDeleteTopicHistory(channel InputChannel, topMsgID int32) (*MessagesAffectedHistory, error) {
	responseData, err := c.MakeRequest(&ChannelsDeleteTopicHistoryParams{
		Channel:  channel,
		TopMsgID: topMsgID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsDeleteTopicHistory")
	}

	resp, ok := responseData.(*MessagesAffectedHistory)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsEditAdminParams struct {
	Channel     InputChannel
	UserID      InputUser
	AdminRights *ChatAdminRights
	Rank        string
}

func (*ChannelsEditAdminParams) CRC() uint32 {
	return 0xd33c8902
}

// Modify the admin rights of a user in a supergroup/channel.
func (c *Client) ChannelsEditAdmin(channel InputChannel, userID InputUser, adminRights *ChatAdminRights, rank string) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsEditAdminParams{
		AdminRights: adminRights,
		Channel:     channel,
		Rank:        rank,
		UserID:      userID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsEditAdmin")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsEditBannedParams struct {
	Channel      InputChannel
	Participant  InputPeer
	BannedRights *ChatBannedRights
}

func (*ChannelsEditBannedParams) CRC() uint32 {
	return 0x96e6cd81
}

// Ban/unban/kick a user in a supergroup/channel.
func (c *Client) ChannelsEditBanned(channel InputChannel, participant InputPeer, bannedRights *ChatBannedRights) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsEditBannedParams{
		BannedRights: bannedRights,
		Channel:      channel,
		Participant:  participant,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsEditBanned")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsEditCreatorParams struct {
	Channel  InputChannel
	UserID   InputUser
	Password InputCheckPasswordSRP
}

func (*ChannelsEditCreatorParams) CRC() uint32 {
	return 0x8f38cd1f
}

// Transfer channel ownership
func (c *Client) ChannelsEditCreator(channel InputChannel, userID InputUser, password InputCheckPasswordSRP) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsEditCreatorParams{
		Channel:  channel,
		Password: password,
		UserID:   userID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsEditCreator")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsEditForumTopicParams struct {
	Channel     InputChannel
	TopicID     int32
	Title       string `tl:"flag:0"`
	IconEmojiID int64  `tl:"flag:1"`
	Closed      bool   `tl:"flag:2"`
	Hidden      bool   `tl:"flag:3"`
}

func (*ChannelsEditForumTopicParams) CRC() uint32 {
	return 0xf4dfa185
}

func (*ChannelsEditForumTopicParams) FlagIndex() int {
	return 0
}

// Edit forum topic; requires <a href="/api/rights">`manage_topics` rights</a>.
func (c *Client) ChannelsEditForumTopic(params *ChannelsEditForumTopicParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsEditForumTopic")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsEditLocationParams struct {
	Channel  InputChannel
	GeoPoint InputGeoPoint
	Address  string
}

func (*ChannelsEditLocationParams) CRC() uint32 {
	return 0x58e63f6d
}

// Edit location of geogroup, see here » for more info on geogroups.
func (c *Client) ChannelsEditLocation(channel InputChannel, geoPoint InputGeoPoint, address string) (bool, error) {
	responseData, err := c.MakeRequest(&ChannelsEditLocationParams{
		Address:  address,
		Channel:  channel,
		GeoPoint: geoPoint,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ChannelsEditLocation")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsEditPhotoParams struct {
	Channel InputChannel
	Photo   InputChatPhoto
}

func (*ChannelsEditPhotoParams) CRC() uint32 {
	return 0xf12e57c9
}

// Change the photo of a channel/supergroup
func (c *Client) ChannelsEditPhoto(channel InputChannel, photo InputChatPhoto) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsEditPhotoParams{
		Channel: channel,
		Photo:   photo,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsEditPhoto")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsEditTitleParams struct {
	Channel InputChannel
	Title   string
}

func (*ChannelsEditTitleParams) CRC() uint32 {
	return 0x566decd0
}

// Edit the name of a channel/supergroup
func (c *Client) ChannelsEditTitle(channel InputChannel, title string) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsEditTitleParams{
		Channel: channel,
		Title:   title,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsEditTitle")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsExportMessageLinkParams struct {
	Grouped bool `tl:"flag:0,encoded_in_bitflags"`
	Thread  bool `tl:"flag:1,encoded_in_bitflags"`
	Channel InputChannel
	ID      int32
}

func (*ChannelsExportMessageLinkParams) CRC() uint32 {
	return 0xe63fadeb
}

func (*ChannelsExportMessageLinkParams) FlagIndex() int {
	return 0
}

// Get link and embed info of a message in a channel/supergroup
func (c *Client) ChannelsExportMessageLink(grouped, thread bool, channel InputChannel, id int32) (*ExportedMessageLink, error) {
	responseData, err := c.MakeRequest(&ChannelsExportMessageLinkParams{
		Channel: channel,
		Grouped: grouped,
		ID:      id,
		Thread:  thread,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsExportMessageLink")
	}

	resp, ok := responseData.(*ExportedMessageLink)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsGetAdminLogParams struct {
	Channel      InputChannel
	Q            string
	EventsFilter *ChannelAdminLogEventsFilter `tl:"flag:0"`
	Admins       []InputUser                  `tl:"flag:1"`
	MaxID        int64
	MinID        int64
	Limit        int32
}

func (*ChannelsGetAdminLogParams) CRC() uint32 {
	return 0x33ddf480
}

func (*ChannelsGetAdminLogParams) FlagIndex() int {
	return 0
}

// Get the admin log of a channel/supergroup
func (c *Client) ChannelsGetAdminLog(params *ChannelsGetAdminLogParams) (*ChannelsAdminLogResults, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsGetAdminLog")
	}

	resp, ok := responseData.(*ChannelsAdminLogResults)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsGetAdminedPublicChannelsParams struct {
	ByLocation  bool `tl:"flag:0,encoded_in_bitflags"`
	CheckLimit  bool `tl:"flag:1,encoded_in_bitflags"`
	ForPersonal bool `tl:"flag:2,encoded_in_bitflags"`
}

func (*ChannelsGetAdminedPublicChannelsParams) CRC() uint32 {
	return 0xf8b036af
}

func (*ChannelsGetAdminedPublicChannelsParams) FlagIndex() int {
	return 0
}

// Get channels/supergroups/geogroups we're admin in. Usually called when the user exceeds the limit for owned public channels/supergroups/geogroups, and the user is given the choice to remove one of his channels/supergroups/geogroups.
func (c *Client) ChannelsGetAdminedPublicChannels(byLocation, checkLimit, forPersonal bool) (MessagesChats, error) {
	responseData, err := c.MakeRequest(&ChannelsGetAdminedPublicChannelsParams{
		ByLocation:  byLocation,
		CheckLimit:  checkLimit,
		ForPersonal: forPersonal,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsGetAdminedPublicChannels")
	}

	resp, ok := responseData.(MessagesChats)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsGetChannelRecommendationsParams struct {
	Channel InputChannel `tl:"flag:0"`
}

func (*ChannelsGetChannelRecommendationsParams) CRC() uint32 {
	return 0x25a71742
}

func (*ChannelsGetChannelRecommendationsParams) FlagIndex() int {
	return 0
}

// Obtain a list of similarly themed public channels, selected based on similarities in their <strong>subscriber bases</strong>.
func (c *Client) ChannelsGetChannelRecommendations(channel InputChannel) (MessagesChats, error) {
	responseData, err := c.MakeRequest(&ChannelsGetChannelRecommendationsParams{Channel: channel})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsGetChannelRecommendations")
	}

	resp, ok := responseData.(MessagesChats)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsGetChannelsParams struct {
	ID []InputChannel
}

func (*ChannelsGetChannelsParams) CRC() uint32 {
	return 0xa7f6bbb
}

// Get info about channels/supergroups
func (c *Client) ChannelsGetChannels(id []InputChannel) (MessagesChats, error) {
	responseData, err := c.MakeRequest(&ChannelsGetChannelsParams{ID: id})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsGetChannels")
	}

	resp, ok := responseData.(MessagesChats)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsGetForumTopicsParams struct {
	Channel     InputChannel
	Q           string `tl:"flag:0"`
	OffsetDate  int32
	OffsetID    int32
	OffsetTopic int32
	Limit       int32
}

func (*ChannelsGetForumTopicsParams) CRC() uint32 {
	return 0xde560d1
}

func (*ChannelsGetForumTopicsParams) FlagIndex() int {
	return 0
}

// Get topics of a forum
func (c *Client) ChannelsGetForumTopics(params *ChannelsGetForumTopicsParams) (*MessagesForumTopics, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsGetForumTopics")
	}

	resp, ok := responseData.(*MessagesForumTopics)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsGetForumTopicsByIDParams struct {
	Channel InputChannel
	Topics  []int32
}

func (*ChannelsGetForumTopicsByIDParams) CRC() uint32 {
	return 0xb0831eb9
}

// Get forum topics by their ID
func (c *Client) ChannelsGetForumTopicsByID(channel InputChannel, topics []int32) (*MessagesForumTopics, error) {
	responseData, err := c.MakeRequest(&ChannelsGetForumTopicsByIDParams{
		Channel: channel,
		Topics:  topics,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsGetForumTopicsByID")
	}

	resp, ok := responseData.(*MessagesForumTopics)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsGetFullChannelParams struct {
	Channel InputChannel
}

func (*ChannelsGetFullChannelParams) CRC() uint32 {
	return 0x8736a09
}

// Get full info about a supergroup, gigagroup or channel
func (c *Client) ChannelsGetFullChannel(channel InputChannel) (*MessagesChatFull, error) {
	responseData, err := c.MakeRequest(&ChannelsGetFullChannelParams{Channel: channel})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsGetFullChannel")
	}

	resp, ok := responseData.(*MessagesChatFull)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsGetGroupsForDiscussionParams struct{}

func (*ChannelsGetGroupsForDiscussionParams) CRC() uint32 {
	return 0xf5dad378
}

// Get all groups that can be used as discussion groups.
func (c *Client) ChannelsGetGroupsForDiscussion() (MessagesChats, error) {
	responseData, err := c.MakeRequest(&ChannelsGetGroupsForDiscussionParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsGetGroupsForDiscussion")
	}

	resp, ok := responseData.(MessagesChats)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsGetInactiveChannelsParams struct{}

func (*ChannelsGetInactiveChannelsParams) CRC() uint32 {
	return 0x11e831ee
}

// Get inactive channels and supergroups
func (c *Client) ChannelsGetInactiveChannels() (*MessagesInactiveChats, error) {
	responseData, err := c.MakeRequest(&ChannelsGetInactiveChannelsParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsGetInactiveChannels")
	}

	resp, ok := responseData.(*MessagesInactiveChats)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsGetLeftChannelsParams struct {
	Offset int32
}

func (*ChannelsGetLeftChannelsParams) CRC() uint32 {
	return 0x8341ecc0
}

// Get a list of channels/supergroups we left, requires a takeout session, see here » for more info.
func (c *Client) ChannelsGetLeftChannels(offset int32) (MessagesChats, error) {
	responseData, err := c.MakeRequest(&ChannelsGetLeftChannelsParams{Offset: offset})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsGetLeftChannels")
	}

	resp, ok := responseData.(MessagesChats)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsGetMessagesParams struct {
	Channel InputChannel
	ID      []InputMessage
}

func (*ChannelsGetMessagesParams) CRC() uint32 {
	return 0xad8c9a23
}

// Get channel/supergroup messages
func (c *Client) ChannelsGetMessages(channel InputChannel, id []InputMessage) (MessagesMessages, error) {
	responseData, err := c.MakeRequest(&ChannelsGetMessagesParams{
		Channel: channel,
		ID:      id,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsGetMessages")
	}

	resp, ok := responseData.(MessagesMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsGetParticipantParams struct {
	Channel     InputChannel
	Participant InputPeer
}

func (*ChannelsGetParticipantParams) CRC() uint32 {
	return 0xa0ab6cc6
}

// Get info about a channel/supergroup participant
func (c *Client) ChannelsGetParticipant(channel InputChannel, participant InputPeer) (*ChannelsChannelParticipant, error) {
	responseData, err := c.MakeRequest(&ChannelsGetParticipantParams{
		Channel:     channel,
		Participant: participant,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsGetParticipant")
	}

	resp, ok := responseData.(*ChannelsChannelParticipant)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsGetParticipantsParams struct {
	Channel InputChannel
	Filter  ChannelParticipantsFilter
	Offset  int32
	Limit   int32
	Hash    int64
}

func (*ChannelsGetParticipantsParams) CRC() uint32 {
	return 0x77ced9d0
}

// Get the participants of a supergroup/channel
func (c *Client) ChannelsGetParticipants(channel InputChannel, filter ChannelParticipantsFilter, offset, limit int32, hash int64) (ChannelsChannelParticipants, error) {
	responseData, err := c.MakeRequest(&ChannelsGetParticipantsParams{
		Channel: channel,
		Filter:  filter,
		Hash:    hash,
		Limit:   limit,
		Offset:  offset,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsGetParticipants")
	}

	resp, ok := responseData.(ChannelsChannelParticipants)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsGetSendAsParams struct {
	Peer InputPeer
}

func (*ChannelsGetSendAsParams) CRC() uint32 {
	return 0xdc770ee
}

// Obtains a list of peers that can be used to send messages in a specific group
func (c *Client) ChannelsGetSendAs(peer InputPeer) (*ChannelsSendAsPeers, error) {
	responseData, err := c.MakeRequest(&ChannelsGetSendAsParams{Peer: peer})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsGetSendAs")
	}

	resp, ok := responseData.(*ChannelsSendAsPeers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsInviteToChannelParams struct {
	Channel InputChannel
	Users   []InputUser
}

func (*ChannelsInviteToChannelParams) CRC() uint32 {
	return 0xc9e33d54
}

// Invite users to a channel/supergroup
func (c *Client) ChannelsInviteToChannel(channel InputChannel, users []InputUser) (*MessagesInvitedUsers, error) {
	responseData, err := c.MakeRequest(&ChannelsInviteToChannelParams{
		Channel: channel,
		Users:   users,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsInviteToChannel")
	}

	resp, ok := responseData.(*MessagesInvitedUsers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsJoinChannelParams struct {
	Channel InputChannel
}

func (*ChannelsJoinChannelParams) CRC() uint32 {
	return 0x24b524c5
}

// Join a channel/supergroup
func (c *Client) ChannelsJoinChannel(channel InputChannel) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsJoinChannelParams{Channel: channel})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsJoinChannel")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsLeaveChannelParams struct {
	Channel InputChannel
}

func (*ChannelsLeaveChannelParams) CRC() uint32 {
	return 0xf836aa95
}

// Leave a channel/supergroup
func (c *Client) ChannelsLeaveChannel(channel InputChannel) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsLeaveChannelParams{Channel: channel})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsLeaveChannel")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsReadHistoryParams struct {
	Channel InputChannel
	MaxID   int32
}

func (*ChannelsReadHistoryParams) CRC() uint32 {
	return 0xcc104937
}

// Mark channel/supergroup history as read
func (c *Client) ChannelsReadHistory(channel InputChannel, maxID int32) (bool, error) {
	responseData, err := c.MakeRequest(&ChannelsReadHistoryParams{
		Channel: channel,
		MaxID:   maxID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ChannelsReadHistory")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsReadMessageContentsParams struct {
	Channel InputChannel
	ID      []int32
}

func (*ChannelsReadMessageContentsParams) CRC() uint32 {
	return 0xeab5dc38
}

// Mark channel/supergroup message contents as read
func (c *Client) ChannelsReadMessageContents(channel InputChannel, id []int32) (bool, error) {
	responseData, err := c.MakeRequest(&ChannelsReadMessageContentsParams{
		Channel: channel,
		ID:      id,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ChannelsReadMessageContents")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsReorderPinnedForumTopicsParams struct {
	Force   bool `tl:"flag:0,encoded_in_bitflags"`
	Channel InputChannel
	Order   []int32
}

func (*ChannelsReorderPinnedForumTopicsParams) CRC() uint32 {
	return 0x2950a18f
}

func (*ChannelsReorderPinnedForumTopicsParams) FlagIndex() int {
	return 0
}

// Reorder pinned forum topics
func (c *Client) ChannelsReorderPinnedForumTopics(force bool, channel InputChannel, order []int32) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsReorderPinnedForumTopicsParams{
		Channel: channel,
		Force:   force,
		Order:   order,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsReorderPinnedForumTopics")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsReorderUsernamesParams struct {
	Channel InputChannel
	Order   []string
}

func (*ChannelsReorderUsernamesParams) CRC() uint32 {
	return 0xb45ced1d
}

// Reorder active usernames
func (c *Client) ChannelsReorderUsernames(channel InputChannel, order []string) (bool, error) {
	responseData, err := c.MakeRequest(&ChannelsReorderUsernamesParams{
		Channel: channel,
		Order:   order,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ChannelsReorderUsernames")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsReportAntiSpamFalsePositiveParams struct {
	Channel InputChannel
	MsgID   int32
}

func (*ChannelsReportAntiSpamFalsePositiveParams) CRC() uint32 {
	return 0xa850a693
}

// Report a native antispam false positive
func (c *Client) ChannelsReportAntiSpamFalsePositive(channel InputChannel, msgID int32) (bool, error) {
	responseData, err := c.MakeRequest(&ChannelsReportAntiSpamFalsePositiveParams{
		Channel: channel,
		MsgID:   msgID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ChannelsReportAntiSpamFalsePositive")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsReportSpamParams struct {
	Channel     InputChannel
	Participant InputPeer
	ID          []int32
}

func (*ChannelsReportSpamParams) CRC() uint32 {
	return 0xf44a8315
}

// Reports some messages from a user in a supergroup as spam; requires administrator rights in the supergroup
func (c *Client) ChannelsReportSpam(channel InputChannel, participant InputPeer, id []int32) (bool, error) {
	responseData, err := c.MakeRequest(&ChannelsReportSpamParams{
		Channel:     channel,
		ID:          id,
		Participant: participant,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ChannelsReportSpam")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsRestrictSponsoredMessagesParams struct {
	Channel    InputChannel
	Restricted bool
}

func (*ChannelsRestrictSponsoredMessagesParams) CRC() uint32 {
	return 0x9ae91519
}

// Disable ads on the specified channel, for all users.
func (c *Client) ChannelsRestrictSponsoredMessages(channel InputChannel, restricted bool) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsRestrictSponsoredMessagesParams{
		Channel:    channel,
		Restricted: restricted,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsRestrictSponsoredMessages")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsSearchPostsParams struct {
	Hashtag    string
	OffsetRate int32
	OffsetPeer InputPeer
	OffsetID   int32
	Limit      int32
}

func (*ChannelsSearchPostsParams) CRC() uint32 {
	return 0xd19f987b
}

// Globally search for posts from public channels » (<em>including</em> those we aren't a member of) containing a specific hashtag.
func (c *Client) ChannelsSearchPosts(hashtag string, offsetRate int32, offsetPeer InputPeer, offsetID, limit int32) (MessagesMessages, error) {
	responseData, err := c.MakeRequest(&ChannelsSearchPostsParams{
		Hashtag:    hashtag,
		Limit:      limit,
		OffsetID:   offsetID,
		OffsetPeer: offsetPeer,
		OffsetRate: offsetRate,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsSearchPosts")
	}

	resp, ok := responseData.(MessagesMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsSetBoostsToUnblockRestrictionsParams struct {
	Channel InputChannel
	Boosts  int32
}

func (*ChannelsSetBoostsToUnblockRestrictionsParams) CRC() uint32 {
	return 0xad399cee
}

// Admins with ban_users admin rights » may allow users that apply a certain number of booosts » to the group to bypass slow mode » and other » supergroup restrictions, see here » for more info.
func (c *Client) ChannelsSetBoostsToUnblockRestrictions(channel InputChannel, boosts int32) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsSetBoostsToUnblockRestrictionsParams{
		Boosts:  boosts,
		Channel: channel,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsSetBoostsToUnblockRestrictions")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsSetDiscussionGroupParams struct {
	Broadcast InputChannel
	Group     InputChannel
}

func (*ChannelsSetDiscussionGroupParams) CRC() uint32 {
	return 0x40582bb2
}

// Associate a group to a channel as discussion group for that channel
func (c *Client) ChannelsSetDiscussionGroup(broadcast, group InputChannel) (bool, error) {
	responseData, err := c.MakeRequest(&ChannelsSetDiscussionGroupParams{
		Broadcast: broadcast,
		Group:     group,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ChannelsSetDiscussionGroup")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsSetEmojiStickersParams struct {
	Channel    InputChannel
	Stickerset InputStickerSet
}

func (*ChannelsSetEmojiStickersParams) CRC() uint32 {
	return 0x3cd930b7
}

// Set a custom emoji stickerset for supergroups. Only usable after reaching at least the boost level » specified in the <a href="/api/config#group-emoji-stickers-level-min">`group_emoji_stickers_level_min` »</a> config parameter.
func (c *Client) ChannelsSetEmojiStickers(channel InputChannel, stickerset InputStickerSet) (bool, error) {
	responseData, err := c.MakeRequest(&ChannelsSetEmojiStickersParams{
		Channel:    channel,
		Stickerset: stickerset,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ChannelsSetEmojiStickers")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsSetStickersParams struct {
	Channel    InputChannel
	Stickerset InputStickerSet
}

func (*ChannelsSetStickersParams) CRC() uint32 {
	return 0xea8ca4f9
}

// Associate a stickerset to the supergroup
func (c *Client) ChannelsSetStickers(channel InputChannel, stickerset InputStickerSet) (bool, error) {
	responseData, err := c.MakeRequest(&ChannelsSetStickersParams{
		Channel:    channel,
		Stickerset: stickerset,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ChannelsSetStickers")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsToggleAntiSpamParams struct {
	Channel InputChannel
	Enabled bool
}

func (*ChannelsToggleAntiSpamParams) CRC() uint32 {
	return 0x68f3e4eb
}

// Enable or disable the native antispam system.
func (c *Client) ChannelsToggleAntiSpam(channel InputChannel, enabled bool) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsToggleAntiSpamParams{
		Channel: channel,
		Enabled: enabled,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsToggleAntiSpam")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsToggleForumParams struct {
	Channel InputChannel
	Enabled bool
}

func (*ChannelsToggleForumParams) CRC() uint32 {
	return 0xa4298b29
}

// Enable or disable forum functionality in a supergroup.
func (c *Client) ChannelsToggleForum(channel InputChannel, enabled bool) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsToggleForumParams{
		Channel: channel,
		Enabled: enabled,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsToggleForum")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsToggleJoinRequestParams struct {
	Channel InputChannel
	Enabled bool
}

func (*ChannelsToggleJoinRequestParams) CRC() uint32 {
	return 0x4c2985b6
}

// Set whether all users should request admin approval to join the group ».
func (c *Client) ChannelsToggleJoinRequest(channel InputChannel, enabled bool) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsToggleJoinRequestParams{
		Channel: channel,
		Enabled: enabled,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsToggleJoinRequest")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsToggleJoinToSendParams struct {
	Channel InputChannel
	Enabled bool
}

func (*ChannelsToggleJoinToSendParams) CRC() uint32 {
	return 0xe4cb9580
}

// Set whether all users should join a discussion group in order to comment on a post »
func (c *Client) ChannelsToggleJoinToSend(channel InputChannel, enabled bool) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsToggleJoinToSendParams{
		Channel: channel,
		Enabled: enabled,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsToggleJoinToSend")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsToggleParticipantsHiddenParams struct {
	Channel InputChannel
	Enabled bool
}

func (*ChannelsToggleParticipantsHiddenParams) CRC() uint32 {
	return 0x6a6e7854
}

// Hide or display the participants list in a supergroup.
func (c *Client) ChannelsToggleParticipantsHidden(channel InputChannel, enabled bool) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsToggleParticipantsHiddenParams{
		Channel: channel,
		Enabled: enabled,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsToggleParticipantsHidden")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsTogglePreHistoryHiddenParams struct {
	Channel InputChannel
	Enabled bool
}

func (*ChannelsTogglePreHistoryHiddenParams) CRC() uint32 {
	return 0xeabbb94c
}

// Hide/unhide message history for new channel/supergroup users
func (c *Client) ChannelsTogglePreHistoryHidden(channel InputChannel, enabled bool) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsTogglePreHistoryHiddenParams{
		Channel: channel,
		Enabled: enabled,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsTogglePreHistoryHidden")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsToggleSignaturesParams struct {
	SignaturesEnabled bool `tl:"flag:0,encoded_in_bitflags"`
	ProfilesEnabled   bool `tl:"flag:1,encoded_in_bitflags"`
	Channel           InputChannel
}

func (*ChannelsToggleSignaturesParams) CRC() uint32 {
	return 0x418d549c
}

func (*ChannelsToggleSignaturesParams) FlagIndex() int {
	return 0
}

// Enable/disable message signatures in channels
func (c *Client) ChannelsToggleSignatures(signaturesEnabled, profilesEnabled bool, channel InputChannel) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsToggleSignaturesParams{
		Channel:           channel,
		ProfilesEnabled:   profilesEnabled,
		SignaturesEnabled: signaturesEnabled,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsToggleSignatures")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsToggleSlowModeParams struct {
	Channel InputChannel
	Seconds int32
}

func (*ChannelsToggleSlowModeParams) CRC() uint32 {
	return 0xedd49ef0
}

// Toggle supergroup slow mode: if enabled, users will only be able to send one message every `seconds` seconds
func (c *Client) ChannelsToggleSlowMode(channel InputChannel, seconds int32) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsToggleSlowModeParams{
		Channel: channel,
		Seconds: seconds,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsToggleSlowMode")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsToggleUsernameParams struct {
	Channel  InputChannel
	Username string
	Active   bool
}

func (*ChannelsToggleUsernameParams) CRC() uint32 {
	return 0x50f24105
}

// Activate or deactivate a purchased fragment.com username associated to a supergroup or channel we own.
func (c *Client) ChannelsToggleUsername(channel InputChannel, username string, active bool) (bool, error) {
	responseData, err := c.MakeRequest(&ChannelsToggleUsernameParams{
		Active:   active,
		Channel:  channel,
		Username: username,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ChannelsToggleUsername")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsToggleViewForumAsMessagesParams struct {
	Channel InputChannel
	Enabled bool
}

func (*ChannelsToggleViewForumAsMessagesParams) CRC() uint32 {
	return 0x9738bb15
}

// Users may also choose to display messages from all topics of a forum as if they were sent to a normal group, using a "View as messages" setting in the local client: this setting only affects the current account, and is synced to other logged in sessions using this method.
func (c *Client) ChannelsToggleViewForumAsMessages(channel InputChannel, enabled bool) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsToggleViewForumAsMessagesParams{
		Channel: channel,
		Enabled: enabled,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsToggleViewForumAsMessages")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsUpdateColorParams struct {
	ForProfile        bool `tl:"flag:1,encoded_in_bitflags"`
	Channel           InputChannel
	Color             int32 `tl:"flag:2"`
	BackgroundEmojiID int64 `tl:"flag:0"`
}

func (*ChannelsUpdateColorParams) CRC() uint32 {
	return 0xd8aa3671
}

func (*ChannelsUpdateColorParams) FlagIndex() int {
	return 0
}

// Update the accent color and background custom emoji » of a channel.
func (c *Client) ChannelsUpdateColor(forProfile bool, channel InputChannel, color int32, backgroundEmojiID int64) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsUpdateColorParams{
		BackgroundEmojiID: backgroundEmojiID,
		Channel:           channel,
		Color:             color,
		ForProfile:        forProfile,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsUpdateColor")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsUpdateEmojiStatusParams struct {
	Channel     InputChannel
	EmojiStatus EmojiStatus
}

func (*ChannelsUpdateEmojiStatusParams) CRC() uint32 {
	return 0xf0d3e6a8
}

// Set an emoji status for a channel or supergroup.
func (c *Client) ChannelsUpdateEmojiStatus(channel InputChannel, emojiStatus EmojiStatus) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsUpdateEmojiStatusParams{
		Channel:     channel,
		EmojiStatus: emojiStatus,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsUpdateEmojiStatus")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsUpdatePinnedForumTopicParams struct {
	Channel InputChannel
	TopicID int32
	Pinned  bool
}

func (*ChannelsUpdatePinnedForumTopicParams) CRC() uint32 {
	return 0x6c2d9026
}

// Pin or unpin forum topics
func (c *Client) ChannelsUpdatePinnedForumTopic(channel InputChannel, topicID int32, pinned bool) (Updates, error) {
	responseData, err := c.MakeRequest(&ChannelsUpdatePinnedForumTopicParams{
		Channel: channel,
		Pinned:  pinned,
		TopicID: topicID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChannelsUpdatePinnedForumTopic")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChannelsUpdateUsernameParams struct {
	Channel  InputChannel
	Username string
}

func (*ChannelsUpdateUsernameParams) CRC() uint32 {
	return 0x3514b3de
}

// Change or remove the username of a supergroup/channel
func (c *Client) ChannelsUpdateUsername(channel InputChannel, username string) (bool, error) {
	responseData, err := c.MakeRequest(&ChannelsUpdateUsernameParams{
		Channel:  channel,
		Username: username,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ChannelsUpdateUsername")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChatlistsCheckChatlistInviteParams struct {
	Slug string
}

func (*ChatlistsCheckChatlistInviteParams) CRC() uint32 {
	return 0x41c10fff
}

// Obtain information about a chat folder deep link ».
func (c *Client) ChatlistsCheckChatlistInvite(slug string) (ChatlistsChatlistInvite, error) {
	responseData, err := c.MakeRequest(&ChatlistsCheckChatlistInviteParams{Slug: slug})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChatlistsCheckChatlistInvite")
	}

	resp, ok := responseData.(ChatlistsChatlistInvite)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChatlistsDeleteExportedInviteParams struct {
	Chatlist *InputChatlistDialogFilter
	Slug     string
}

func (*ChatlistsDeleteExportedInviteParams) CRC() uint32 {
	return 0x719c5c5e
}

// Delete a previously created chat folder deep link ».
func (c *Client) ChatlistsDeleteExportedInvite(chatlist *InputChatlistDialogFilter, slug string) (bool, error) {
	responseData, err := c.MakeRequest(&ChatlistsDeleteExportedInviteParams{
		Chatlist: chatlist,
		Slug:     slug,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ChatlistsDeleteExportedInvite")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChatlistsEditExportedInviteParams struct {
	Revoked  bool `tl:"flag:0,encoded_in_bitflags"`
	Chatlist *InputChatlistDialogFilter
	Slug     string
	Title    string      `tl:"flag:1"`
	Peers    []InputPeer `tl:"flag:2"`
}

func (*ChatlistsEditExportedInviteParams) CRC() uint32 {
	return 0x653db63d
}

func (*ChatlistsEditExportedInviteParams) FlagIndex() int {
	return 0
}

// Edit a chat folder deep link ».
func (c *Client) ChatlistsEditExportedInvite(params *ChatlistsEditExportedInviteParams) (*ExportedChatlistInvite, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending ChatlistsEditExportedInvite")
	}

	resp, ok := responseData.(*ExportedChatlistInvite)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChatlistsExportChatlistInviteParams struct {
	Chatlist *InputChatlistDialogFilter
	Title    string
	Peers    []InputPeer
}

func (*ChatlistsExportChatlistInviteParams) CRC() uint32 {
	return 0x8472478e
}

// Export a folder », creating a chat folder deep link ».
func (c *Client) ChatlistsExportChatlistInvite(chatlist *InputChatlistDialogFilter, title string, peers []InputPeer) (*ChatlistsExportedChatlistInvite, error) {
	responseData, err := c.MakeRequest(&ChatlistsExportChatlistInviteParams{
		Chatlist: chatlist,
		Peers:    peers,
		Title:    title,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChatlistsExportChatlistInvite")
	}

	resp, ok := responseData.(*ChatlistsExportedChatlistInvite)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChatlistsGetChatlistUpdatesParams struct {
	Chatlist *InputChatlistDialogFilter
}

func (*ChatlistsGetChatlistUpdatesParams) CRC() uint32 {
	return 0x89419521
}

// Fetch new chats associated with an imported chat folder deep link ». Must be invoked at most every `chatlist_update_period` seconds (as per the related client configuration parameter »).
func (c *Client) ChatlistsGetChatlistUpdates(chatlist *InputChatlistDialogFilter) (*ChatlistsChatlistUpdates, error) {
	responseData, err := c.MakeRequest(&ChatlistsGetChatlistUpdatesParams{Chatlist: chatlist})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChatlistsGetChatlistUpdates")
	}

	resp, ok := responseData.(*ChatlistsChatlistUpdates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChatlistsGetExportedInvitesParams struct {
	Chatlist *InputChatlistDialogFilter
}

func (*ChatlistsGetExportedInvitesParams) CRC() uint32 {
	return 0xce03da83
}

// List all chat folder deep links » associated to a folder
func (c *Client) ChatlistsGetExportedInvites(chatlist *InputChatlistDialogFilter) (*ChatlistsExportedInvites, error) {
	responseData, err := c.MakeRequest(&ChatlistsGetExportedInvitesParams{Chatlist: chatlist})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChatlistsGetExportedInvites")
	}

	resp, ok := responseData.(*ChatlistsExportedInvites)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChatlistsGetLeaveChatlistSuggestionsParams struct {
	Chatlist *InputChatlistDialogFilter
}

func (*ChatlistsGetLeaveChatlistSuggestionsParams) CRC() uint32 {
	return 0xfdbcd714
}

// Returns identifiers of pinned or always included chats from a chat folder imported using a chat folder deep link », which are suggested to be left when the chat folder is deleted.
func (c *Client) ChatlistsGetLeaveChatlistSuggestions(chatlist *InputChatlistDialogFilter) ([]Peer, error) {
	responseData, err := c.MakeRequest(&ChatlistsGetLeaveChatlistSuggestionsParams{Chatlist: chatlist})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChatlistsGetLeaveChatlistSuggestions")
	}

	resp, ok := responseData.([]Peer)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChatlistsHideChatlistUpdatesParams struct {
	Chatlist *InputChatlistDialogFilter
}

func (*ChatlistsHideChatlistUpdatesParams) CRC() uint32 {
	return 0x66e486fb
}

// Dismiss new pending peers recently added to a chat folder deep link ».
func (c *Client) ChatlistsHideChatlistUpdates(chatlist *InputChatlistDialogFilter) (bool, error) {
	responseData, err := c.MakeRequest(&ChatlistsHideChatlistUpdatesParams{Chatlist: chatlist})
	if err != nil {
		return false, errors.Wrap(err, "sending ChatlistsHideChatlistUpdates")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChatlistsJoinChatlistInviteParams struct {
	Slug  string
	Peers []InputPeer
}

func (*ChatlistsJoinChatlistInviteParams) CRC() uint32 {
	return 0xa6b1e39a
}

// Import a chat folder deep link », joining some or all the chats in the folder.
func (c *Client) ChatlistsJoinChatlistInvite(slug string, peers []InputPeer) (Updates, error) {
	responseData, err := c.MakeRequest(&ChatlistsJoinChatlistInviteParams{
		Peers: peers,
		Slug:  slug,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChatlistsJoinChatlistInvite")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChatlistsJoinChatlistUpdatesParams struct {
	Chatlist *InputChatlistDialogFilter
	Peers    []InputPeer
}

func (*ChatlistsJoinChatlistUpdatesParams) CRC() uint32 {
	return 0xe089f8f5
}

// Join channels and supergroups recently added to a chat folder deep link ».
func (c *Client) ChatlistsJoinChatlistUpdates(chatlist *InputChatlistDialogFilter, peers []InputPeer) (Updates, error) {
	responseData, err := c.MakeRequest(&ChatlistsJoinChatlistUpdatesParams{
		Chatlist: chatlist,
		Peers:    peers,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChatlistsJoinChatlistUpdates")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ChatlistsLeaveChatlistParams struct {
	Chatlist *InputChatlistDialogFilter
	Peers    []InputPeer
}

func (*ChatlistsLeaveChatlistParams) CRC() uint32 {
	return 0x74fae13a
}

// Delete a folder imported using a chat folder deep link »
func (c *Client) ChatlistsLeaveChatlist(chatlist *InputChatlistDialogFilter, peers []InputPeer) (Updates, error) {
	responseData, err := c.MakeRequest(&ChatlistsLeaveChatlistParams{
		Chatlist: chatlist,
		Peers:    peers,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ChatlistsLeaveChatlist")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsAcceptContactParams struct {
	ID InputUser
}

func (*ContactsAcceptContactParams) CRC() uint32 {
	return 0xf831a20f
}

// If the add contact action bar is active, add that user as contact
func (c *Client) ContactsAcceptContact(id InputUser) (Updates, error) {
	responseData, err := c.MakeRequest(&ContactsAcceptContactParams{ID: id})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsAcceptContact")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsAddContactParams struct {
	AddPhonePrivacyException bool `tl:"flag:0,encoded_in_bitflags"`
	ID                       InputUser
	FirstName                string
	LastName                 string
	Phone                    string
}

func (*ContactsAddContactParams) CRC() uint32 {
	return 0xe8f463d0
}

func (*ContactsAddContactParams) FlagIndex() int {
	return 0
}

// Add an existing telegram user as contact.
func (c *Client) ContactsAddContact(params *ContactsAddContactParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsAddContact")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsBlockParams struct {
	MyStoriesFrom bool `tl:"flag:0,encoded_in_bitflags"`
	ID            InputPeer
}

func (*ContactsBlockParams) CRC() uint32 {
	return 0x2e2e8734
}

func (*ContactsBlockParams) FlagIndex() int {
	return 0
}

// Adds a peer to a blocklist, see here » for more info.
func (c *Client) ContactsBlock(myStoriesFrom bool, id InputPeer) (bool, error) {
	responseData, err := c.MakeRequest(&ContactsBlockParams{
		ID:            id,
		MyStoriesFrom: myStoriesFrom,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ContactsBlock")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsBlockFromRepliesParams struct {
	DeleteMessage bool `tl:"flag:0,encoded_in_bitflags"`
	DeleteHistory bool `tl:"flag:1,encoded_in_bitflags"`
	ReportSpam    bool `tl:"flag:2,encoded_in_bitflags"`
	MsgID         int32
}

func (*ContactsBlockFromRepliesParams) CRC() uint32 {
	return 0x29a8962c
}

func (*ContactsBlockFromRepliesParams) FlagIndex() int {
	return 0
}

// Stop getting notifications about discussion replies of a certain user in `@replies`
func (c *Client) ContactsBlockFromReplies(deleteMessage, deleteHistory, reportSpam bool, msgID int32) (Updates, error) {
	responseData, err := c.MakeRequest(&ContactsBlockFromRepliesParams{
		DeleteHistory: deleteHistory,
		DeleteMessage: deleteMessage,
		MsgID:         msgID,
		ReportSpam:    reportSpam,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsBlockFromReplies")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsDeleteByPhonesParams struct {
	Phones []string
}

func (*ContactsDeleteByPhonesParams) CRC() uint32 {
	return 0x1013fd9e
}

// Delete contacts by phone number
func (c *Client) ContactsDeleteByPhones(phones []string) (bool, error) {
	responseData, err := c.MakeRequest(&ContactsDeleteByPhonesParams{Phones: phones})
	if err != nil {
		return false, errors.Wrap(err, "sending ContactsDeleteByPhones")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsDeleteContactsParams struct {
	ID []InputUser
}

func (*ContactsDeleteContactsParams) CRC() uint32 {
	return 0x96a0e00
}

// Deletes several contacts from the list.
func (c *Client) ContactsDeleteContacts(id []InputUser) (Updates, error) {
	responseData, err := c.MakeRequest(&ContactsDeleteContactsParams{ID: id})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsDeleteContacts")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsEditCloseFriendsParams struct {
	ID []int64
}

func (*ContactsEditCloseFriendsParams) CRC() uint32 {
	return 0xba6705f0
}

// Edit the close friends list, see here » for more info.
func (c *Client) ContactsEditCloseFriends(id []int64) (bool, error) {
	responseData, err := c.MakeRequest(&ContactsEditCloseFriendsParams{ID: id})
	if err != nil {
		return false, errors.Wrap(err, "sending ContactsEditCloseFriends")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsExportContactTokenParams struct{}

func (*ContactsExportContactTokenParams) CRC() uint32 {
	return 0xf8654027
}

// Generates a temporary profile link for the currently logged-in user.
func (c *Client) ContactsExportContactToken() (*ExportedContactToken, error) {
	responseData, err := c.MakeRequest(&ContactsExportContactTokenParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsExportContactToken")
	}

	resp, ok := responseData.(*ExportedContactToken)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsGetBirthdaysParams struct{}

func (*ContactsGetBirthdaysParams) CRC() uint32 {
	return 0xdaeda864
}

// Fetch all users with birthdays that fall within +1/-1 days, relative to the current day: this method should be invoked by clients every 6-8 hours, and if the result is non-empty, it should be used to appropriately update locally cached birthday information in user.`birthday`.
func (c *Client) ContactsGetBirthdays() (*ContactsContactBirthdays, error) {
	responseData, err := c.MakeRequest(&ContactsGetBirthdaysParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsGetBirthdays")
	}

	resp, ok := responseData.(*ContactsContactBirthdays)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsGetBlockedParams struct {
	MyStoriesFrom bool `tl:"flag:0,encoded_in_bitflags"`
	Offset        int32
	Limit         int32
}

func (*ContactsGetBlockedParams) CRC() uint32 {
	return 0x9a868f80
}

func (*ContactsGetBlockedParams) FlagIndex() int {
	return 0
}

// Returns the list of blocked users.
func (c *Client) ContactsGetBlocked(myStoriesFrom bool, offset, limit int32) (ContactsBlocked, error) {
	responseData, err := c.MakeRequest(&ContactsGetBlockedParams{
		Limit:         limit,
		MyStoriesFrom: myStoriesFrom,
		Offset:        offset,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsGetBlocked")
	}

	resp, ok := responseData.(ContactsBlocked)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsGetContactIDsParams struct {
	Hash int64
}

func (*ContactsGetContactIDsParams) CRC() uint32 {
	return 0x7adc669d
}

/*
Get the telegram IDs of all contacts.<br>
Returns an array of Telegram user IDs for all contacts (0 if a contact does not have an associated Telegram account or have hidden their account using privacy settings).
*/
func (c *Client) ContactsGetContactIDs(hash int64) ([]int32, error) {
	responseData, err := c.MakeRequest(&ContactsGetContactIDsParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsGetContactIDs")
	}

	resp, ok := responseData.([]int32)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsGetContactsParams struct {
	Hash int64
}

func (*ContactsGetContactsParams) CRC() uint32 {
	return 0x5dd69e12
}

// Returns the current user's contact list.
func (c *Client) ContactsGetContacts(hash int64) (ContactsContacts, error) {
	responseData, err := c.MakeRequest(&ContactsGetContactsParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsGetContacts")
	}

	resp, ok := responseData.(ContactsContacts)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsGetLocatedParams struct {
	Background  bool `tl:"flag:1,encoded_in_bitflags"`
	GeoPoint    InputGeoPoint
	SelfExpires int32 `tl:"flag:0"`
}

func (*ContactsGetLocatedParams) CRC() uint32 {
	return 0xd348bc44
}

func (*ContactsGetLocatedParams) FlagIndex() int {
	return 0
}

// Get users and geochats near you, see here » for more info.
func (c *Client) ContactsGetLocated(background bool, geoPoint InputGeoPoint, selfExpires int32) (Updates, error) {
	responseData, err := c.MakeRequest(&ContactsGetLocatedParams{
		Background:  background,
		GeoPoint:    geoPoint,
		SelfExpires: selfExpires,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsGetLocated")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsGetSavedParams struct{}

func (*ContactsGetSavedParams) CRC() uint32 {
	return 0x82f1e39f
}

// Get all contacts, requires a takeout session, see here » for more info.
func (c *Client) ContactsGetSaved() ([]*SavedPhoneContact, error) {
	responseData, err := c.MakeRequest(&ContactsGetSavedParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsGetSaved")
	}

	resp, ok := responseData.([]*SavedPhoneContact)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsGetStatusesParams struct{}

func (*ContactsGetStatusesParams) CRC() uint32 {
	return 0xc4a353ee
}

// Use this method to obtain the online statuses of all contacts with an accessible Telegram account.
func (c *Client) ContactsGetStatuses() ([]*ContactStatus, error) {
	responseData, err := c.MakeRequest(&ContactsGetStatusesParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsGetStatuses")
	}

	resp, ok := responseData.([]*ContactStatus)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsGetTopPeersParams struct {
	Correspondents bool `tl:"flag:0,encoded_in_bitflags"`
	BotsPm         bool `tl:"flag:1,encoded_in_bitflags"`
	BotsInline     bool `tl:"flag:2,encoded_in_bitflags"`
	PhoneCalls     bool `tl:"flag:3,encoded_in_bitflags"`
	ForwardUsers   bool `tl:"flag:4,encoded_in_bitflags"`
	ForwardChats   bool `tl:"flag:5,encoded_in_bitflags"`
	Groups         bool `tl:"flag:10,encoded_in_bitflags"`
	Channels       bool `tl:"flag:15,encoded_in_bitflags"`
	BotsApp        bool `tl:"flag:16,encoded_in_bitflags"`
	Offset         int32
	Limit          int32
	Hash           int64
}

func (*ContactsGetTopPeersParams) CRC() uint32 {
	return 0x973478b6
}

func (*ContactsGetTopPeersParams) FlagIndex() int {
	return 0
}

// Get most used peers
func (c *Client) ContactsGetTopPeers(params *ContactsGetTopPeersParams) (ContactsTopPeers, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsGetTopPeers")
	}

	resp, ok := responseData.(ContactsTopPeers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsImportCardParams struct {
	ExportCard []int32
}

func (*ContactsImportCardParams) CRC() uint32 {
	return 0x4fe196fe
}

// Returns general information on a user using his previously exported card as input.<br>The app may use it to open a conversation without knowing the user&#39;s phone number.
func (c *Client) ContactsImportCard(exportCard []int32) (User, error) {
	responseData, err := c.MakeRequest(&ContactsImportCardParams{ExportCard: exportCard})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsImportCard")
	}

	resp, ok := responseData.(User)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsImportContactTokenParams struct {
	Token string
}

func (*ContactsImportContactTokenParams) CRC() uint32 {
	return 0x13005788
}

// Obtain user info from a temporary profile link.
func (c *Client) ContactsImportContactToken(token string) (User, error) {
	responseData, err := c.MakeRequest(&ContactsImportContactTokenParams{Token: token})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsImportContactToken")
	}

	resp, ok := responseData.(User)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsImportContactsParams struct {
	Contacts []*InputPhoneContact
}

func (*ContactsImportContactsParams) CRC() uint32 {
	return 0x2c800be5
}

// Imports contacts: saves a full list on the server, adds already registered contacts to the contact list, returns added contacts and their info.
func (c *Client) ContactsImportContacts(contacts []*InputPhoneContact) (*ContactsImportedContacts, error) {
	responseData, err := c.MakeRequest(&ContactsImportContactsParams{Contacts: contacts})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsImportContacts")
	}

	resp, ok := responseData.(*ContactsImportedContacts)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsResetSavedParams struct{}

func (*ContactsResetSavedParams) CRC() uint32 {
	return 0x879537f1
}

// Removes all contacts without an associated Telegram account.
func (c *Client) ContactsResetSaved() (bool, error) {
	responseData, err := c.MakeRequest(&ContactsResetSavedParams{})
	if err != nil {
		return false, errors.Wrap(err, "sending ContactsResetSaved")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsResetTopPeerRatingParams struct {
	Category TopPeerCategory
	Peer     InputPeer
}

func (*ContactsResetTopPeerRatingParams) CRC() uint32 {
	return 0x1ae373ac
}

// Reset rating of top peer
func (c *Client) ContactsResetTopPeerRating(category TopPeerCategory, peer InputPeer) (bool, error) {
	responseData, err := c.MakeRequest(&ContactsResetTopPeerRatingParams{
		Category: category,
		Peer:     peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ContactsResetTopPeerRating")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsResolvePhoneParams struct {
	Phone string
}

func (*ContactsResolvePhoneParams) CRC() uint32 {
	return 0x8af94344
}

// Resolve a phone number to get user info, if their privacy settings allow it.
func (c *Client) ContactsResolvePhone(phone string) (*ContactsResolvedPeer, error) {
	responseData, err := c.MakeRequest(&ContactsResolvePhoneParams{Phone: phone})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsResolvePhone")
	}

	resp, ok := responseData.(*ContactsResolvedPeer)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsResolveUsernameParams struct {
	Username string
	Referer  string `tl:"flag:0"`
}

func (*ContactsResolveUsernameParams) CRC() uint32 {
	return 0x725afbbc
}

func (*ContactsResolveUsernameParams) FlagIndex() int {
	return 0
}

// Resolve a @username to get peer info
func (c *Client) ContactsResolveUsername(username, referer string) (*ContactsResolvedPeer, error) {
	responseData, err := c.MakeRequest(&ContactsResolveUsernameParams{
		Referer:  referer,
		Username: username,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsResolveUsername")
	}

	resp, ok := responseData.(*ContactsResolvedPeer)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsSearchParams struct {
	Q     string
	Limit int32
}

func (*ContactsSearchParams) CRC() uint32 {
	return 0x11f812d8
}

// Returns users found by username substring.
func (c *Client) ContactsSearch(q string, limit int32) (*ContactsFound, error) {
	responseData, err := c.MakeRequest(&ContactsSearchParams{
		Limit: limit,
		Q:     q,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending ContactsSearch")
	}

	resp, ok := responseData.(*ContactsFound)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsSetBlockedParams struct {
	MyStoriesFrom bool `tl:"flag:0,encoded_in_bitflags"`
	ID            []InputPeer
	Limit         int32
}

func (*ContactsSetBlockedParams) CRC() uint32 {
	return 0x94c65c76
}

func (*ContactsSetBlockedParams) FlagIndex() int {
	return 0
}

// Replace the contents of an entire blocklist, see here for more info ».
func (c *Client) ContactsSetBlocked(myStoriesFrom bool, id []InputPeer, limit int32) (bool, error) {
	responseData, err := c.MakeRequest(&ContactsSetBlockedParams{
		ID:            id,
		Limit:         limit,
		MyStoriesFrom: myStoriesFrom,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ContactsSetBlocked")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsToggleTopPeersParams struct {
	Enabled bool
}

func (*ContactsToggleTopPeersParams) CRC() uint32 {
	return 0x8514bdda
}

// Enable/disable top peers
func (c *Client) ContactsToggleTopPeers(enabled bool) (bool, error) {
	responseData, err := c.MakeRequest(&ContactsToggleTopPeersParams{Enabled: enabled})
	if err != nil {
		return false, errors.Wrap(err, "sending ContactsToggleTopPeers")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type ContactsUnblockParams struct {
	MyStoriesFrom bool `tl:"flag:0,encoded_in_bitflags"`
	ID            InputPeer
}

func (*ContactsUnblockParams) CRC() uint32 {
	return 0xb550d328
}

func (*ContactsUnblockParams) FlagIndex() int {
	return 0
}

// Deletes a peer from a blocklist, see here » for more info.
func (c *Client) ContactsUnblock(myStoriesFrom bool, id InputPeer) (bool, error) {
	responseData, err := c.MakeRequest(&ContactsUnblockParams{
		ID:            id,
		MyStoriesFrom: myStoriesFrom,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending ContactsUnblock")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type FoldersDeleteFolderParams struct {
	FolderID int32
}

func (*FoldersDeleteFolderParams) CRC() uint32 {
	return 0x1c295881
}

// Delete a peer folder
func (c *Client) FoldersDeleteFolder(folderID int32) (Updates, error) {
	responseData, err := c.MakeRequest(&FoldersDeleteFolderParams{FolderID: folderID})
	if err != nil {
		return nil, errors.Wrap(err, "sending FoldersDeleteFolder")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type FoldersEditPeerFoldersParams struct {
	FolderPeers []*InputFolderPeer
}

func (*FoldersEditPeerFoldersParams) CRC() uint32 {
	return 0x6847d0ab
}

// Edit peers in peer folder
func (c *Client) FoldersEditPeerFolders(folderPeers []*InputFolderPeer) (Updates, error) {
	responseData, err := c.MakeRequest(&FoldersEditPeerFoldersParams{FolderPeers: folderPeers})
	if err != nil {
		return nil, errors.Wrap(err, "sending FoldersEditPeerFolders")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type FragmentGetCollectibleInfoParams struct {
	Collectible InputCollectible
}

func (*FragmentGetCollectibleInfoParams) CRC() uint32 {
	return 0xbe1e85ba
}

// Fetch information about a fragment collectible, see here » for more info on the full flow.
func (c *Client) FragmentGetCollectibleInfo(collectible InputCollectible) (*FragmentCollectibleInfo, error) {
	responseData, err := c.MakeRequest(&FragmentGetCollectibleInfoParams{Collectible: collectible})
	if err != nil {
		return nil, errors.Wrap(err, "sending FragmentGetCollectibleInfo")
	}

	resp, ok := responseData.(*FragmentCollectibleInfo)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpAcceptTermsOfServiceParams struct {
	ID *DataJson
}

func (*HelpAcceptTermsOfServiceParams) CRC() uint32 {
	return 0xee72f79a
}

// Accept the new terms of service
func (c *Client) HelpAcceptTermsOfService(id *DataJson) (bool, error) {
	responseData, err := c.MakeRequest(&HelpAcceptTermsOfServiceParams{ID: id})
	if err != nil {
		return false, errors.Wrap(err, "sending HelpAcceptTermsOfService")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpDismissSuggestionParams struct {
	Peer       InputPeer
	Suggestion string
}

func (*HelpDismissSuggestionParams) CRC() uint32 {
	return 0xf50dbaa1
}

// Dismiss a suggestion, see here for more info ».
func (c *Client) HelpDismissSuggestion(peer InputPeer, suggestion string) (bool, error) {
	responseData, err := c.MakeRequest(&HelpDismissSuggestionParams{
		Peer:       peer,
		Suggestion: suggestion,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending HelpDismissSuggestion")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpEditUserInfoParams struct {
	UserID   InputUser
	Message  string
	Entities []MessageEntity
}

func (*HelpEditUserInfoParams) CRC() uint32 {
	return 0x66b91b70
}

// Internal use
func (c *Client) HelpEditUserInfo(userID InputUser, message string, entities []MessageEntity) (HelpUserInfo, error) {
	responseData, err := c.MakeRequest(&HelpEditUserInfoParams{
		Entities: entities,
		Message:  message,
		UserID:   userID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpEditUserInfo")
	}

	resp, ok := responseData.(HelpUserInfo)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetAppConfigParams struct {
	Hash int32
}

func (*HelpGetAppConfigParams) CRC() uint32 {
	return 0x61e3f854
}

// Get app-specific configuration, see client configuration for more info on the result.
func (c *Client) HelpGetAppConfig(hash int32) (HelpAppConfig, error) {
	responseData, err := c.MakeRequest(&HelpGetAppConfigParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetAppConfig")
	}

	resp, ok := responseData.(HelpAppConfig)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetAppUpdateParams struct {
	Source string
}

func (*HelpGetAppUpdateParams) CRC() uint32 {
	return 0x522d5a7d
}

// Returns information on update availability for the current application.
func (c *Client) HelpGetAppUpdate(source string) (HelpAppUpdate, error) {
	responseData, err := c.MakeRequest(&HelpGetAppUpdateParams{Source: source})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetAppUpdate")
	}

	resp, ok := responseData.(HelpAppUpdate)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetCdnConfigParams struct{}

func (*HelpGetCdnConfigParams) CRC() uint32 {
	return 0x52029342
}

// Get configuration for CDN file downloads.
func (c *Client) HelpGetCdnConfig() (*CdnConfig, error) {
	responseData, err := c.MakeRequest(&HelpGetCdnConfigParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetCdnConfig")
	}

	resp, ok := responseData.(*CdnConfig)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetConfigParams struct{}

func (*HelpGetConfigParams) CRC() uint32 {
	return 0xc4f9186b
}

// Returns current configuration, including data center configuration.
func (c *Client) HelpGetConfig() (*Config, error) {
	responseData, err := c.MakeRequest(&HelpGetConfigParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetConfig")
	}

	resp, ok := responseData.(*Config)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetCountriesListParams struct {
	LangCode string
	Hash     int32
}

func (*HelpGetCountriesListParams) CRC() uint32 {
	return 0x735787a8
}

// Get name, ISO code, localized name and phone codes/patterns of all available countries
func (c *Client) HelpGetCountriesList(langCode string, hash int32) (HelpCountriesList, error) {
	responseData, err := c.MakeRequest(&HelpGetCountriesListParams{
		Hash:     hash,
		LangCode: langCode,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetCountriesList")
	}

	resp, ok := responseData.(HelpCountriesList)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetDeepLinkInfoParams struct {
	Path string
}

func (*HelpGetDeepLinkInfoParams) CRC() uint32 {
	return 0x3fedc75f
}

// Get info about an unsupported deep link, see here for more info ».
func (c *Client) HelpGetDeepLinkInfo(path string) (HelpDeepLinkInfo, error) {
	responseData, err := c.MakeRequest(&HelpGetDeepLinkInfoParams{Path: path})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetDeepLinkInfo")
	}

	resp, ok := responseData.(HelpDeepLinkInfo)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetInviteTextParams struct{}

func (*HelpGetInviteTextParams) CRC() uint32 {
	return 0x4d392343
}

// Returns localized text of a text message with an invitation.
func (c *Client) HelpGetInviteText() (*HelpInviteText, error) {
	responseData, err := c.MakeRequest(&HelpGetInviteTextParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetInviteText")
	}

	resp, ok := responseData.(*HelpInviteText)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetNearestDcParams struct{}

func (*HelpGetNearestDcParams) CRC() uint32 {
	return 0x1fb33026
}

// Returns info on data center nearest to the user.
func (c *Client) HelpGetNearestDc() (*NearestDc, error) {
	responseData, err := c.MakeRequest(&HelpGetNearestDcParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetNearestDc")
	}

	resp, ok := responseData.(*NearestDc)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetPassportConfigParams struct {
	Hash int32
}

func (*HelpGetPassportConfigParams) CRC() uint32 {
	return 0xc661ad08
}

// Get passport configuration
func (c *Client) HelpGetPassportConfig(hash int32) (HelpPassportConfig, error) {
	responseData, err := c.MakeRequest(&HelpGetPassportConfigParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetPassportConfig")
	}

	resp, ok := responseData.(HelpPassportConfig)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetPeerColorsParams struct {
	Hash int32
}

func (*HelpGetPeerColorsParams) CRC() uint32 {
	return 0xda80f42f
}

// Get the set of accent color palettes » that can be used for message accents.
func (c *Client) HelpGetPeerColors(hash int32) (HelpPeerColors, error) {
	responseData, err := c.MakeRequest(&HelpGetPeerColorsParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetPeerColors")
	}

	resp, ok := responseData.(HelpPeerColors)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetPeerProfileColorsParams struct {
	Hash int32
}

func (*HelpGetPeerProfileColorsParams) CRC() uint32 {
	return 0xabcfa9fd
}

// Get the set of accent color palettes » that can be used in profile page backgrounds.
func (c *Client) HelpGetPeerProfileColors(hash int32) (HelpPeerColors, error) {
	responseData, err := c.MakeRequest(&HelpGetPeerProfileColorsParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetPeerProfileColors")
	}

	resp, ok := responseData.(HelpPeerColors)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetPremiumPromoParams struct{}

func (*HelpGetPremiumPromoParams) CRC() uint32 {
	return 0xb81b93d4
}

// Get Telegram Premium promotion information
func (c *Client) HelpGetPremiumPromo() (*HelpPremiumPromo, error) {
	responseData, err := c.MakeRequest(&HelpGetPremiumPromoParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetPremiumPromo")
	}

	resp, ok := responseData.(*HelpPremiumPromo)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetPromoDataParams struct{}

func (*HelpGetPromoDataParams) CRC() uint32 {
	return 0xc0977421
}

// Get MTProxy/Public Service Announcement information
func (c *Client) HelpGetPromoData() (HelpPromoData, error) {
	responseData, err := c.MakeRequest(&HelpGetPromoDataParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetPromoData")
	}

	resp, ok := responseData.(HelpPromoData)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetRecentMeUrlsParams struct {
	Referer string
}

func (*HelpGetRecentMeUrlsParams) CRC() uint32 {
	return 0x3dc0f114
}

// Get recently used `t.me` links.
func (c *Client) HelpGetRecentMeUrls(referer string) (*HelpRecentMeUrls, error) {
	responseData, err := c.MakeRequest(&HelpGetRecentMeUrlsParams{Referer: referer})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetRecentMeUrls")
	}

	resp, ok := responseData.(*HelpRecentMeUrls)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetSupportParams struct{}

func (*HelpGetSupportParams) CRC() uint32 {
	return 0x9cdf08cd
}

// Returns the support user for the "ask a question" feature.
func (c *Client) HelpGetSupport() (*HelpSupport, error) {
	responseData, err := c.MakeRequest(&HelpGetSupportParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetSupport")
	}

	resp, ok := responseData.(*HelpSupport)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetSupportNameParams struct{}

func (*HelpGetSupportNameParams) CRC() uint32 {
	return 0xd360e72c
}

// Get localized name of the telegram support user
func (c *Client) HelpGetSupportName() (*HelpSupportName, error) {
	responseData, err := c.MakeRequest(&HelpGetSupportNameParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetSupportName")
	}

	resp, ok := responseData.(*HelpSupportName)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetTermsOfServiceUpdateParams struct{}

func (*HelpGetTermsOfServiceUpdateParams) CRC() uint32 {
	return 0x2ca51fd1
}

// Look for updates of telegram's terms of service
func (c *Client) HelpGetTermsOfServiceUpdate() (HelpTermsOfServiceUpdate, error) {
	responseData, err := c.MakeRequest(&HelpGetTermsOfServiceUpdateParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetTermsOfServiceUpdate")
	}

	resp, ok := responseData.(HelpTermsOfServiceUpdate)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetTimezonesListParams struct {
	Hash int32
}

func (*HelpGetTimezonesListParams) CRC() uint32 {
	return 0x49b30240
}

// Returns timezone information that may be used elsewhere in the API, such as to set Telegram Business opening hours ».
func (c *Client) HelpGetTimezonesList(hash int32) (HelpTimezonesList, error) {
	responseData, err := c.MakeRequest(&HelpGetTimezonesListParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetTimezonesList")
	}

	resp, ok := responseData.(HelpTimezonesList)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpGetUserInfoParams struct {
	UserID InputUser
}

func (*HelpGetUserInfoParams) CRC() uint32 {
	return 0x38a08d3
}

// Can only be used by TSF members to obtain internal information.
func (c *Client) HelpGetUserInfo(userID InputUser) (HelpUserInfo, error) {
	responseData, err := c.MakeRequest(&HelpGetUserInfoParams{UserID: userID})
	if err != nil {
		return nil, errors.Wrap(err, "sending HelpGetUserInfo")
	}

	resp, ok := responseData.(HelpUserInfo)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpHidePromoDataParams struct {
	Peer InputPeer
}

func (*HelpHidePromoDataParams) CRC() uint32 {
	return 0x1e251c95
}

// Hide MTProxy/Public Service Announcement information
func (c *Client) HelpHidePromoData(peer InputPeer) (bool, error) {
	responseData, err := c.MakeRequest(&HelpHidePromoDataParams{Peer: peer})
	if err != nil {
		return false, errors.Wrap(err, "sending HelpHidePromoData")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpSaveAppLogParams struct {
	Events []*InputAppEvent
}

func (*HelpSaveAppLogParams) CRC() uint32 {
	return 0x6f02f748
}

// Saves logs of application on the server.
func (c *Client) HelpSaveAppLog(events []*InputAppEvent) (bool, error) {
	responseData, err := c.MakeRequest(&HelpSaveAppLogParams{Events: events})
	if err != nil {
		return false, errors.Wrap(err, "sending HelpSaveAppLog")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type HelpSetBotUpdatesStatusParams struct {
	PendingUpdatesCount int32
	Message             string
}

func (*HelpSetBotUpdatesStatusParams) CRC() uint32 {
	return 0xec22cfcd
}

// Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only
func (c *Client) HelpSetBotUpdatesStatus(pendingUpdatesCount int32, message string) (bool, error) {
	responseData, err := c.MakeRequest(&HelpSetBotUpdatesStatusParams{
		Message:             message,
		PendingUpdatesCount: pendingUpdatesCount,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending HelpSetBotUpdatesStatus")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type LangpackGetDifferenceParams struct {
	LangPack    string
	LangCode    string
	FromVersion int32
}

func (*LangpackGetDifferenceParams) CRC() uint32 {
	return 0xcd984aa5
}

// Get new strings in language pack
func (c *Client) LangpackGetDifference(langPack, langCode string, fromVersion int32) (*LangPackDifference, error) {
	responseData, err := c.MakeRequest(&LangpackGetDifferenceParams{
		FromVersion: fromVersion,
		LangCode:    langCode,
		LangPack:    langPack,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending LangpackGetDifference")
	}

	resp, ok := responseData.(*LangPackDifference)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type LangpackGetLangPackParams struct {
	LangPack string
	LangCode string
}

func (*LangpackGetLangPackParams) CRC() uint32 {
	return 0xf2f2330a
}

// Get localization pack strings
func (c *Client) LangpackGetLangPack(langPack, langCode string) (*LangPackDifference, error) {
	responseData, err := c.MakeRequest(&LangpackGetLangPackParams{
		LangCode: langCode,
		LangPack: langPack,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending LangpackGetLangPack")
	}

	resp, ok := responseData.(*LangPackDifference)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type LangpackGetLanguageParams struct {
	LangPack string
	LangCode string
}

func (*LangpackGetLanguageParams) CRC() uint32 {
	return 0x6a596502
}

// Get information about a language in a localization pack
func (c *Client) LangpackGetLanguage(langPack, langCode string) (*LangPackLanguage, error) {
	responseData, err := c.MakeRequest(&LangpackGetLanguageParams{
		LangCode: langCode,
		LangPack: langPack,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending LangpackGetLanguage")
	}

	resp, ok := responseData.(*LangPackLanguage)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type LangpackGetLanguagesParams struct {
	LangPack string
}

func (*LangpackGetLanguagesParams) CRC() uint32 {
	return 0x42c6978f
}

// Get information about all languages in a localization pack
func (c *Client) LangpackGetLanguages(langPack string) ([]*LangPackLanguage, error) {
	responseData, err := c.MakeRequest(&LangpackGetLanguagesParams{LangPack: langPack})
	if err != nil {
		return nil, errors.Wrap(err, "sending LangpackGetLanguages")
	}

	resp, ok := responseData.([]*LangPackLanguage)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type LangpackGetStringsParams struct {
	LangPack string
	LangCode string
	Keys     []string
}

func (*LangpackGetStringsParams) CRC() uint32 {
	return 0xefea3803
}

// Get strings from a language pack
func (c *Client) LangpackGetStrings(langPack, langCode string, keys []string) ([]LangPackString, error) {
	responseData, err := c.MakeRequest(&LangpackGetStringsParams{
		Keys:     keys,
		LangCode: langCode,
		LangPack: langPack,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending LangpackGetStrings")
	}

	resp, ok := responseData.([]LangPackString)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesAcceptEncryptionParams struct {
	Peer           *InputEncryptedChat
	GB             []byte
	KeyFingerprint int64
}

func (*MessagesAcceptEncryptionParams) CRC() uint32 {
	return 0x3dbc0415
}

// Confirms creation of a secret chat
func (c *Client) MessagesAcceptEncryption(peer *InputEncryptedChat, gB []byte, keyFingerprint int64) (EncryptedChat, error) {
	responseData, err := c.MakeRequest(&MessagesAcceptEncryptionParams{
		GB:             gB,
		KeyFingerprint: keyFingerprint,
		Peer:           peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesAcceptEncryption")
	}

	resp, ok := responseData.(EncryptedChat)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesAcceptURLAuthParams struct {
	WriteAllowed bool      `tl:"flag:0,encoded_in_bitflags"`
	Peer         InputPeer `tl:"flag:1"`
	MsgID        int32     `tl:"flag:1"`
	ButtonID     int32     `tl:"flag:1"`
	URL          string    `tl:"flag:2"`
}

func (*MessagesAcceptURLAuthParams) CRC() uint32 {
	return 0xb12c7125
}

func (*MessagesAcceptURLAuthParams) FlagIndex() int {
	return 0
}

// Use this to accept a Seamless Telegram Login authorization request, for more info click here »
func (c *Client) MessagesAcceptURLAuth(params *MessagesAcceptURLAuthParams) (URLAuthResult, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesAcceptURLAuth")
	}

	resp, ok := responseData.(URLAuthResult)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesAddChatUserParams struct {
	ChatID   int64
	UserID   InputUser
	FwdLimit int32
}

func (*MessagesAddChatUserParams) CRC() uint32 {
	return 0xcbc6d107
}

// Adds a user to a chat and sends a service message on it.
func (c *Client) MessagesAddChatUser(chatID int64, userID InputUser, fwdLimit int32) (*MessagesInvitedUsers, error) {
	responseData, err := c.MakeRequest(&MessagesAddChatUserParams{
		ChatID:   chatID,
		FwdLimit: fwdLimit,
		UserID:   userID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesAddChatUser")
	}

	resp, ok := responseData.(*MessagesInvitedUsers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesCheckChatInviteParams struct {
	Hash string
}

func (*MessagesCheckChatInviteParams) CRC() uint32 {
	return 0x3eadb1bb
}

// Check the validity of a chat invite link and get basic info about it
func (c *Client) MessagesCheckChatInvite(hash string) (ChatInvite, error) {
	responseData, err := c.MakeRequest(&MessagesCheckChatInviteParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesCheckChatInvite")
	}

	resp, ok := responseData.(ChatInvite)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesCheckHistoryImportParams struct {
	ImportHead string
}

func (*MessagesCheckHistoryImportParams) CRC() uint32 {
	return 0x43fe19f3
}

// Obtains information about a chat export file, generated by a foreign chat app, click here for more info about imported chats ».
func (c *Client) MessagesCheckHistoryImport(importHead string) (*MessagesHistoryImportParsed, error) {
	responseData, err := c.MakeRequest(&MessagesCheckHistoryImportParams{ImportHead: importHead})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesCheckHistoryImport")
	}

	resp, ok := responseData.(*MessagesHistoryImportParsed)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesCheckHistoryImportPeerParams struct {
	Peer InputPeer
}

func (*MessagesCheckHistoryImportPeerParams) CRC() uint32 {
	return 0x5dc60f03
}

// Check whether chat history exported from another chat app can be imported into a specific Telegram chat, click here for more info ».
func (c *Client) MessagesCheckHistoryImportPeer(peer InputPeer) (*MessagesCheckedHistoryImportPeer, error) {
	responseData, err := c.MakeRequest(&MessagesCheckHistoryImportPeerParams{Peer: peer})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesCheckHistoryImportPeer")
	}

	resp, ok := responseData.(*MessagesCheckedHistoryImportPeer)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesCheckQuickReplyShortcutParams struct {
	Shortcut string
}

func (*MessagesCheckQuickReplyShortcutParams) CRC() uint32 {
	return 0xf1d0fbd3
}

// Before offering the user the choice to add a message to a quick reply shortcut, to make sure that none of the limits specified here » were reached.
func (c *Client) MessagesCheckQuickReplyShortcut(shortcut string) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesCheckQuickReplyShortcutParams{Shortcut: shortcut})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesCheckQuickReplyShortcut")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesClearAllDraftsParams struct{}

func (*MessagesClearAllDraftsParams) CRC() uint32 {
	return 0x7e58ee9c
}

// Clear all drafts.
func (c *Client) MessagesClearAllDrafts() (bool, error) {
	responseData, err := c.MakeRequest(&MessagesClearAllDraftsParams{})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesClearAllDrafts")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesClearRecentReactionsParams struct{}

func (*MessagesClearRecentReactionsParams) CRC() uint32 {
	return 0x9dfeefb4
}

// Clear recently used message reactions
func (c *Client) MessagesClearRecentReactions() (bool, error) {
	responseData, err := c.MakeRequest(&MessagesClearRecentReactionsParams{})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesClearRecentReactions")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesClearRecentStickersParams struct {
	Attached bool `tl:"flag:0,encoded_in_bitflags"`
}

func (*MessagesClearRecentStickersParams) CRC() uint32 {
	return 0x8999602d
}

func (*MessagesClearRecentStickersParams) FlagIndex() int {
	return 0
}

// Clear recent stickers
func (c *Client) MessagesClearRecentStickers(attached bool) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesClearRecentStickersParams{Attached: attached})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesClearRecentStickers")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesClickSponsoredMessageParams struct {
	Media      bool `tl:"flag:0,encoded_in_bitflags"`
	Fullscreen bool `tl:"flag:1,encoded_in_bitflags"`
	Peer       InputPeer
	RandomID   []byte
}

func (*MessagesClickSponsoredMessageParams) CRC() uint32 {
	return 0xf093465
}

func (*MessagesClickSponsoredMessageParams) FlagIndex() int {
	return 0
}

// Informs the server that the user has interacted with a sponsored message in one of the ways listed here ».
func (c *Client) MessagesClickSponsoredMessage(media, fullscreen bool, peer InputPeer, randomID []byte) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesClickSponsoredMessageParams{
		Fullscreen: fullscreen,
		Media:      media,
		Peer:       peer,
		RandomID:   randomID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesClickSponsoredMessage")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesCreateChatParams struct {
	Users     []InputUser
	Title     string
	TtlPeriod int32 `tl:"flag:0"`
}

func (*MessagesCreateChatParams) CRC() uint32 {
	return 0x92ceddd4
}

func (*MessagesCreateChatParams) FlagIndex() int {
	return 0
}

// Creates a new chat.
func (c *Client) MessagesCreateChat(users []InputUser, title string, ttlPeriod int32) (*MessagesInvitedUsers, error) {
	responseData, err := c.MakeRequest(&MessagesCreateChatParams{
		Title:     title,
		TtlPeriod: ttlPeriod,
		Users:     users,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesCreateChat")
	}

	resp, ok := responseData.(*MessagesInvitedUsers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesDeleteChatParams struct {
	ChatID int64
}

func (*MessagesDeleteChatParams) CRC() uint32 {
	return 0x5bd0ee50
}

// Delete a chat
func (c *Client) MessagesDeleteChat(chatID int64) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesDeleteChatParams{ChatID: chatID})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesDeleteChat")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesDeleteChatUserParams struct {
	RevokeHistory bool `tl:"flag:0,encoded_in_bitflags"`
	ChatID        int64
	UserID        InputUser
}

func (*MessagesDeleteChatUserParams) CRC() uint32 {
	return 0xa2185cab
}

func (*MessagesDeleteChatUserParams) FlagIndex() int {
	return 0
}

// Deletes a user from a chat and sends a service message on it.
func (c *Client) MessagesDeleteChatUser(revokeHistory bool, chatID int64, userID InputUser) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesDeleteChatUserParams{
		ChatID:        chatID,
		RevokeHistory: revokeHistory,
		UserID:        userID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesDeleteChatUser")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesDeleteExportedChatInviteParams struct {
	Peer InputPeer
	Link string
}

func (*MessagesDeleteExportedChatInviteParams) CRC() uint32 {
	return 0xd464a42b
}

// Delete a chat invite
func (c *Client) MessagesDeleteExportedChatInvite(peer InputPeer, link string) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesDeleteExportedChatInviteParams{
		Link: link,
		Peer: peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesDeleteExportedChatInvite")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesDeleteFactCheckParams struct {
	Peer  InputPeer
	MsgID int32
}

func (*MessagesDeleteFactCheckParams) CRC() uint32 {
	return 0xd1da940c
}

// Delete a fact-check from a message.
func (c *Client) MessagesDeleteFactCheck(peer InputPeer, msgID int32) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesDeleteFactCheckParams{
		MsgID: msgID,
		Peer:  peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesDeleteFactCheck")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesDeleteHistoryParams struct {
	JustClear bool `tl:"flag:0,encoded_in_bitflags"`
	Revoke    bool `tl:"flag:1,encoded_in_bitflags"`
	Peer      InputPeer
	MaxID     int32
	MinDate   int32 `tl:"flag:2"`
	MaxDate   int32 `tl:"flag:3"`
}

func (*MessagesDeleteHistoryParams) CRC() uint32 {
	return 0xb08f922a
}

func (*MessagesDeleteHistoryParams) FlagIndex() int {
	return 0
}

// Deletes communication history.
func (c *Client) MessagesDeleteHistory(params *MessagesDeleteHistoryParams) (*MessagesAffectedHistory, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesDeleteHistory")
	}

	resp, ok := responseData.(*MessagesAffectedHistory)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesDeleteMessagesParams struct {
	Revoke bool `tl:"flag:0,encoded_in_bitflags"`
	ID     []int32
}

func (*MessagesDeleteMessagesParams) CRC() uint32 {
	return 0xe58e95d2
}

func (*MessagesDeleteMessagesParams) FlagIndex() int {
	return 0
}

// Deletes messages by their identifiers.
func (c *Client) MessagesDeleteMessages(revoke bool, id []int32) (*MessagesAffectedMessages, error) {
	responseData, err := c.MakeRequest(&MessagesDeleteMessagesParams{
		ID:     id,
		Revoke: revoke,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesDeleteMessages")
	}

	resp, ok := responseData.(*MessagesAffectedMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesDeletePhoneCallHistoryParams struct {
	Revoke bool `tl:"flag:0,encoded_in_bitflags"`
}

func (*MessagesDeletePhoneCallHistoryParams) CRC() uint32 {
	return 0xf9cbe409
}

func (*MessagesDeletePhoneCallHistoryParams) FlagIndex() int {
	return 0
}

// Delete the entire phone call history.
func (c *Client) MessagesDeletePhoneCallHistory(revoke bool) (*MessagesAffectedFoundMessages, error) {
	responseData, err := c.MakeRequest(&MessagesDeletePhoneCallHistoryParams{Revoke: revoke})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesDeletePhoneCallHistory")
	}

	resp, ok := responseData.(*MessagesAffectedFoundMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesDeleteQuickReplyMessagesParams struct {
	ShortcutID int32
	ID         []int32
}

func (*MessagesDeleteQuickReplyMessagesParams) CRC() uint32 {
	return 0xe105e910
}

// Delete one or more messages from a quick reply shortcut. This will also emit an updateDeleteQuickReplyMessages update.
func (c *Client) MessagesDeleteQuickReplyMessages(shortcutID int32, id []int32) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesDeleteQuickReplyMessagesParams{
		ID:         id,
		ShortcutID: shortcutID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesDeleteQuickReplyMessages")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesDeleteQuickReplyShortcutParams struct {
	ShortcutID int32
}

func (*MessagesDeleteQuickReplyShortcutParams) CRC() uint32 {
	return 0x3cc04740
}

/*
Completely delete a quick reply shortcut.<br>
This will also emit an updateDeleteQuickReply update to other logged-in sessions (and <em>no</em> updateDeleteQuickReplyMessages updates, even if all the messages in the shortcuts are also deleted by this method).
*/
func (c *Client) MessagesDeleteQuickReplyShortcut(shortcutID int32) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesDeleteQuickReplyShortcutParams{ShortcutID: shortcutID})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesDeleteQuickReplyShortcut")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesDeleteRevokedExportedChatInvitesParams struct {
	Peer    InputPeer
	AdminID InputUser
}

func (*MessagesDeleteRevokedExportedChatInvitesParams) CRC() uint32 {
	return 0x56987bd5
}

// Delete all revoked chat invites
func (c *Client) MessagesDeleteRevokedExportedChatInvites(peer InputPeer, adminID InputUser) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesDeleteRevokedExportedChatInvitesParams{
		AdminID: adminID,
		Peer:    peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesDeleteRevokedExportedChatInvites")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesDeleteSavedHistoryParams struct {
	Peer    InputPeer
	MaxID   int32
	MinDate int32 `tl:"flag:2"`
	MaxDate int32 `tl:"flag:3"`
}

func (*MessagesDeleteSavedHistoryParams) CRC() uint32 {
	return 0x6e98102b
}

func (*MessagesDeleteSavedHistoryParams) FlagIndex() int {
	return 0
}

// Deletes messages forwarded from a specific peer to saved messages ».
func (c *Client) MessagesDeleteSavedHistory(peer InputPeer, maxID, minDate, maxDate int32) (*MessagesAffectedHistory, error) {
	responseData, err := c.MakeRequest(&MessagesDeleteSavedHistoryParams{
		MaxDate: maxDate,
		MaxID:   maxID,
		MinDate: minDate,
		Peer:    peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesDeleteSavedHistory")
	}

	resp, ok := responseData.(*MessagesAffectedHistory)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesDeleteScheduledMessagesParams struct {
	Peer InputPeer
	ID   []int32
}

func (*MessagesDeleteScheduledMessagesParams) CRC() uint32 {
	return 0x59ae2b16
}

// Delete scheduled messages
func (c *Client) MessagesDeleteScheduledMessages(peer InputPeer, id []int32) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesDeleteScheduledMessagesParams{
		ID:   id,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesDeleteScheduledMessages")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesDiscardEncryptionParams struct {
	DeleteHistory bool `tl:"flag:0,encoded_in_bitflags"`
	ChatID        int32
}

func (*MessagesDiscardEncryptionParams) CRC() uint32 {
	return 0xf393aea0
}

func (*MessagesDiscardEncryptionParams) FlagIndex() int {
	return 0
}

// Cancels a request for creation and/or delete info on secret chat.
func (c *Client) MessagesDiscardEncryption(deleteHistory bool, chatID int32) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesDiscardEncryptionParams{
		ChatID:        chatID,
		DeleteHistory: deleteHistory,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesDiscardEncryption")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesEditChatAboutParams struct {
	Peer  InputPeer
	About string
}

func (*MessagesEditChatAboutParams) CRC() uint32 {
	return 0xdef60797
}

// Edit the description of a group/supergroup/channel.
func (c *Client) MessagesEditChatAbout(peer InputPeer, about string) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesEditChatAboutParams{
		About: about,
		Peer:  peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesEditChatAbout")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesEditChatAdminParams struct {
	ChatID  int64
	UserID  InputUser
	IsAdmin bool
}

func (*MessagesEditChatAdminParams) CRC() uint32 {
	return 0xa85bd1c2
}

// Make a user admin in a basic group.
func (c *Client) MessagesEditChatAdmin(chatID int64, userID InputUser, isAdmin bool) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesEditChatAdminParams{
		ChatID:  chatID,
		IsAdmin: isAdmin,
		UserID:  userID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesEditChatAdmin")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesEditChatDefaultBannedRightsParams struct {
	Peer         InputPeer
	BannedRights *ChatBannedRights
}

func (*MessagesEditChatDefaultBannedRightsParams) CRC() uint32 {
	return 0xa5866b41
}

// Edit the default banned rights of a channel/supergroup/group.
func (c *Client) MessagesEditChatDefaultBannedRights(peer InputPeer, bannedRights *ChatBannedRights) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesEditChatDefaultBannedRightsParams{
		BannedRights: bannedRights,
		Peer:         peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesEditChatDefaultBannedRights")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesEditChatPhotoParams struct {
	ChatID int64
	Photo  InputChatPhoto
}

func (*MessagesEditChatPhotoParams) CRC() uint32 {
	return 0x35ddd674
}

// Changes chat photo and sends a service message on it
func (c *Client) MessagesEditChatPhoto(chatID int64, photo InputChatPhoto) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesEditChatPhotoParams{
		ChatID: chatID,
		Photo:  photo,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesEditChatPhoto")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesEditChatTitleParams struct {
	ChatID int64
	Title  string
}

func (*MessagesEditChatTitleParams) CRC() uint32 {
	return 0x73783ffd
}

// Changes chat name and sends a service message on it.
func (c *Client) MessagesEditChatTitle(chatID int64, title string) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesEditChatTitleParams{
		ChatID: chatID,
		Title:  title,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesEditChatTitle")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesEditExportedChatInviteParams struct {
	Revoked       bool `tl:"flag:2,encoded_in_bitflags"`
	Peer          InputPeer
	Link          string
	ExpireDate    int32  `tl:"flag:0"`
	UsageLimit    int32  `tl:"flag:1"`
	RequestNeeded bool   `tl:"flag:3"`
	Title         string `tl:"flag:4"`
}

func (*MessagesEditExportedChatInviteParams) CRC() uint32 {
	return 0xbdca2f75
}

func (*MessagesEditExportedChatInviteParams) FlagIndex() int {
	return 0
}

// Edit an exported chat invite
func (c *Client) MessagesEditExportedChatInvite(params *MessagesEditExportedChatInviteParams) (MessagesExportedChatInvite, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesEditExportedChatInvite")
	}

	resp, ok := responseData.(MessagesExportedChatInvite)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesEditFactCheckParams struct {
	Peer  InputPeer
	MsgID int32
	Text  *TextWithEntities
}

func (*MessagesEditFactCheckParams) CRC() uint32 {
	return 0x589ee75
}

// Edit/create a fact-check on a message.
func (c *Client) MessagesEditFactCheck(peer InputPeer, msgID int32, text *TextWithEntities) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesEditFactCheckParams{
		MsgID: msgID,
		Peer:  peer,
		Text:  text,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesEditFactCheck")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesEditInlineBotMessageParams struct {
	NoWebpage   bool `tl:"flag:1,encoded_in_bitflags"`
	InvertMedia bool `tl:"flag:16,encoded_in_bitflags"`
	ID          InputBotInlineMessageID
	Message     string          `tl:"flag:11"`
	Media       InputMedia      `tl:"flag:14"`
	ReplyMarkup ReplyMarkup     `tl:"flag:2"`
	Entities    []MessageEntity `tl:"flag:3"`
}

func (*MessagesEditInlineBotMessageParams) CRC() uint32 {
	return 0x83557dba
}

func (*MessagesEditInlineBotMessageParams) FlagIndex() int {
	return 0
}

// Edit an inline bot message
func (c *Client) MessagesEditInlineBotMessage(params *MessagesEditInlineBotMessageParams) (bool, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesEditInlineBotMessage")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesEditMessageParams struct {
	NoWebpage            bool `tl:"flag:1,encoded_in_bitflags"`
	InvertMedia          bool `tl:"flag:16,encoded_in_bitflags"`
	Peer                 InputPeer
	ID                   int32
	Message              string          `tl:"flag:11"`
	Media                InputMedia      `tl:"flag:14"`
	ReplyMarkup          ReplyMarkup     `tl:"flag:2"`
	Entities             []MessageEntity `tl:"flag:3"`
	ScheduleDate         int32           `tl:"flag:15"`
	QuickReplyShortcutID int32           `tl:"flag:17"`
}

func (*MessagesEditMessageParams) CRC() uint32 {
	return 0xdfd14005
}

func (*MessagesEditMessageParams) FlagIndex() int {
	return 0
}

// Edit message
func (c *Client) MessagesEditMessage(params *MessagesEditMessageParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesEditMessage")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesEditQuickReplyShortcutParams struct {
	ShortcutID int32
	Shortcut   string
}

func (*MessagesEditQuickReplyShortcutParams) CRC() uint32 {
	return 0x5c003cef
}

/*
Rename a quick reply shortcut.<br>
This will emit an updateQuickReplies update to other logged-in sessions.
*/
func (c *Client) MessagesEditQuickReplyShortcut(shortcutID int32, shortcut string) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesEditQuickReplyShortcutParams{
		Shortcut:   shortcut,
		ShortcutID: shortcutID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesEditQuickReplyShortcut")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesExportChatInviteParams struct {
	LegacyRevokePermanent bool `tl:"flag:2,encoded_in_bitflags"`
	RequestNeeded         bool `tl:"flag:3,encoded_in_bitflags"`
	Peer                  InputPeer
	ExpireDate            int32                     `tl:"flag:0"`
	UsageLimit            int32                     `tl:"flag:1"`
	Title                 string                    `tl:"flag:4"`
	SubscriptionPricing   *StarsSubscriptionPricing `tl:"flag:5"`
}

func (*MessagesExportChatInviteParams) CRC() uint32 {
	return 0xa455de90
}

func (*MessagesExportChatInviteParams) FlagIndex() int {
	return 0
}

// Export an invite link for a chat
func (c *Client) MessagesExportChatInvite(params *MessagesExportChatInviteParams) (ExportedChatInvite, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesExportChatInvite")
	}

	resp, ok := responseData.(ExportedChatInvite)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesFaveStickerParams struct {
	ID     InputDocument
	Unfave bool
}

func (*MessagesFaveStickerParams) CRC() uint32 {
	return 0xb9ffc55b
}

// Mark or unmark a sticker as favorite
func (c *Client) MessagesFaveSticker(id InputDocument, unfave bool) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesFaveStickerParams{
		ID:     id,
		Unfave: unfave,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesFaveSticker")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesForwardMessageParams struct {
	Peer     InputPeer
	ID       int32
	RandomID int64
}

func (*MessagesForwardMessageParams) CRC() uint32 {
	return 0x33963bf9
}

// Forwards single messages.
func (c *Client) MessagesForwardMessage(peer InputPeer, id int32, randomID int64) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesForwardMessageParams{
		ID:       id,
		Peer:     peer,
		RandomID: randomID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesForwardMessage")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesForwardMessagesParams struct {
	Silent             bool `tl:"flag:5,encoded_in_bitflags"`
	Background         bool `tl:"flag:6,encoded_in_bitflags"`
	WithMyScore        bool `tl:"flag:8,encoded_in_bitflags"`
	DropAuthor         bool `tl:"flag:11,encoded_in_bitflags"`
	DropMediaCaptions  bool `tl:"flag:12,encoded_in_bitflags"`
	Noforwards         bool `tl:"flag:14,encoded_in_bitflags"`
	AllowPaidFloodskip bool `tl:"flag:19,encoded_in_bitflags"`
	FromPeer           InputPeer
	ID                 []int32
	RandomID           []int64
	ToPeer             InputPeer
	TopMsgID           int32                   `tl:"flag:9"`
	ScheduleDate       int32                   `tl:"flag:10"`
	SendAs             InputPeer               `tl:"flag:13"`
	QuickReplyShortcut InputQuickReplyShortcut `tl:"flag:17"`
	VideoTimestamp     int32                   `tl:"flag:20"`
}

func (*MessagesForwardMessagesParams) CRC() uint32 {
	return 0x6d74da08
}

func (*MessagesForwardMessagesParams) FlagIndex() int {
	return 0
}

// Forwards messages by their IDs.
func (c *Client) MessagesForwardMessages(params *MessagesForwardMessagesParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesForwardMessages")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetAdminsWithInvitesParams struct {
	Peer InputPeer
}

func (*MessagesGetAdminsWithInvitesParams) CRC() uint32 {
	return 0x3920e6ef
}

// Get info about chat invites generated by admins.
func (c *Client) MessagesGetAdminsWithInvites(peer InputPeer) (*MessagesChatAdminsWithInvites, error) {
	responseData, err := c.MakeRequest(&MessagesGetAdminsWithInvitesParams{Peer: peer})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetAdminsWithInvites")
	}

	resp, ok := responseData.(*MessagesChatAdminsWithInvites)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetAllChatsParams struct {
	ExceptIds []int64
}

func (*MessagesGetAllChatsParams) CRC() uint32 {
	return 0x875f74be
}

// Get all chats, channels and supergroups
func (c *Client) MessagesGetAllChats(exceptIds []int64) (MessagesChats, error) {
	responseData, err := c.MakeRequest(&MessagesGetAllChatsParams{ExceptIds: exceptIds})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetAllChats")
	}

	resp, ok := responseData.(MessagesChats)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetAllDraftsParams struct{}

func (*MessagesGetAllDraftsParams) CRC() uint32 {
	return 0x6a3f8d65
}

/*
Return all message drafts.<br>
Returns all the latest updateDraftMessage updates related to all chats with drafts.
*/
func (c *Client) MessagesGetAllDrafts() (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesGetAllDraftsParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetAllDrafts")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetAllStickersParams struct {
	Hash int64
}

func (*MessagesGetAllStickersParams) CRC() uint32 {
	return 0xb8a0a1a8
}

// Get all installed stickers
func (c *Client) MessagesGetAllStickers(hash int64) (MessagesAllStickers, error) {
	responseData, err := c.MakeRequest(&MessagesGetAllStickersParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetAllStickers")
	}

	resp, ok := responseData.(MessagesAllStickers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetArchivedStickersParams struct {
	Masks    bool `tl:"flag:0,encoded_in_bitflags"`
	Emojis   bool `tl:"flag:1,encoded_in_bitflags"`
	OffsetID int64
	Limit    int32
}

func (*MessagesGetArchivedStickersParams) CRC() uint32 {
	return 0x57f17692
}

func (*MessagesGetArchivedStickersParams) FlagIndex() int {
	return 0
}

// Get all archived stickers
func (c *Client) MessagesGetArchivedStickers(masks, emojis bool, offsetID int64, limit int32) (*MessagesArchivedStickers, error) {
	responseData, err := c.MakeRequest(&MessagesGetArchivedStickersParams{
		Emojis:   emojis,
		Limit:    limit,
		Masks:    masks,
		OffsetID: offsetID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetArchivedStickers")
	}

	resp, ok := responseData.(*MessagesArchivedStickers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetAttachMenuBotParams struct {
	Bot InputUser
}

func (*MessagesGetAttachMenuBotParams) CRC() uint32 {
	return 0x77216192
}

// Returns attachment menu entry for a bot mini app that can be launched from the attachment menu »
func (c *Client) MessagesGetAttachMenuBot(bot InputUser) (*AttachMenuBotsBot, error) {
	responseData, err := c.MakeRequest(&MessagesGetAttachMenuBotParams{Bot: bot})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetAttachMenuBot")
	}

	resp, ok := responseData.(*AttachMenuBotsBot)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetAttachMenuBotsParams struct {
	Hash int64
}

func (*MessagesGetAttachMenuBotsParams) CRC() uint32 {
	return 0x16fcc2cb
}

// Returns installed attachment menu bot mini apps »
func (c *Client) MessagesGetAttachMenuBots(hash int64) (AttachMenuBots, error) {
	responseData, err := c.MakeRequest(&MessagesGetAttachMenuBotsParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetAttachMenuBots")
	}

	resp, ok := responseData.(AttachMenuBots)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetAttachedStickersParams struct {
	Media InputStickeredMedia
}

func (*MessagesGetAttachedStickersParams) CRC() uint32 {
	return 0xcc5b67cc
}

// Get stickers attached to a photo or video
func (c *Client) MessagesGetAttachedStickers(media InputStickeredMedia) ([]StickerSetCovered, error) {
	responseData, err := c.MakeRequest(&MessagesGetAttachedStickersParams{Media: media})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetAttachedStickers")
	}

	resp, ok := responseData.([]StickerSetCovered)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetAvailableEffectsParams struct {
	Hash int32
}

func (*MessagesGetAvailableEffectsParams) CRC() uint32 {
	return 0xdea20a39
}

// Fetch the full list of usable animated message effects ».
func (c *Client) MessagesGetAvailableEffects(hash int32) (MessagesAvailableEffects, error) {
	responseData, err := c.MakeRequest(&MessagesGetAvailableEffectsParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetAvailableEffects")
	}

	resp, ok := responseData.(MessagesAvailableEffects)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetAvailableReactionsParams struct {
	Hash int32
}

func (*MessagesGetAvailableReactionsParams) CRC() uint32 {
	return 0x18dea0ac
}

// Obtain available message reactions »
func (c *Client) MessagesGetAvailableReactions(hash int32) (MessagesAvailableReactions, error) {
	responseData, err := c.MakeRequest(&MessagesGetAvailableReactionsParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetAvailableReactions")
	}

	resp, ok := responseData.(MessagesAvailableReactions)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetBotAppParams struct {
	App  InputBotApp
	Hash int64
}

func (*MessagesGetBotAppParams) CRC() uint32 {
	return 0x34fdc5c3
}

// Obtain information about a direct link Mini App
func (c *Client) MessagesGetBotApp(app InputBotApp, hash int64) (*MessagesBotApp, error) {
	responseData, err := c.MakeRequest(&MessagesGetBotAppParams{
		App:  app,
		Hash: hash,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetBotApp")
	}

	resp, ok := responseData.(*MessagesBotApp)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetBotCallbackAnswerParams struct {
	Game     bool `tl:"flag:1,encoded_in_bitflags"`
	Peer     InputPeer
	MsgID    int32
	Data     []byte                `tl:"flag:0"`
	Password InputCheckPasswordSRP `tl:"flag:2"`
}

func (*MessagesGetBotCallbackAnswerParams) CRC() uint32 {
	return 0x9342ca07
}

func (*MessagesGetBotCallbackAnswerParams) FlagIndex() int {
	return 0
}

// Press an inline callback button and get a callback answer from the bot
func (c *Client) MessagesGetBotCallbackAnswer(params *MessagesGetBotCallbackAnswerParams) (*MessagesBotCallbackAnswer, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetBotCallbackAnswer")
	}

	resp, ok := responseData.(*MessagesBotCallbackAnswer)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetChatInviteImportersParams struct {
	Requested           bool `tl:"flag:0,encoded_in_bitflags"`
	SubscriptionExpired bool `tl:"flag:3,encoded_in_bitflags"`
	Peer                InputPeer
	Link                string `tl:"flag:1"`
	Q                   string `tl:"flag:2"`
	OffsetDate          int32
	OffsetUser          InputUser
	Limit               int32
}

func (*MessagesGetChatInviteImportersParams) CRC() uint32 {
	return 0xdf04dd4e
}

func (*MessagesGetChatInviteImportersParams) FlagIndex() int {
	return 0
}

// Get info about the users that joined the chat using a specific chat invite
func (c *Client) MessagesGetChatInviteImporters(params *MessagesGetChatInviteImportersParams) (*MessagesChatInviteImporters, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetChatInviteImporters")
	}

	resp, ok := responseData.(*MessagesChatInviteImporters)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetChatsParams struct {
	ID []int64
}

func (*MessagesGetChatsParams) CRC() uint32 {
	return 0x49e9528f
}

// Returns chat basic info on their IDs.
func (c *Client) MessagesGetChats(id []int64) (MessagesChats, error) {
	responseData, err := c.MakeRequest(&MessagesGetChatsParams{ID: id})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetChats")
	}

	resp, ok := responseData.(MessagesChats)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetCommonChatsParams struct {
	UserID InputUser
	MaxID  int64
	Limit  int32
}

func (*MessagesGetCommonChatsParams) CRC() uint32 {
	return 0xe40ca104
}

// Get chats in common with a user
func (c *Client) MessagesGetCommonChats(userID InputUser, maxID int64, limit int32) (MessagesChats, error) {
	responseData, err := c.MakeRequest(&MessagesGetCommonChatsParams{
		Limit:  limit,
		MaxID:  maxID,
		UserID: userID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetCommonChats")
	}

	resp, ok := responseData.(MessagesChats)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetCustomEmojiDocumentsParams struct {
	DocumentID []int64
}

func (*MessagesGetCustomEmojiDocumentsParams) CRC() uint32 {
	return 0xd9ab0f54
}

// Fetch custom emoji stickers ».
func (c *Client) MessagesGetCustomEmojiDocuments(documentID []int64) ([]Document, error) {
	responseData, err := c.MakeRequest(&MessagesGetCustomEmojiDocumentsParams{DocumentID: documentID})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetCustomEmojiDocuments")
	}

	resp, ok := responseData.([]Document)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetDefaultHistoryTtlParams struct{}

func (*MessagesGetDefaultHistoryTtlParams) CRC() uint32 {
	return 0x658b7188
}

// Gets the default value of the Time-To-Live setting, applied to all new chats.
func (c *Client) MessagesGetDefaultHistoryTtl() (*DefaultHistoryTtl, error) {
	responseData, err := c.MakeRequest(&MessagesGetDefaultHistoryTtlParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetDefaultHistoryTtl")
	}

	resp, ok := responseData.(*DefaultHistoryTtl)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetDefaultTagReactionsParams struct {
	Hash int64
}

func (*MessagesGetDefaultTagReactionsParams) CRC() uint32 {
	return 0xbdf93428
}

// Fetch a default recommended list of saved message tag reactions.
func (c *Client) MessagesGetDefaultTagReactions(hash int64) (MessagesReactions, error) {
	responseData, err := c.MakeRequest(&MessagesGetDefaultTagReactionsParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetDefaultTagReactions")
	}

	resp, ok := responseData.(MessagesReactions)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetDhConfigParams struct {
	Version      int32
	RandomLength int32
}

func (*MessagesGetDhConfigParams) CRC() uint32 {
	return 0x26cf8950
}

// Returns configuration parameters for Diffie-Hellman key generation. Can also return a random sequence of bytes of required length.
func (c *Client) MessagesGetDhConfig(version, randomLength int32) (MessagesDhConfig, error) {
	responseData, err := c.MakeRequest(&MessagesGetDhConfigParams{
		RandomLength: randomLength,
		Version:      version,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetDhConfig")
	}

	resp, ok := responseData.(MessagesDhConfig)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetDialogFiltersParams struct{}

func (*MessagesGetDialogFiltersParams) CRC() uint32 {
	return 0xefd48c89
}

// Get folders
func (c *Client) MessagesGetDialogFilters() (*MessagesDialogFilters, error) {
	responseData, err := c.MakeRequest(&MessagesGetDialogFiltersParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetDialogFilters")
	}

	resp, ok := responseData.(*MessagesDialogFilters)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetDialogUnreadMarksParams struct{}

func (*MessagesGetDialogUnreadMarksParams) CRC() uint32 {
	return 0x22e24e22
}

// Get dialogs manually marked as unread
func (c *Client) MessagesGetDialogUnreadMarks() ([]DialogPeer, error) {
	responseData, err := c.MakeRequest(&MessagesGetDialogUnreadMarksParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetDialogUnreadMarks")
	}

	resp, ok := responseData.([]DialogPeer)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetDialogsParams struct {
	ExcludePinned bool  `tl:"flag:0,encoded_in_bitflags"`
	FolderID      int32 `tl:"flag:1"`
	OffsetDate    int32
	OffsetID      int32
	OffsetPeer    InputPeer
	Limit         int32
	Hash          int64
}

func (*MessagesGetDialogsParams) CRC() uint32 {
	return 0xa0f4cb4f
}

func (*MessagesGetDialogsParams) FlagIndex() int {
	return 0
}

// Returns the current user dialog list.
func (c *Client) MessagesGetDialogs(params *MessagesGetDialogsParams) (MessagesDialogs, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetDialogs")
	}

	resp, ok := responseData.(MessagesDialogs)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetDiscussionMessageParams struct {
	Peer  InputPeer
	MsgID int32
}

func (*MessagesGetDiscussionMessageParams) CRC() uint32 {
	return 0x446972fd
}

// Get discussion message from the associated discussion group of a channel to show it on top of the comment section, without actually joining the group
func (c *Client) MessagesGetDiscussionMessage(peer InputPeer, msgID int32) (*MessagesDiscussionMessage, error) {
	responseData, err := c.MakeRequest(&MessagesGetDiscussionMessageParams{
		MsgID: msgID,
		Peer:  peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetDiscussionMessage")
	}

	resp, ok := responseData.(*MessagesDiscussionMessage)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetDocumentByHashParams struct {
	SHA256   []byte
	Size     int64
	MimeType string
}

func (*MessagesGetDocumentByHashParams) CRC() uint32 {
	return 0xb1f2061f
}

// Get a document by its SHA256 hash, mainly used for gifs
func (c *Client) MessagesGetDocumentByHash(sha256 []byte, size int64, mimeType string) (Document, error) {
	responseData, err := c.MakeRequest(&MessagesGetDocumentByHashParams{
		MimeType: mimeType,
		SHA256:   sha256,
		Size:     size,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetDocumentByHash")
	}

	resp, ok := responseData.(Document)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetEmojiGroupsParams struct {
	Hash int32
}

func (*MessagesGetEmojiGroupsParams) CRC() uint32 {
	return 0x7488ce5b
}

// Represents a list of emoji categories.
func (c *Client) MessagesGetEmojiGroups(hash int32) (MessagesEmojiGroups, error) {
	responseData, err := c.MakeRequest(&MessagesGetEmojiGroupsParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetEmojiGroups")
	}

	resp, ok := responseData.(MessagesEmojiGroups)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetEmojiKeywordsParams struct {
	LangCode string
}

func (*MessagesGetEmojiKeywordsParams) CRC() uint32 {
	return 0x35a0e062
}

// Get localized emoji keywords ».
func (c *Client) MessagesGetEmojiKeywords(langCode string) (*EmojiKeywordsDifference, error) {
	responseData, err := c.MakeRequest(&MessagesGetEmojiKeywordsParams{LangCode: langCode})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetEmojiKeywords")
	}

	resp, ok := responseData.(*EmojiKeywordsDifference)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetEmojiKeywordsDifferenceParams struct {
	LangCode    string
	FromVersion int32
}

func (*MessagesGetEmojiKeywordsDifferenceParams) CRC() uint32 {
	return 0x1508b6af
}

// Get changed emoji keywords ».
func (c *Client) MessagesGetEmojiKeywordsDifference(langCode string, fromVersion int32) (*EmojiKeywordsDifference, error) {
	responseData, err := c.MakeRequest(&MessagesGetEmojiKeywordsDifferenceParams{
		FromVersion: fromVersion,
		LangCode:    langCode,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetEmojiKeywordsDifference")
	}

	resp, ok := responseData.(*EmojiKeywordsDifference)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetEmojiKeywordsLanguagesParams struct {
	LangCodes []string
}

func (*MessagesGetEmojiKeywordsLanguagesParams) CRC() uint32 {
	return 0x4e9963b2
}

// Obtain a list of related languages that must be used when fetching emoji keyword lists ».
func (c *Client) MessagesGetEmojiKeywordsLanguages(langCodes []string) ([]*EmojiLanguage, error) {
	responseData, err := c.MakeRequest(&MessagesGetEmojiKeywordsLanguagesParams{LangCodes: langCodes})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetEmojiKeywordsLanguages")
	}

	resp, ok := responseData.([]*EmojiLanguage)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetEmojiProfilePhotoGroupsParams struct {
	Hash int32
}

func (*MessagesGetEmojiProfilePhotoGroupsParams) CRC() uint32 {
	return 0x21a548f3
}

// Represents a list of emoji categories, to be used when selecting custom emojis to set as profile picture.
func (c *Client) MessagesGetEmojiProfilePhotoGroups(hash int32) (MessagesEmojiGroups, error) {
	responseData, err := c.MakeRequest(&MessagesGetEmojiProfilePhotoGroupsParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetEmojiProfilePhotoGroups")
	}

	resp, ok := responseData.(MessagesEmojiGroups)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetEmojiStatusGroupsParams struct {
	Hash int32
}

func (*MessagesGetEmojiStatusGroupsParams) CRC() uint32 {
	return 0x2ecd56cd
}

// Represents a list of emoji categories, to be used when selecting custom emojis to set as custom emoji status.
func (c *Client) MessagesGetEmojiStatusGroups(hash int32) (MessagesEmojiGroups, error) {
	responseData, err := c.MakeRequest(&MessagesGetEmojiStatusGroupsParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetEmojiStatusGroups")
	}

	resp, ok := responseData.(MessagesEmojiGroups)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetEmojiStickerGroupsParams struct {
	Hash int32
}

func (*MessagesGetEmojiStickerGroupsParams) CRC() uint32 {
	return 0x1dd840f5
}

// Represents a list of emoji categories, to be used when choosing a sticker.
func (c *Client) MessagesGetEmojiStickerGroups(hash int32) (MessagesEmojiGroups, error) {
	responseData, err := c.MakeRequest(&MessagesGetEmojiStickerGroupsParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetEmojiStickerGroups")
	}

	resp, ok := responseData.(MessagesEmojiGroups)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetEmojiStickersParams struct {
	Hash int64
}

func (*MessagesGetEmojiStickersParams) CRC() uint32 {
	return 0xfbfca18f
}

// Gets the list of currently installed custom emoji stickersets.
func (c *Client) MessagesGetEmojiStickers(hash int64) (MessagesAllStickers, error) {
	responseData, err := c.MakeRequest(&MessagesGetEmojiStickersParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetEmojiStickers")
	}

	resp, ok := responseData.(MessagesAllStickers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetEmojiURLParams struct {
	LangCode string
}

func (*MessagesGetEmojiURLParams) CRC() uint32 {
	return 0xd5b10c26
}

// Returns an HTTP URL which can be used to automatically log in into translation platform and suggest new emoji keywords ». The URL will be valid for 30 seconds after generation.
func (c *Client) MessagesGetEmojiURL(langCode string) (*EmojiURL, error) {
	responseData, err := c.MakeRequest(&MessagesGetEmojiURLParams{LangCode: langCode})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetEmojiURL")
	}

	resp, ok := responseData.(*EmojiURL)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetExportedChatInviteParams struct {
	Peer InputPeer
	Link string
}

func (*MessagesGetExportedChatInviteParams) CRC() uint32 {
	return 0x73746f5c
}

// Get info about a chat invite
func (c *Client) MessagesGetExportedChatInvite(peer InputPeer, link string) (MessagesExportedChatInvite, error) {
	responseData, err := c.MakeRequest(&MessagesGetExportedChatInviteParams{
		Link: link,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetExportedChatInvite")
	}

	resp, ok := responseData.(MessagesExportedChatInvite)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetExportedChatInvitesParams struct {
	Revoked    bool `tl:"flag:3,encoded_in_bitflags"`
	Peer       InputPeer
	AdminID    InputUser
	OffsetDate int32  `tl:"flag:2"`
	OffsetLink string `tl:"flag:2"`
	Limit      int32
}

func (*MessagesGetExportedChatInvitesParams) CRC() uint32 {
	return 0xa2b5a3f6
}

func (*MessagesGetExportedChatInvitesParams) FlagIndex() int {
	return 0
}

// Get info about the chat invites of a specific chat
func (c *Client) MessagesGetExportedChatInvites(params *MessagesGetExportedChatInvitesParams) (*MessagesExportedChatInvites, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetExportedChatInvites")
	}

	resp, ok := responseData.(*MessagesExportedChatInvites)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetExtendedMediaParams struct {
	Peer InputPeer
	ID   []int32
}

func (*MessagesGetExtendedMediaParams) CRC() uint32 {
	return 0x84f80814
}

// Fetch updated information about paid media, see here » for the full flow.
func (c *Client) MessagesGetExtendedMedia(peer InputPeer, id []int32) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesGetExtendedMediaParams{
		ID:   id,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetExtendedMedia")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetFactCheckParams struct {
	Peer  InputPeer
	MsgID []int32
}

func (*MessagesGetFactCheckParams) CRC() uint32 {
	return 0xb9cdc5ee
}

// Fetch one or more factchecks, see here » for the full flow.
func (c *Client) MessagesGetFactCheck(peer InputPeer, msgID []int32) ([]*FactCheck, error) {
	responseData, err := c.MakeRequest(&MessagesGetFactCheckParams{
		MsgID: msgID,
		Peer:  peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetFactCheck")
	}

	resp, ok := responseData.([]*FactCheck)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetFavedStickersParams struct {
	Hash int64
}

func (*MessagesGetFavedStickersParams) CRC() uint32 {
	return 0x4f1aaa9
}

// Get faved stickers
func (c *Client) MessagesGetFavedStickers(hash int64) (MessagesFavedStickers, error) {
	responseData, err := c.MakeRequest(&MessagesGetFavedStickersParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetFavedStickers")
	}

	resp, ok := responseData.(MessagesFavedStickers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetFeaturedEmojiStickersParams struct {
	Hash int64
}

func (*MessagesGetFeaturedEmojiStickersParams) CRC() uint32 {
	return 0xecf6736
}

// Gets featured custom emoji stickersets.
func (c *Client) MessagesGetFeaturedEmojiStickers(hash int64) (MessagesFeaturedStickers, error) {
	responseData, err := c.MakeRequest(&MessagesGetFeaturedEmojiStickersParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetFeaturedEmojiStickers")
	}

	resp, ok := responseData.(MessagesFeaturedStickers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetFeaturedStickersParams struct {
	Hash int64
}

func (*MessagesGetFeaturedStickersParams) CRC() uint32 {
	return 0x64780b14
}

// Get featured stickers
func (c *Client) MessagesGetFeaturedStickers(hash int64) (MessagesFeaturedStickers, error) {
	responseData, err := c.MakeRequest(&MessagesGetFeaturedStickersParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetFeaturedStickers")
	}

	resp, ok := responseData.(MessagesFeaturedStickers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetFullChatParams struct {
	ChatID int64
}

func (*MessagesGetFullChatParams) CRC() uint32 {
	return 0xaeb00b34
}

// Get full info about a basic group.
func (c *Client) MessagesGetFullChat(chatID int64) (*MessagesChatFull, error) {
	responseData, err := c.MakeRequest(&MessagesGetFullChatParams{ChatID: chatID})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetFullChat")
	}

	resp, ok := responseData.(*MessagesChatFull)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetGameHighScoresParams struct {
	Peer   InputPeer
	ID     int32
	UserID InputUser
}

func (*MessagesGetGameHighScoresParams) CRC() uint32 {
	return 0xe822649d
}

// Get highscores of a game
func (c *Client) MessagesGetGameHighScores(peer InputPeer, id int32, userID InputUser) (*MessagesHighScores, error) {
	responseData, err := c.MakeRequest(&MessagesGetGameHighScoresParams{
		ID:     id,
		Peer:   peer,
		UserID: userID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetGameHighScores")
	}

	resp, ok := responseData.(*MessagesHighScores)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetHistoryParams struct {
	Peer       InputPeer
	OffsetID   int32
	OffsetDate int32
	AddOffset  int32
	Limit      int32
	MaxID      int32
	MinID      int32
	Hash       int64
}

func (*MessagesGetHistoryParams) CRC() uint32 {
	return 0x4423e6c5
}

// Returns the conversation history with one interlocutor / within a chat
func (c *Client) MessagesGetHistory(params *MessagesGetHistoryParams) (MessagesMessages, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetHistory")
	}

	resp, ok := responseData.(MessagesMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetInlineBotResultsParams struct {
	Bot      InputUser
	Peer     InputPeer
	GeoPoint InputGeoPoint `tl:"flag:0"`
	Query    string
	Offset   string
}

func (*MessagesGetInlineBotResultsParams) CRC() uint32 {
	return 0x514e999d
}

func (*MessagesGetInlineBotResultsParams) FlagIndex() int {
	return 0
}

// Query an inline bot
func (c *Client) MessagesGetInlineBotResults(params *MessagesGetInlineBotResultsParams) (*MessagesBotResults, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetInlineBotResults")
	}

	resp, ok := responseData.(*MessagesBotResults)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetInlineGameHighScoresParams struct {
	ID     InputBotInlineMessageID
	UserID InputUser
}

func (*MessagesGetInlineGameHighScoresParams) CRC() uint32 {
	return 0xf635e1b
}

// Get highscores of a game sent using an inline bot
func (c *Client) MessagesGetInlineGameHighScores(id InputBotInlineMessageID, userID InputUser) (*MessagesHighScores, error) {
	responseData, err := c.MakeRequest(&MessagesGetInlineGameHighScoresParams{
		ID:     id,
		UserID: userID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetInlineGameHighScores")
	}

	resp, ok := responseData.(*MessagesHighScores)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetMaskStickersParams struct {
	Hash int64
}

func (*MessagesGetMaskStickersParams) CRC() uint32 {
	return 0x640f82b8
}

// Get installed mask stickers
func (c *Client) MessagesGetMaskStickers(hash int64) (MessagesAllStickers, error) {
	responseData, err := c.MakeRequest(&MessagesGetMaskStickersParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetMaskStickers")
	}

	resp, ok := responseData.(MessagesAllStickers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetMessageEditDataParams struct {
	Peer InputPeer
	ID   int32
}

func (*MessagesGetMessageEditDataParams) CRC() uint32 {
	return 0xfda68d36
}

// Find out if a media message's caption can be edited
func (c *Client) MessagesGetMessageEditData(peer InputPeer, id int32) (*MessagesMessageEditData, error) {
	responseData, err := c.MakeRequest(&MessagesGetMessageEditDataParams{
		ID:   id,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetMessageEditData")
	}

	resp, ok := responseData.(*MessagesMessageEditData)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetMessageReactionsListParams struct {
	Peer     InputPeer
	ID       int32
	Reaction Reaction `tl:"flag:0"`
	Offset   string   `tl:"flag:1"`
	Limit    int32
}

func (*MessagesGetMessageReactionsListParams) CRC() uint32 {
	return 0x461b3f48
}

func (*MessagesGetMessageReactionsListParams) FlagIndex() int {
	return 0
}

// Get message reaction list, along with the sender of each reaction.
func (c *Client) MessagesGetMessageReactionsList(params *MessagesGetMessageReactionsListParams) (*MessagesMessageReactionsList, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetMessageReactionsList")
	}

	resp, ok := responseData.(*MessagesMessageReactionsList)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetMessageReadParticipantsParams struct {
	Peer  InputPeer
	MsgID int32
}

func (*MessagesGetMessageReadParticipantsParams) CRC() uint32 {
	return 0x31c1c44f
}

// Get which users read a specific message: only available for groups and supergroups with less than <a href="/api/config#chat-read-mark-size-threshold">`chat_read_mark_size_threshold` members</a>, read receipts will be stored for <a href="/api/config#chat-read-mark-expire-period">`chat_read_mark_expire_period` seconds after the message was sent</a>, see client configuration for more info ».
func (c *Client) MessagesGetMessageReadParticipants(peer InputPeer, msgID int32) ([]*ReadParticipantDate, error) {
	responseData, err := c.MakeRequest(&MessagesGetMessageReadParticipantsParams{
		MsgID: msgID,
		Peer:  peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetMessageReadParticipants")
	}

	resp, ok := responseData.([]*ReadParticipantDate)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetMessagesParams struct {
	ID []InputMessage
}

func (*MessagesGetMessagesParams) CRC() uint32 {
	return 0x63c66506
}

// Returns the list of messages by their IDs.
func (c *Client) MessagesGetMessages(id []InputMessage) (MessagesMessages, error) {
	responseData, err := c.MakeRequest(&MessagesGetMessagesParams{ID: id})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetMessages")
	}

	resp, ok := responseData.(MessagesMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetMessagesReactionsParams struct {
	Peer InputPeer
	ID   []int32
}

func (*MessagesGetMessagesReactionsParams) CRC() uint32 {
	return 0x8bba90e6
}

// Get message reactions »
func (c *Client) MessagesGetMessagesReactions(peer InputPeer, id []int32) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesGetMessagesReactionsParams{
		ID:   id,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetMessagesReactions")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetMessagesViewsParams struct {
	Peer      InputPeer
	ID        []int32
	Increment bool
}

func (*MessagesGetMessagesViewsParams) CRC() uint32 {
	return 0x5784d3e1
}

// Get and increase the view counter of a message sent or forwarded from a channel
func (c *Client) MessagesGetMessagesViews(peer InputPeer, id []int32, increment bool) (*MessagesMessageViews, error) {
	responseData, err := c.MakeRequest(&MessagesGetMessagesViewsParams{
		ID:        id,
		Increment: increment,
		Peer:      peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetMessagesViews")
	}

	resp, ok := responseData.(*MessagesMessageViews)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetMyStickersParams struct {
	OffsetID int64
	Limit    int32
}

func (*MessagesGetMyStickersParams) CRC() uint32 {
	return 0xd0b5e1fc
}

// Fetch all stickersets » owned by the current user.
func (c *Client) MessagesGetMyStickers(offsetID int64, limit int32) (*MessagesMyStickers, error) {
	responseData, err := c.MakeRequest(&MessagesGetMyStickersParams{
		Limit:    limit,
		OffsetID: offsetID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetMyStickers")
	}

	resp, ok := responseData.(*MessagesMyStickers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetOldFeaturedStickersParams struct {
	Offset int32
	Limit  int32
	Hash   int64
}

func (*MessagesGetOldFeaturedStickersParams) CRC() uint32 {
	return 0x7ed094a1
}

// Method for fetching previously featured stickers
func (c *Client) MessagesGetOldFeaturedStickers(offset, limit int32, hash int64) (MessagesFeaturedStickers, error) {
	responseData, err := c.MakeRequest(&MessagesGetOldFeaturedStickersParams{
		Hash:   hash,
		Limit:  limit,
		Offset: offset,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetOldFeaturedStickers")
	}

	resp, ok := responseData.(MessagesFeaturedStickers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetOnlinesParams struct {
	Peer InputPeer
}

func (*MessagesGetOnlinesParams) CRC() uint32 {
	return 0x6e2be050
}

// Get count of online users in a chat
func (c *Client) MessagesGetOnlines(peer InputPeer) (*ChatOnlines, error) {
	responseData, err := c.MakeRequest(&MessagesGetOnlinesParams{Peer: peer})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetOnlines")
	}

	resp, ok := responseData.(*ChatOnlines)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetOutboxReadDateParams struct {
	Peer  InputPeer
	MsgID int32
}

func (*MessagesGetOutboxReadDateParams) CRC() uint32 {
	return 0x8c4bfe5d
}

// Get the exact read date of one of our messages, sent to a private chat with another user.
func (c *Client) MessagesGetOutboxReadDate(peer InputPeer, msgID int32) (*OutboxReadDate, error) {
	responseData, err := c.MakeRequest(&MessagesGetOutboxReadDateParams{
		MsgID: msgID,
		Peer:  peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetOutboxReadDate")
	}

	resp, ok := responseData.(*OutboxReadDate)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetPaidReactionPrivacyParams struct{}

func (*MessagesGetPaidReactionPrivacyParams) CRC() uint32 {
	return 0x472455aa
}

// Fetches an updatePaidReactionPrivacy update with the current default paid reaction privacy, see here » for more info.
func (c *Client) MessagesGetPaidReactionPrivacy() (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesGetPaidReactionPrivacyParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetPaidReactionPrivacy")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetPeerDialogsParams struct {
	Peers []InputDialogPeer
}

func (*MessagesGetPeerDialogsParams) CRC() uint32 {
	return 0xe470bcfd
}

// Get dialog info of specified peers
func (c *Client) MessagesGetPeerDialogs(peers []InputDialogPeer) (*MessagesPeerDialogs, error) {
	responseData, err := c.MakeRequest(&MessagesGetPeerDialogsParams{Peers: peers})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetPeerDialogs")
	}

	resp, ok := responseData.(*MessagesPeerDialogs)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetPeerSettingsParams struct {
	Peer InputPeer
}

func (*MessagesGetPeerSettingsParams) CRC() uint32 {
	return 0xefd9a6a2
}

// Get peer settings
func (c *Client) MessagesGetPeerSettings(peer InputPeer) (*MessagesPeerSettings, error) {
	responseData, err := c.MakeRequest(&MessagesGetPeerSettingsParams{Peer: peer})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetPeerSettings")
	}

	resp, ok := responseData.(*MessagesPeerSettings)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetPinnedDialogsParams struct {
	FolderID int32
}

func (*MessagesGetPinnedDialogsParams) CRC() uint32 {
	return 0xd6b94df2
}

// Get pinned dialogs
func (c *Client) MessagesGetPinnedDialogs(folderID int32) (*MessagesPeerDialogs, error) {
	responseData, err := c.MakeRequest(&MessagesGetPinnedDialogsParams{FolderID: folderID})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetPinnedDialogs")
	}

	resp, ok := responseData.(*MessagesPeerDialogs)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetPinnedSavedDialogsParams struct{}

func (*MessagesGetPinnedSavedDialogsParams) CRC() uint32 {
	return 0xd63d94e0
}

// Get pinned saved dialogs, see here » for more info.
func (c *Client) MessagesGetPinnedSavedDialogs() (MessagesSavedDialogs, error) {
	responseData, err := c.MakeRequest(&MessagesGetPinnedSavedDialogsParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetPinnedSavedDialogs")
	}

	resp, ok := responseData.(MessagesSavedDialogs)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetPollResultsParams struct {
	Peer  InputPeer
	MsgID int32
}

func (*MessagesGetPollResultsParams) CRC() uint32 {
	return 0x73bb643b
}

// Get poll results
func (c *Client) MessagesGetPollResults(peer InputPeer, msgID int32) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesGetPollResultsParams{
		MsgID: msgID,
		Peer:  peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetPollResults")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetPollVotesParams struct {
	Peer   InputPeer
	ID     int32
	Option []byte `tl:"flag:0"`
	Offset string `tl:"flag:1"`
	Limit  int32
}

func (*MessagesGetPollVotesParams) CRC() uint32 {
	return 0xb86e380e
}

func (*MessagesGetPollVotesParams) FlagIndex() int {
	return 0
}

// Get poll results for non-anonymous polls
func (c *Client) MessagesGetPollVotes(params *MessagesGetPollVotesParams) (*MessagesVotesList, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetPollVotes")
	}

	resp, ok := responseData.(*MessagesVotesList)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetPreparedInlineMessageParams struct {
	Bot InputUser
	ID  string
}

func (*MessagesGetPreparedInlineMessageParams) CRC() uint32 {
	return 0x857ebdb8
}

// Obtain a prepared inline message generated by a mini app: invoked when handling web_app_send_prepared_message events
func (c *Client) MessagesGetPreparedInlineMessage(bot InputUser, id string) (*MessagesPreparedInlineMessage, error) {
	responseData, err := c.MakeRequest(&MessagesGetPreparedInlineMessageParams{
		Bot: bot,
		ID:  id,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetPreparedInlineMessage")
	}

	resp, ok := responseData.(*MessagesPreparedInlineMessage)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetQuickRepliesParams struct {
	Hash int64
}

func (*MessagesGetQuickRepliesParams) CRC() uint32 {
	return 0xd483f2a8
}

// Fetch basic info about all existing quick reply shortcuts.
func (c *Client) MessagesGetQuickReplies(hash int64) (MessagesQuickReplies, error) {
	responseData, err := c.MakeRequest(&MessagesGetQuickRepliesParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetQuickReplies")
	}

	resp, ok := responseData.(MessagesQuickReplies)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetQuickReplyMessagesParams struct {
	ShortcutID int32
	ID         []int32 `tl:"flag:0"`
	Hash       int64
}

func (*MessagesGetQuickReplyMessagesParams) CRC() uint32 {
	return 0x94a495c3
}

func (*MessagesGetQuickReplyMessagesParams) FlagIndex() int {
	return 0
}

// Fetch (a subset or all) messages in a quick reply shortcut ».
func (c *Client) MessagesGetQuickReplyMessages(shortcutID int32, id []int32, hash int64) (MessagesMessages, error) {
	responseData, err := c.MakeRequest(&MessagesGetQuickReplyMessagesParams{
		Hash:       hash,
		ID:         id,
		ShortcutID: shortcutID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetQuickReplyMessages")
	}

	resp, ok := responseData.(MessagesMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetRecentLocationsParams struct {
	Peer  InputPeer
	Limit int32
	Hash  int64
}

func (*MessagesGetRecentLocationsParams) CRC() uint32 {
	return 0x702a40e0
}

// Get live location history of a certain user
func (c *Client) MessagesGetRecentLocations(peer InputPeer, limit int32, hash int64) (MessagesMessages, error) {
	responseData, err := c.MakeRequest(&MessagesGetRecentLocationsParams{
		Hash:  hash,
		Limit: limit,
		Peer:  peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetRecentLocations")
	}

	resp, ok := responseData.(MessagesMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetRecentReactionsParams struct {
	Limit int32
	Hash  int64
}

func (*MessagesGetRecentReactionsParams) CRC() uint32 {
	return 0x39461db2
}

// Get recently used message reactions
func (c *Client) MessagesGetRecentReactions(limit int32, hash int64) (MessagesReactions, error) {
	responseData, err := c.MakeRequest(&MessagesGetRecentReactionsParams{
		Hash:  hash,
		Limit: limit,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetRecentReactions")
	}

	resp, ok := responseData.(MessagesReactions)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetRecentStickersParams struct {
	Attached bool `tl:"flag:0,encoded_in_bitflags"`
	Hash     int64
}

func (*MessagesGetRecentStickersParams) CRC() uint32 {
	return 0x9da9403b
}

func (*MessagesGetRecentStickersParams) FlagIndex() int {
	return 0
}

// Get recent stickers
func (c *Client) MessagesGetRecentStickers(attached bool, hash int64) (MessagesRecentStickers, error) {
	responseData, err := c.MakeRequest(&MessagesGetRecentStickersParams{
		Attached: attached,
		Hash:     hash,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetRecentStickers")
	}

	resp, ok := responseData.(MessagesRecentStickers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetRepliesParams struct {
	Peer       InputPeer
	MsgID      int32
	OffsetID   int32
	OffsetDate int32
	AddOffset  int32
	Limit      int32
	MaxID      int32
	MinID      int32
	Hash       int64
}

func (*MessagesGetRepliesParams) CRC() uint32 {
	return 0x22ddd30c
}

// Get messages in a reply thread
func (c *Client) MessagesGetReplies(params *MessagesGetRepliesParams) (MessagesMessages, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetReplies")
	}

	resp, ok := responseData.(MessagesMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetSavedDialogsParams struct {
	ExcludePinned bool `tl:"flag:0,encoded_in_bitflags"`
	OffsetDate    int32
	OffsetID      int32
	OffsetPeer    InputPeer
	Limit         int32
	Hash          int64
}

func (*MessagesGetSavedDialogsParams) CRC() uint32 {
	return 0x5381d21a
}

func (*MessagesGetSavedDialogsParams) FlagIndex() int {
	return 0
}

// Returns the current saved dialog list, see here » for more info.
func (c *Client) MessagesGetSavedDialogs(params *MessagesGetSavedDialogsParams) (MessagesSavedDialogs, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetSavedDialogs")
	}

	resp, ok := responseData.(MessagesSavedDialogs)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetSavedGifsParams struct {
	Hash int64
}

func (*MessagesGetSavedGifsParams) CRC() uint32 {
	return 0x5cf09635
}

// Get saved GIFs.
func (c *Client) MessagesGetSavedGifs(hash int64) (MessagesSavedGifs, error) {
	responseData, err := c.MakeRequest(&MessagesGetSavedGifsParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetSavedGifs")
	}

	resp, ok := responseData.(MessagesSavedGifs)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetSavedHistoryParams struct {
	Peer       InputPeer
	OffsetID   int32
	OffsetDate int32
	AddOffset  int32
	Limit      int32
	MaxID      int32
	MinID      int32
	Hash       int64
}

func (*MessagesGetSavedHistoryParams) CRC() uint32 {
	return 0x3d9a414d
}

// Returns saved messages » forwarded from a specific peer
func (c *Client) MessagesGetSavedHistory(params *MessagesGetSavedHistoryParams) (MessagesMessages, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetSavedHistory")
	}

	resp, ok := responseData.(MessagesMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetSavedReactionTagsParams struct {
	Peer InputPeer `tl:"flag:0"`
	Hash int64
}

func (*MessagesGetSavedReactionTagsParams) CRC() uint32 {
	return 0x3637e05b
}

func (*MessagesGetSavedReactionTagsParams) FlagIndex() int {
	return 0
}

// Fetch the full list of saved message tags created by the user.
func (c *Client) MessagesGetSavedReactionTags(peer InputPeer, hash int64) (MessagesSavedReactionTags, error) {
	responseData, err := c.MakeRequest(&MessagesGetSavedReactionTagsParams{
		Hash: hash,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetSavedReactionTags")
	}

	resp, ok := responseData.(MessagesSavedReactionTags)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetScheduledHistoryParams struct {
	Peer InputPeer
	Hash int64
}

func (*MessagesGetScheduledHistoryParams) CRC() uint32 {
	return 0xf516760b
}

// Get scheduled messages
func (c *Client) MessagesGetScheduledHistory(peer InputPeer, hash int64) (MessagesMessages, error) {
	responseData, err := c.MakeRequest(&MessagesGetScheduledHistoryParams{
		Hash: hash,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetScheduledHistory")
	}

	resp, ok := responseData.(MessagesMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetScheduledMessagesParams struct {
	Peer InputPeer
	ID   []int32
}

func (*MessagesGetScheduledMessagesParams) CRC() uint32 {
	return 0xbdbb0464
}

// Get scheduled messages
func (c *Client) MessagesGetScheduledMessages(peer InputPeer, id []int32) (MessagesMessages, error) {
	responseData, err := c.MakeRequest(&MessagesGetScheduledMessagesParams{
		ID:   id,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetScheduledMessages")
	}

	resp, ok := responseData.(MessagesMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetSearchCountersParams struct {
	Peer        InputPeer
	SavedPeerID InputPeer `tl:"flag:2"`
	TopMsgID    int32     `tl:"flag:0"`
	Filters     []MessagesFilter
}

func (*MessagesGetSearchCountersParams) CRC() uint32 {
	return 0x1bbcf300
}

func (*MessagesGetSearchCountersParams) FlagIndex() int {
	return 0
}

// Get the number of results that would be found by a messages.search call with the same parameters
func (c *Client) MessagesGetSearchCounters(peer, savedPeerID InputPeer, topMsgID int32, filters []MessagesFilter) ([]*MessagesSearchCounter, error) {
	responseData, err := c.MakeRequest(&MessagesGetSearchCountersParams{
		Filters:     filters,
		Peer:        peer,
		SavedPeerID: savedPeerID,
		TopMsgID:    topMsgID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetSearchCounters")
	}

	resp, ok := responseData.([]*MessagesSearchCounter)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetSearchResultsCalendarParams struct {
	Peer        InputPeer
	SavedPeerID InputPeer `tl:"flag:2"`
	Filter      MessagesFilter
	OffsetID    int32
	OffsetDate  int32
}

func (*MessagesGetSearchResultsCalendarParams) CRC() uint32 {
	return 0x6aa3f6bd
}

func (*MessagesGetSearchResultsCalendarParams) FlagIndex() int {
	return 0
}

// Returns information about the next messages of the specified type in the chat split by days.
func (c *Client) MessagesGetSearchResultsCalendar(params *MessagesGetSearchResultsCalendarParams) (*MessagesSearchResultsCalendar, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetSearchResultsCalendar")
	}

	resp, ok := responseData.(*MessagesSearchResultsCalendar)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetSearchResultsPositionsParams struct {
	Peer        InputPeer
	SavedPeerID InputPeer `tl:"flag:2"`
	Filter      MessagesFilter
	OffsetID    int32
	Limit       int32
}

func (*MessagesGetSearchResultsPositionsParams) CRC() uint32 {
	return 0x9c7f2f10
}

func (*MessagesGetSearchResultsPositionsParams) FlagIndex() int {
	return 0
}

// Returns sparse positions of messages of the specified type in the chat to be used for shared media scroll implementation.
func (c *Client) MessagesGetSearchResultsPositions(params *MessagesGetSearchResultsPositionsParams) (*MessagesSearchResultsPositions, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetSearchResultsPositions")
	}

	resp, ok := responseData.(*MessagesSearchResultsPositions)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetSplitRangesParams struct{}

func (*MessagesGetSplitRangesParams) CRC() uint32 {
	return 0x1cff7e08
}

// Get message ranges for saving the user's chat history
func (c *Client) MessagesGetSplitRanges() ([]*MessageRange, error) {
	responseData, err := c.MakeRequest(&MessagesGetSplitRangesParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetSplitRanges")
	}

	resp, ok := responseData.([]*MessageRange)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetSponsoredMessagesParams struct {
	Peer InputPeer
}

func (*MessagesGetSponsoredMessagesParams) CRC() uint32 {
	return 0x9bd2f439
}

// Get a list of sponsored messages for a peer, see here » for more info.
func (c *Client) MessagesGetSponsoredMessages(peer InputPeer) (MessagesSponsoredMessages, error) {
	responseData, err := c.MakeRequest(&MessagesGetSponsoredMessagesParams{Peer: peer})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetSponsoredMessages")
	}

	resp, ok := responseData.(MessagesSponsoredMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetStatsURLParams struct {
	Dark   bool `tl:"flag:0,encoded_in_bitflags"`
	Peer   InputPeer
	Params string
}

func (*MessagesGetStatsURLParams) CRC() uint32 {
	return 0x812c2ae6
}

func (*MessagesGetStatsURLParams) FlagIndex() int {
	return 0
}

// Returns URL with the chat statistics. Currently this method can be used only for channels
func (c *Client) MessagesGetStatsURL(dark bool, peer InputPeer, params string) (*StatsURL, error) {
	responseData, err := c.MakeRequest(&MessagesGetStatsURLParams{
		Dark:   dark,
		Params: params,
		Peer:   peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetStatsURL")
	}

	resp, ok := responseData.(*StatsURL)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetStickerSetParams struct {
	Stickerset InputStickerSet
	Hash       int32
}

func (*MessagesGetStickerSetParams) CRC() uint32 {
	return 0xc8a0ec74
}

// Get info about a stickerset
func (c *Client) MessagesGetStickerSet(stickerset InputStickerSet, hash int32) (MessagesStickerSet, error) {
	responseData, err := c.MakeRequest(&MessagesGetStickerSetParams{
		Hash:       hash,
		Stickerset: stickerset,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetStickerSet")
	}

	resp, ok := responseData.(MessagesStickerSet)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetStickersParams struct {
	Emoticon string
	Hash     int64
}

func (*MessagesGetStickersParams) CRC() uint32 {
	return 0xd5a5d3a1
}

// Get stickers by emoji
func (c *Client) MessagesGetStickers(emoticon string, hash int64) (MessagesStickers, error) {
	responseData, err := c.MakeRequest(&MessagesGetStickersParams{
		Emoticon: emoticon,
		Hash:     hash,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetStickers")
	}

	resp, ok := responseData.(MessagesStickers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetSuggestedDialogFiltersParams struct{}

func (*MessagesGetSuggestedDialogFiltersParams) CRC() uint32 {
	return 0xa29cd42c
}

// Get suggested folders
func (c *Client) MessagesGetSuggestedDialogFilters() ([]*DialogFilterSuggested, error) {
	responseData, err := c.MakeRequest(&MessagesGetSuggestedDialogFiltersParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetSuggestedDialogFilters")
	}

	resp, ok := responseData.([]*DialogFilterSuggested)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetTopReactionsParams struct {
	Limit int32
	Hash  int64
}

func (*MessagesGetTopReactionsParams) CRC() uint32 {
	return 0xbb8125ba
}

// Got popular message reactions
func (c *Client) MessagesGetTopReactions(limit int32, hash int64) (MessagesReactions, error) {
	responseData, err := c.MakeRequest(&MessagesGetTopReactionsParams{
		Hash:  hash,
		Limit: limit,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetTopReactions")
	}

	resp, ok := responseData.(MessagesReactions)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetUnreadMentionsParams struct {
	Peer      InputPeer
	TopMsgID  int32 `tl:"flag:0"`
	OffsetID  int32
	AddOffset int32
	Limit     int32
	MaxID     int32
	MinID     int32
}

func (*MessagesGetUnreadMentionsParams) CRC() uint32 {
	return 0xf107e790
}

func (*MessagesGetUnreadMentionsParams) FlagIndex() int {
	return 0
}

// Get unread messages where we were mentioned
func (c *Client) MessagesGetUnreadMentions(params *MessagesGetUnreadMentionsParams) (MessagesMessages, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetUnreadMentions")
	}

	resp, ok := responseData.(MessagesMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetUnreadReactionsParams struct {
	Peer      InputPeer
	TopMsgID  int32 `tl:"flag:0"`
	OffsetID  int32
	AddOffset int32
	Limit     int32
	MaxID     int32
	MinID     int32
}

func (*MessagesGetUnreadReactionsParams) CRC() uint32 {
	return 0x3223495b
}

func (*MessagesGetUnreadReactionsParams) FlagIndex() int {
	return 0
}

// Get unread reactions to messages you sent
func (c *Client) MessagesGetUnreadReactions(params *MessagesGetUnreadReactionsParams) (MessagesMessages, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetUnreadReactions")
	}

	resp, ok := responseData.(MessagesMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetWebPageParams struct {
	URL  string
	Hash int32
}

func (*MessagesGetWebPageParams) CRC() uint32 {
	return 0x8d9692a3
}

// Get instant view page
func (c *Client) MessagesGetWebPage(url string, hash int32) (*MessagesWebPage, error) {
	responseData, err := c.MakeRequest(&MessagesGetWebPageParams{
		Hash: hash,
		URL:  url,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetWebPage")
	}

	resp, ok := responseData.(*MessagesWebPage)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetWebPagePreviewParams struct {
	Message  string
	Entities []MessageEntity `tl:"flag:3"`
}

func (*MessagesGetWebPagePreviewParams) CRC() uint32 {
	return 0x570d6f6f
}

func (*MessagesGetWebPagePreviewParams) FlagIndex() int {
	return 0
}

// Get preview of webpage
func (c *Client) MessagesGetWebPagePreview(message string, entities []MessageEntity) (*MessagesWebPagePreview, error) {
	responseData, err := c.MakeRequest(&MessagesGetWebPagePreviewParams{
		Entities: entities,
		Message:  message,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetWebPagePreview")
	}

	resp, ok := responseData.(*MessagesWebPagePreview)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesGetWebViewResultParams struct {
	Peer    InputPeer
	Bot     InputUser
	QueryID int64
}

func (*MessagesGetWebViewResultParams) CRC() uint32 {
	return 0x22b6c214
}

func (c *Client) MessagesGetWebViewResult(peer InputPeer, bot InputUser, queryID int64) (*MessagesWebViewResult, error) {
	responseData, err := c.MakeRequest(&MessagesGetWebViewResultParams{
		Bot:     bot,
		Peer:    peer,
		QueryID: queryID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesGetWebViewResult")
	}

	resp, ok := responseData.(*MessagesWebViewResult)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesHideAllChatJoinRequestsParams struct {
	Approved bool `tl:"flag:0,encoded_in_bitflags"`
	Peer     InputPeer
	Link     string `tl:"flag:1"`
}

func (*MessagesHideAllChatJoinRequestsParams) CRC() uint32 {
	return 0xe085f4ea
}

func (*MessagesHideAllChatJoinRequestsParams) FlagIndex() int {
	return 0
}

// Dismiss or approve all join requests related to a specific chat or channel.
func (c *Client) MessagesHideAllChatJoinRequests(approved bool, peer InputPeer, link string) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesHideAllChatJoinRequestsParams{
		Approved: approved,
		Link:     link,
		Peer:     peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesHideAllChatJoinRequests")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesHideChatJoinRequestParams struct {
	Approved bool `tl:"flag:0,encoded_in_bitflags"`
	Peer     InputPeer
	UserID   InputUser
}

func (*MessagesHideChatJoinRequestParams) CRC() uint32 {
	return 0x7fe7e815
}

func (*MessagesHideChatJoinRequestParams) FlagIndex() int {
	return 0
}

// Dismiss or approve a chat join request related to a specific chat or channel.
func (c *Client) MessagesHideChatJoinRequest(approved bool, peer InputPeer, userID InputUser) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesHideChatJoinRequestParams{
		Approved: approved,
		Peer:     peer,
		UserID:   userID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesHideChatJoinRequest")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesHidePeerSettingsBarParams struct {
	Peer InputPeer
}

func (*MessagesHidePeerSettingsBarParams) CRC() uint32 {
	return 0x4facb138
}

// Should be called after the user hides the report spam/add as contact bar of a new chat, effectively prevents the user from executing the actions specified in the action bar ».
func (c *Client) MessagesHidePeerSettingsBar(peer InputPeer) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesHidePeerSettingsBarParams{Peer: peer})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesHidePeerSettingsBar")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesImportChatInviteParams struct {
	Hash string
}

func (*MessagesImportChatInviteParams) CRC() uint32 {
	return 0x6c50051c
}

// Import a chat invite and join a private chat/supergroup/channel
func (c *Client) MessagesImportChatInvite(hash string) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesImportChatInviteParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesImportChatInvite")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesInitHistoryImportParams struct {
	Peer       InputPeer
	File       InputFile
	MediaCount int32
}

func (*MessagesInitHistoryImportParams) CRC() uint32 {
	return 0x34090c3b
}

// Import chat history from a foreign chat app into a specific Telegram chat, click here for more info about imported chats ».
func (c *Client) MessagesInitHistoryImport(peer InputPeer, file InputFile, mediaCount int32) (*MessagesHistoryImport, error) {
	responseData, err := c.MakeRequest(&MessagesInitHistoryImportParams{
		File:       file,
		MediaCount: mediaCount,
		Peer:       peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesInitHistoryImport")
	}

	resp, ok := responseData.(*MessagesHistoryImport)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesInstallStickerSetParams struct {
	Stickerset InputStickerSet
	Archived   bool
}

func (*MessagesInstallStickerSetParams) CRC() uint32 {
	return 0xc78fe460
}

// Install a stickerset
func (c *Client) MessagesInstallStickerSet(stickerset InputStickerSet, archived bool) (MessagesStickerSetInstallResult, error) {
	responseData, err := c.MakeRequest(&MessagesInstallStickerSetParams{
		Archived:   archived,
		Stickerset: stickerset,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesInstallStickerSet")
	}

	resp, ok := responseData.(MessagesStickerSetInstallResult)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesJoinGroupCallParams struct {
	Muted        bool `tl:"flag:0,encoded_in_bitflags"`
	VideoStopped bool `tl:"flag:2,encoded_in_bitflags"`
	Call         *InputGroupCall
	JoinAs       InputPeer
	InviteHash   string `tl:"flag:1"`
	Params       *DataJson
}

func (*MessagesJoinGroupCallParams) CRC() uint32 {
	return 0xb132ff7b
}

func (*MessagesJoinGroupCallParams) FlagIndex() int {
	return 0
}

func (c *Client) MessagesJoinGroupCall(params *MessagesJoinGroupCallParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesJoinGroupCall")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesMarkDialogUnreadParams struct {
	Unread bool `tl:"flag:0,encoded_in_bitflags"`
	Peer   InputDialogPeer
}

func (*MessagesMarkDialogUnreadParams) CRC() uint32 {
	return 0xc286d98f
}

func (*MessagesMarkDialogUnreadParams) FlagIndex() int {
	return 0
}

// Manually mark dialog as unread
func (c *Client) MessagesMarkDialogUnread(unread bool, peer InputDialogPeer) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesMarkDialogUnreadParams{
		Peer:   peer,
		Unread: unread,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesMarkDialogUnread")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesMigrateChatParams struct {
	ChatID int64
}

func (*MessagesMigrateChatParams) CRC() uint32 {
	return 0xa2875319
}

// Turn a basic group into a supergroup
func (c *Client) MessagesMigrateChat(chatID int64) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesMigrateChatParams{ChatID: chatID})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesMigrateChat")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesProlongWebViewParams struct {
	Silent  bool `tl:"flag:5,encoded_in_bitflags"`
	Peer    InputPeer
	Bot     InputUser
	QueryID int64
	ReplyTo InputReplyTo `tl:"flag:0"`
	SendAs  InputPeer    `tl:"flag:13"`
}

func (*MessagesProlongWebViewParams) CRC() uint32 {
	return 0xb0d81a83
}

func (*MessagesProlongWebViewParams) FlagIndex() int {
	return 0
}

// Indicate to the server (from the user side) that the user is still using a web app.
func (c *Client) MessagesProlongWebView(params *MessagesProlongWebViewParams) (bool, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesProlongWebView")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesRateTranscribedAudioParams struct {
	Peer            InputPeer
	MsgID           int32
	TranscriptionID int64
	Good            bool
}

func (*MessagesRateTranscribedAudioParams) CRC() uint32 {
	return 0x7f1d072f
}

// Rate transcribed voice message
func (c *Client) MessagesRateTranscribedAudio(peer InputPeer, msgID int32, transcriptionID int64, good bool) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesRateTranscribedAudioParams{
		Good:            good,
		MsgID:           msgID,
		Peer:            peer,
		TranscriptionID: transcriptionID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesRateTranscribedAudio")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReadDiscussionParams struct {
	Peer      InputPeer
	MsgID     int32
	ReadMaxID int32
}

func (*MessagesReadDiscussionParams) CRC() uint32 {
	return 0xf731a9f4
}

// Mark a thread as read
func (c *Client) MessagesReadDiscussion(peer InputPeer, msgID, readMaxID int32) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesReadDiscussionParams{
		MsgID:     msgID,
		Peer:      peer,
		ReadMaxID: readMaxID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesReadDiscussion")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReadEncryptedHistoryParams struct {
	Peer    *InputEncryptedChat
	MaxDate int32
}

func (*MessagesReadEncryptedHistoryParams) CRC() uint32 {
	return 0x7f4b690a
}

// Marks message history within a secret chat as read.
func (c *Client) MessagesReadEncryptedHistory(peer *InputEncryptedChat, maxDate int32) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesReadEncryptedHistoryParams{
		MaxDate: maxDate,
		Peer:    peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesReadEncryptedHistory")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReadFeaturedStickersParams struct {
	ID []int64
}

func (*MessagesReadFeaturedStickersParams) CRC() uint32 {
	return 0x5b118126
}

// Mark new featured stickers as read
func (c *Client) MessagesReadFeaturedStickers(id []int64) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesReadFeaturedStickersParams{ID: id})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesReadFeaturedStickers")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReadHistoryParams struct {
	Peer  InputPeer
	MaxID int32
}

func (*MessagesReadHistoryParams) CRC() uint32 {
	return 0xe306d3a
}

// Marks message history as read.
func (c *Client) MessagesReadHistory(peer InputPeer, maxID int32) (*MessagesAffectedMessages, error) {
	responseData, err := c.MakeRequest(&MessagesReadHistoryParams{
		MaxID: maxID,
		Peer:  peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesReadHistory")
	}

	resp, ok := responseData.(*MessagesAffectedMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReadMentionsParams struct {
	Peer     InputPeer
	TopMsgID int32 `tl:"flag:0"`
}

func (*MessagesReadMentionsParams) CRC() uint32 {
	return 0x36e5bf4d
}

func (*MessagesReadMentionsParams) FlagIndex() int {
	return 0
}

// Mark mentions as read
func (c *Client) MessagesReadMentions(peer InputPeer, topMsgID int32) (*MessagesAffectedHistory, error) {
	responseData, err := c.MakeRequest(&MessagesReadMentionsParams{
		Peer:     peer,
		TopMsgID: topMsgID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesReadMentions")
	}

	resp, ok := responseData.(*MessagesAffectedHistory)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReadMessageContentsParams struct {
	ID []int32
}

func (*MessagesReadMessageContentsParams) CRC() uint32 {
	return 0x36a73f77
}

// Notifies the sender about the recipient having listened a voice message or watched a video.
func (c *Client) MessagesReadMessageContents(id []int32) (*MessagesAffectedMessages, error) {
	responseData, err := c.MakeRequest(&MessagesReadMessageContentsParams{ID: id})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesReadMessageContents")
	}

	resp, ok := responseData.(*MessagesAffectedMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReadReactionsParams struct {
	Peer     InputPeer
	TopMsgID int32 `tl:"flag:0"`
}

func (*MessagesReadReactionsParams) CRC() uint32 {
	return 0x54aa7f8e
}

func (*MessagesReadReactionsParams) FlagIndex() int {
	return 0
}

// Mark message reactions » as read
func (c *Client) MessagesReadReactions(peer InputPeer, topMsgID int32) (*MessagesAffectedHistory, error) {
	responseData, err := c.MakeRequest(&MessagesReadReactionsParams{
		Peer:     peer,
		TopMsgID: topMsgID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesReadReactions")
	}

	resp, ok := responseData.(*MessagesAffectedHistory)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReceivedMessagesParams struct {
	MaxID int32
}

func (*MessagesReceivedMessagesParams) CRC() uint32 {
	return 0x5a954c0
}

// Confirms receipt of messages by a client, cancels PUSH-notification sending.
func (c *Client) MessagesReceivedMessages(maxID int32) ([]*ReceivedNotifyMessage, error) {
	responseData, err := c.MakeRequest(&MessagesReceivedMessagesParams{MaxID: maxID})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesReceivedMessages")
	}

	resp, ok := responseData.([]*ReceivedNotifyMessage)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReceivedQueueParams struct {
	MaxQts int32
}

func (*MessagesReceivedQueueParams) CRC() uint32 {
	return 0x55a5bb66
}

/*
Confirms receipt of messages in a secret chat by client, cancels push notifications.<br>
The method returns a list of <strong>random_id</strong>s of messages for which push notifications were cancelled.
*/
func (c *Client) MessagesReceivedQueue(maxQts int32) ([]int64, error) {
	responseData, err := c.MakeRequest(&MessagesReceivedQueueParams{MaxQts: maxQts})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesReceivedQueue")
	}

	resp, ok := responseData.([]int64)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReorderPinnedDialogsParams struct {
	Force    bool `tl:"flag:0,encoded_in_bitflags"`
	FolderID int32
	Order    []InputDialogPeer
}

func (*MessagesReorderPinnedDialogsParams) CRC() uint32 {
	return 0x3b1adf37
}

func (*MessagesReorderPinnedDialogsParams) FlagIndex() int {
	return 0
}

// Reorder pinned dialogs
func (c *Client) MessagesReorderPinnedDialogs(force bool, folderID int32, order []InputDialogPeer) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesReorderPinnedDialogsParams{
		FolderID: folderID,
		Force:    force,
		Order:    order,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesReorderPinnedDialogs")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReorderPinnedSavedDialogsParams struct {
	Force bool `tl:"flag:0,encoded_in_bitflags"`
	Order []InputDialogPeer
}

func (*MessagesReorderPinnedSavedDialogsParams) CRC() uint32 {
	return 0x8b716587
}

func (*MessagesReorderPinnedSavedDialogsParams) FlagIndex() int {
	return 0
}

// Reorder pinned saved message dialogs ».
func (c *Client) MessagesReorderPinnedSavedDialogs(force bool, order []InputDialogPeer) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesReorderPinnedSavedDialogsParams{
		Force: force,
		Order: order,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesReorderPinnedSavedDialogs")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReorderQuickRepliesParams struct {
	Order []int32
}

func (*MessagesReorderQuickRepliesParams) CRC() uint32 {
	return 0x60331907
}

// Reorder quick reply shortcuts.
func (c *Client) MessagesReorderQuickReplies(order []int32) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesReorderQuickRepliesParams{Order: order})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesReorderQuickReplies")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReorderStickerSetsParams struct {
	Masks  bool `tl:"flag:0,encoded_in_bitflags"`
	Emojis bool `tl:"flag:1,encoded_in_bitflags"`
	Order  []int64
}

func (*MessagesReorderStickerSetsParams) CRC() uint32 {
	return 0x78337739
}

func (*MessagesReorderStickerSetsParams) FlagIndex() int {
	return 0
}

// Reorder installed stickersets
func (c *Client) MessagesReorderStickerSets(masks, emojis bool, order []int64) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesReorderStickerSetsParams{
		Emojis: emojis,
		Masks:  masks,
		Order:  order,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesReorderStickerSets")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReportParams struct {
	Peer    InputPeer
	ID      []int32
	Option  []byte
	Message string
}

func (*MessagesReportParams) CRC() uint32 {
	return 0xfc78af9b
}

// Report a message in a chat for violation of telegram's Terms of Service
func (c *Client) MessagesReport(peer InputPeer, id []int32, option []byte, message string) (ReportResult, error) {
	responseData, err := c.MakeRequest(&MessagesReportParams{
		ID:      id,
		Message: message,
		Option:  option,
		Peer:    peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesReport")
	}

	resp, ok := responseData.(ReportResult)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReportEncryptedSpamParams struct {
	Peer *InputEncryptedChat
}

func (*MessagesReportEncryptedSpamParams) CRC() uint32 {
	return 0x4b0c8c0f
}

// Report a secret chat for spam
func (c *Client) MessagesReportEncryptedSpam(peer *InputEncryptedChat) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesReportEncryptedSpamParams{Peer: peer})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesReportEncryptedSpam")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReportMessagesDeliveryParams struct {
	Push bool `tl:"flag:0,encoded_in_bitflags"`
	Peer InputPeer
	ID   []int32
}

func (*MessagesReportMessagesDeliveryParams) CRC() uint32 {
	return 0x5a6d7395
}

func (*MessagesReportMessagesDeliveryParams) FlagIndex() int {
	return 0
}

func (c *Client) MessagesReportMessagesDelivery(push bool, peer InputPeer, id []int32) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesReportMessagesDeliveryParams{
		ID:   id,
		Peer: peer,
		Push: push,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesReportMessagesDelivery")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReportReactionParams struct {
	Peer         InputPeer
	ID           int32
	ReactionPeer InputPeer
}

func (*MessagesReportReactionParams) CRC() uint32 {
	return 0x3f64c076
}

// Report a message reaction
func (c *Client) MessagesReportReaction(peer InputPeer, id int32, reactionPeer InputPeer) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesReportReactionParams{
		ID:           id,
		Peer:         peer,
		ReactionPeer: reactionPeer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesReportReaction")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReportSpamParams struct {
	Peer InputPeer
}

func (*MessagesReportSpamParams) CRC() uint32 {
	return 0xcf1592db
}

// Report a new incoming chat for spam, if the peer settings of the chat allow us to do that
func (c *Client) MessagesReportSpam(peer InputPeer) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesReportSpamParams{Peer: peer})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesReportSpam")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesReportSponsoredMessageParams struct {
	Peer     InputPeer
	RandomID []byte
	Option   []byte
}

func (*MessagesReportSponsoredMessageParams) CRC() uint32 {
	return 0x1af3dbb8
}

// Report a sponsored message », see here » for more info on the full flow.
func (c *Client) MessagesReportSponsoredMessage(peer InputPeer, randomID, option []byte) (ChannelsSponsoredMessageReportResult, error) {
	responseData, err := c.MakeRequest(&MessagesReportSponsoredMessageParams{
		Option:   option,
		Peer:     peer,
		RandomID: randomID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesReportSponsoredMessage")
	}

	resp, ok := responseData.(ChannelsSponsoredMessageReportResult)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesRequestAppWebViewParams struct {
	WriteAllowed bool `tl:"flag:0,encoded_in_bitflags"`
	Compact      bool `tl:"flag:7,encoded_in_bitflags"`
	Fullscreen   bool `tl:"flag:8,encoded_in_bitflags"`
	Peer         InputPeer
	App          InputBotApp
	StartParam   string    `tl:"flag:1"`
	ThemeParams  *DataJson `tl:"flag:2"`
	Platform     string
}

func (*MessagesRequestAppWebViewParams) CRC() uint32 {
	return 0x53618bce
}

func (*MessagesRequestAppWebViewParams) FlagIndex() int {
	return 0
}

// Open a bot mini app from a direct Mini App deep link, sending over user information after user confirmation.
func (c *Client) MessagesRequestAppWebView(params *MessagesRequestAppWebViewParams) (*WebViewResultURL, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesRequestAppWebView")
	}

	resp, ok := responseData.(*WebViewResultURL)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesRequestEncryptionParams struct {
	UserID   InputUser
	RandomID int32
	GA       []byte
}

func (*MessagesRequestEncryptionParams) CRC() uint32 {
	return 0xf64daf43
}

// Sends a request to start a secret chat to the user.
func (c *Client) MessagesRequestEncryption(userID InputUser, randomID int32, gA []byte) (EncryptedChat, error) {
	responseData, err := c.MakeRequest(&MessagesRequestEncryptionParams{
		GA:       gA,
		RandomID: randomID,
		UserID:   userID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesRequestEncryption")
	}

	resp, ok := responseData.(EncryptedChat)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesRequestMainWebViewParams struct {
	Compact     bool `tl:"flag:7,encoded_in_bitflags"`
	Fullscreen  bool `tl:"flag:8,encoded_in_bitflags"`
	Peer        InputPeer
	Bot         InputUser
	StartParam  string    `tl:"flag:1"`
	ThemeParams *DataJson `tl:"flag:0"`
	Platform    string
}

func (*MessagesRequestMainWebViewParams) CRC() uint32 {
	return 0xc9e01e7b
}

func (*MessagesRequestMainWebViewParams) FlagIndex() int {
	return 0
}

// Open a Main Mini App.
func (c *Client) MessagesRequestMainWebView(params *MessagesRequestMainWebViewParams) (*WebViewResultURL, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesRequestMainWebView")
	}

	resp, ok := responseData.(*WebViewResultURL)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesRequestSimpleWebViewParams struct {
	FromSwitchWebview bool `tl:"flag:1,encoded_in_bitflags"`
	FromSideMenu      bool `tl:"flag:2,encoded_in_bitflags"`
	Compact           bool `tl:"flag:7,encoded_in_bitflags"`
	Fullscreen        bool `tl:"flag:8,encoded_in_bitflags"`
	Bot               InputUser
	URL               string    `tl:"flag:3"`
	StartParam        string    `tl:"flag:4"`
	ThemeParams       *DataJson `tl:"flag:0"`
	Platform          string
}

func (*MessagesRequestSimpleWebViewParams) CRC() uint32 {
	return 0x413a3e73
}

func (*MessagesRequestSimpleWebViewParams) FlagIndex() int {
	return 0
}

// Open a bot mini app.
func (c *Client) MessagesRequestSimpleWebView(params *MessagesRequestSimpleWebViewParams) (*WebViewResultURL, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesRequestSimpleWebView")
	}

	resp, ok := responseData.(*WebViewResultURL)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesRequestURLAuthParams struct {
	Peer     InputPeer `tl:"flag:1"`
	MsgID    int32     `tl:"flag:1"`
	ButtonID int32     `tl:"flag:1"`
	URL      string    `tl:"flag:2"`
}

func (*MessagesRequestURLAuthParams) CRC() uint32 {
	return 0x198fb446
}

func (*MessagesRequestURLAuthParams) FlagIndex() int {
	return 0
}

// Get more info about a Seamless Telegram Login authorization request, for more info click here »
func (c *Client) MessagesRequestURLAuth(peer InputPeer, msgID, buttonID int32, url string) (URLAuthResult, error) {
	responseData, err := c.MakeRequest(&MessagesRequestURLAuthParams{
		ButtonID: buttonID,
		MsgID:    msgID,
		Peer:     peer,
		URL:      url,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesRequestURLAuth")
	}

	resp, ok := responseData.(URLAuthResult)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesRequestWebViewParams struct {
	FromBotMenu bool `tl:"flag:4,encoded_in_bitflags"`
	Silent      bool `tl:"flag:5,encoded_in_bitflags"`
	Compact     bool `tl:"flag:7,encoded_in_bitflags"`
	Fullscreen  bool `tl:"flag:8,encoded_in_bitflags"`
	Peer        InputPeer
	Bot         InputUser
	URL         string    `tl:"flag:1"`
	StartParam  string    `tl:"flag:3"`
	ThemeParams *DataJson `tl:"flag:2"`
	Platform    string
	ReplyTo     InputReplyTo `tl:"flag:0"`
	SendAs      InputPeer    `tl:"flag:13"`
}

func (*MessagesRequestWebViewParams) CRC() uint32 {
	return 0x269dc2c1
}

func (*MessagesRequestWebViewParams) FlagIndex() int {
	return 0
}

// Open a bot mini app, sending over user information after user confirmation.
func (c *Client) MessagesRequestWebView(params *MessagesRequestWebViewParams) (*WebViewResultURL, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesRequestWebView")
	}

	resp, ok := responseData.(*WebViewResultURL)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSaveDefaultSendAsParams struct {
	Peer   InputPeer
	SendAs InputPeer
}

func (*MessagesSaveDefaultSendAsParams) CRC() uint32 {
	return 0xccfddf96
}

// Change the default peer that should be used when sending messages, reactions, poll votes to a specific group
func (c *Client) MessagesSaveDefaultSendAs(peer, sendAs InputPeer) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesSaveDefaultSendAsParams{
		Peer:   peer,
		SendAs: sendAs,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesSaveDefaultSendAs")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSaveDraftParams struct {
	NoWebpage   bool         `tl:"flag:1,encoded_in_bitflags"`
	InvertMedia bool         `tl:"flag:6,encoded_in_bitflags"`
	ReplyTo     InputReplyTo `tl:"flag:4"`
	Peer        InputPeer
	Message     string
	Entities    []MessageEntity `tl:"flag:3"`
	Media       InputMedia      `tl:"flag:5"`
	Effect      int64           `tl:"flag:7"`
}

func (*MessagesSaveDraftParams) CRC() uint32 {
	return 0xd372c5ce
}

func (*MessagesSaveDraftParams) FlagIndex() int {
	return 0
}

// Save a message draft associated to a chat.
func (c *Client) MessagesSaveDraft(params *MessagesSaveDraftParams) (bool, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesSaveDraft")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSaveGifParams struct {
	ID     InputDocument
	Unsave bool
}

func (*MessagesSaveGifParams) CRC() uint32 {
	return 0x327a30cb
}

// Add GIF to saved gifs list
func (c *Client) MessagesSaveGif(id InputDocument, unsave bool) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesSaveGifParams{
		ID:     id,
		Unsave: unsave,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesSaveGif")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSavePreparedInlineMessageParams struct {
	Result    InputBotInlineResult
	UserID    InputUser
	PeerTypes []InlineQueryPeerType `tl:"flag:0"`
}

func (*MessagesSavePreparedInlineMessageParams) CRC() uint32 {
	return 0xf21f7f2f
}

func (*MessagesSavePreparedInlineMessageParams) FlagIndex() int {
	return 0
}

// Save a prepared inline message, to be shared by the user of the mini app using a web_app_send_prepared_message event
func (c *Client) MessagesSavePreparedInlineMessage(result InputBotInlineResult, userID InputUser, peerTypes []InlineQueryPeerType) (*MessagesBotPreparedInlineMessage, error) {
	responseData, err := c.MakeRequest(&MessagesSavePreparedInlineMessageParams{
		PeerTypes: peerTypes,
		Result:    result,
		UserID:    userID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSavePreparedInlineMessage")
	}

	resp, ok := responseData.(*MessagesBotPreparedInlineMessage)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSaveRecentStickerParams struct {
	Attached bool `tl:"flag:0,encoded_in_bitflags"`
	ID       InputDocument
	Unsave   bool
}

func (*MessagesSaveRecentStickerParams) CRC() uint32 {
	return 0x392718f8
}

func (*MessagesSaveRecentStickerParams) FlagIndex() int {
	return 0
}

// Add/remove sticker from recent stickers list
func (c *Client) MessagesSaveRecentSticker(attached bool, id InputDocument, unsave bool) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesSaveRecentStickerParams{
		Attached: attached,
		ID:       id,
		Unsave:   unsave,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesSaveRecentSticker")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSearchParams struct {
	Peer          InputPeer
	Q             string
	FromID        InputPeer  `tl:"flag:0"`
	SavedPeerID   InputPeer  `tl:"flag:2"`
	SavedReaction []Reaction `tl:"flag:3"`
	TopMsgID      int32      `tl:"flag:1"`
	Filter        MessagesFilter
	MinDate       int32
	MaxDate       int32
	OffsetID      int32
	AddOffset     int32
	Limit         int32
	MaxID         int32
	MinID         int32
	Hash          int64
}

func (*MessagesSearchParams) CRC() uint32 {
	return 0x29ee847a
}

func (*MessagesSearchParams) FlagIndex() int {
	return 0
}

// Search for messages.
func (c *Client) MessagesSearch(params *MessagesSearchParams) (MessagesMessages, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSearch")
	}

	resp, ok := responseData.(MessagesMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSearchCustomEmojiParams struct {
	Emoticon string
	Hash     int64
}

func (*MessagesSearchCustomEmojiParams) CRC() uint32 {
	return 0x2c11c0d7
}

// Look for custom emojis associated to a UTF8 emoji
func (c *Client) MessagesSearchCustomEmoji(emoticon string, hash int64) (EmojiList, error) {
	responseData, err := c.MakeRequest(&MessagesSearchCustomEmojiParams{
		Emoticon: emoticon,
		Hash:     hash,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSearchCustomEmoji")
	}

	resp, ok := responseData.(EmojiList)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSearchEmojiStickerSetsParams struct {
	ExcludeFeatured bool `tl:"flag:0,encoded_in_bitflags"`
	Q               string
	Hash            int64
}

func (*MessagesSearchEmojiStickerSetsParams) CRC() uint32 {
	return 0x92b4494c
}

func (*MessagesSearchEmojiStickerSetsParams) FlagIndex() int {
	return 0
}

// Search for custom emoji stickersets »
func (c *Client) MessagesSearchEmojiStickerSets(excludeFeatured bool, q string, hash int64) (MessagesFoundStickerSets, error) {
	responseData, err := c.MakeRequest(&MessagesSearchEmojiStickerSetsParams{
		ExcludeFeatured: excludeFeatured,
		Hash:            hash,
		Q:               q,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSearchEmojiStickerSets")
	}

	resp, ok := responseData.(MessagesFoundStickerSets)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSearchGlobalParams struct {
	BroadcastsOnly bool  `tl:"flag:1,encoded_in_bitflags"`
	GroupsOnly     bool  `tl:"flag:2,encoded_in_bitflags"`
	UsersOnly      bool  `tl:"flag:3,encoded_in_bitflags"`
	FolderID       int32 `tl:"flag:0"`
	Q              string
	Filter         MessagesFilter
	MinDate        int32
	MaxDate        int32
	OffsetRate     int32
	OffsetPeer     InputPeer
	OffsetID       int32
	Limit          int32
}

func (*MessagesSearchGlobalParams) CRC() uint32 {
	return 0x4bc6589a
}

func (*MessagesSearchGlobalParams) FlagIndex() int {
	return 0
}

// Search for messages and peers globally
func (c *Client) MessagesSearchGlobal(params *MessagesSearchGlobalParams) (MessagesMessages, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSearchGlobal")
	}

	resp, ok := responseData.(MessagesMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSearchSentMediaParams struct {
	Q      string
	Filter MessagesFilter
	Limit  int32
}

func (*MessagesSearchSentMediaParams) CRC() uint32 {
	return 0x107e31a0
}

/*
View and search recently sent media.<br>
This method does not support pagination.
*/
func (c *Client) MessagesSearchSentMedia(q string, filter MessagesFilter, limit int32) (MessagesMessages, error) {
	responseData, err := c.MakeRequest(&MessagesSearchSentMediaParams{
		Filter: filter,
		Limit:  limit,
		Q:      q,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSearchSentMedia")
	}

	resp, ok := responseData.(MessagesMessages)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSearchStickerSetsParams struct {
	ExcludeFeatured bool `tl:"flag:0,encoded_in_bitflags"`
	Q               string
	Hash            int64
}

func (*MessagesSearchStickerSetsParams) CRC() uint32 {
	return 0x35705b8a
}

func (*MessagesSearchStickerSetsParams) FlagIndex() int {
	return 0
}

// Search for stickersets
func (c *Client) MessagesSearchStickerSets(excludeFeatured bool, q string, hash int64) (MessagesFoundStickerSets, error) {
	responseData, err := c.MakeRequest(&MessagesSearchStickerSetsParams{
		ExcludeFeatured: excludeFeatured,
		Hash:            hash,
		Q:               q,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSearchStickerSets")
	}

	resp, ok := responseData.(MessagesFoundStickerSets)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSearchStickersParams struct {
	Emojis   bool `tl:"flag:0,encoded_in_bitflags"`
	Q        string
	Emoticon string
	LangCode []string
	Offset   int32
	Limit    int32
	Hash     int64
}

func (*MessagesSearchStickersParams) CRC() uint32 {
	return 0x29b1c66a
}

func (*MessagesSearchStickersParams) FlagIndex() int {
	return 0
}

// Search for stickers using AI-powered keyword search
func (c *Client) MessagesSearchStickers(params *MessagesSearchStickersParams) (MessagesFoundStickers, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSearchStickers")
	}

	resp, ok := responseData.(MessagesFoundStickers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendBotRequestedPeerParams struct {
	Peer           InputPeer
	MsgID          int32
	ButtonID       int32
	RequestedPeers []InputPeer
}

func (*MessagesSendBotRequestedPeerParams) CRC() uint32 {
	return 0x91b2d060
}

// Send one or more chosen peers, as requested by a keyboardButtonRequestPeer button.
func (c *Client) MessagesSendBotRequestedPeer(peer InputPeer, msgID, buttonID int32, requestedPeers []InputPeer) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesSendBotRequestedPeerParams{
		ButtonID:       buttonID,
		MsgID:          msgID,
		Peer:           peer,
		RequestedPeers: requestedPeers,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendBotRequestedPeer")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendEncryptedParams struct {
	Silent   bool `tl:"flag:0,encoded_in_bitflags"`
	Peer     *InputEncryptedChat
	RandomID int64
	Data     []byte
}

func (*MessagesSendEncryptedParams) CRC() uint32 {
	return 0x44fa7a15
}

func (*MessagesSendEncryptedParams) FlagIndex() int {
	return 0
}

// Sends a text message to a secret chat.
func (c *Client) MessagesSendEncrypted(silent bool, peer *InputEncryptedChat, randomID int64, data []byte) (MessagesSentEncryptedMessage, error) {
	responseData, err := c.MakeRequest(&MessagesSendEncryptedParams{
		Data:     data,
		Peer:     peer,
		RandomID: randomID,
		Silent:   silent,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendEncrypted")
	}

	resp, ok := responseData.(MessagesSentEncryptedMessage)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendEncryptedFileParams struct {
	Silent   bool `tl:"flag:0,encoded_in_bitflags"`
	Peer     *InputEncryptedChat
	RandomID int64
	Data     []byte
	File     InputEncryptedFile
}

func (*MessagesSendEncryptedFileParams) CRC() uint32 {
	return 0x5559481d
}

func (*MessagesSendEncryptedFileParams) FlagIndex() int {
	return 0
}

// Sends a message with a file attachment to a secret chat
func (c *Client) MessagesSendEncryptedFile(params *MessagesSendEncryptedFileParams) (MessagesSentEncryptedMessage, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendEncryptedFile")
	}

	resp, ok := responseData.(MessagesSentEncryptedMessage)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendEncryptedMultiMediaParams struct{}

func (*MessagesSendEncryptedMultiMediaParams) CRC() uint32 {
	return 0xcacacaca
}

func (c *Client) MessagesSendEncryptedMultiMedia() (MessagesSentEncryptedMessage, error) {
	responseData, err := c.MakeRequest(&MessagesSendEncryptedMultiMediaParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendEncryptedMultiMedia")
	}

	resp, ok := responseData.(MessagesSentEncryptedMessage)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendEncryptedServiceParams struct {
	Peer     *InputEncryptedChat
	RandomID int64
	Data     []byte
}

func (*MessagesSendEncryptedServiceParams) CRC() uint32 {
	return 0x32d439a4
}

// Sends a service message to a secret chat.
func (c *Client) MessagesSendEncryptedService(peer *InputEncryptedChat, randomID int64, data []byte) (MessagesSentEncryptedMessage, error) {
	responseData, err := c.MakeRequest(&MessagesSendEncryptedServiceParams{
		Data:     data,
		Peer:     peer,
		RandomID: randomID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendEncryptedService")
	}

	resp, ok := responseData.(MessagesSentEncryptedMessage)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendInlineBotResultParams struct {
	Silent             bool `tl:"flag:5,encoded_in_bitflags"`
	Background         bool `tl:"flag:6,encoded_in_bitflags"`
	ClearDraft         bool `tl:"flag:7,encoded_in_bitflags"`
	HideVia            bool `tl:"flag:11,encoded_in_bitflags"`
	Peer               InputPeer
	ReplyTo            InputReplyTo `tl:"flag:0"`
	RandomID           int64
	QueryID            int64
	ID                 string
	ScheduleDate       int32                   `tl:"flag:10"`
	SendAs             InputPeer               `tl:"flag:13"`
	QuickReplyShortcut InputQuickReplyShortcut `tl:"flag:17"`
}

func (*MessagesSendInlineBotResultParams) CRC() uint32 {
	return 0x3ebee86a
}

func (*MessagesSendInlineBotResultParams) FlagIndex() int {
	return 0
}

// Send a result obtained using messages.getInlineBotResults.
func (c *Client) MessagesSendInlineBotResult(params *MessagesSendInlineBotResultParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendInlineBotResult")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendMediaParams struct {
	Silent                 bool `tl:"flag:5,encoded_in_bitflags"`
	Background             bool `tl:"flag:6,encoded_in_bitflags"`
	ClearDraft             bool `tl:"flag:7,encoded_in_bitflags"`
	Noforwards             bool `tl:"flag:14,encoded_in_bitflags"`
	UpdateStickersetsOrder bool `tl:"flag:15,encoded_in_bitflags"`
	InvertMedia            bool `tl:"flag:16,encoded_in_bitflags"`
	AllowPaidFloodskip     bool `tl:"flag:19,encoded_in_bitflags"`
	Peer                   InputPeer
	ReplyTo                InputReplyTo `tl:"flag:0"`
	Media                  InputMedia
	Message                string
	RandomID               int64
	ReplyMarkup            ReplyMarkup             `tl:"flag:2"`
	Entities               []MessageEntity         `tl:"flag:3"`
	ScheduleDate           int32                   `tl:"flag:10"`
	SendAs                 InputPeer               `tl:"flag:13"`
	QuickReplyShortcut     InputQuickReplyShortcut `tl:"flag:17"`
	Effect                 int64                   `tl:"flag:18"`
}

func (*MessagesSendMediaParams) CRC() uint32 {
	return 0x7852834e
}

func (*MessagesSendMediaParams) FlagIndex() int {
	return 0
}

// Send a media
func (c *Client) MessagesSendMedia(params *MessagesSendMediaParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendMedia")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendMessageParams struct {
	NoWebpage              bool `tl:"flag:1,encoded_in_bitflags"`
	Silent                 bool `tl:"flag:5,encoded_in_bitflags"`
	Background             bool `tl:"flag:6,encoded_in_bitflags"`
	ClearDraft             bool `tl:"flag:7,encoded_in_bitflags"`
	Noforwards             bool `tl:"flag:14,encoded_in_bitflags"`
	UpdateStickersetsOrder bool `tl:"flag:15,encoded_in_bitflags"`
	InvertMedia            bool `tl:"flag:16,encoded_in_bitflags"`
	AllowPaidFloodskip     bool `tl:"flag:19,encoded_in_bitflags"`
	Peer                   InputPeer
	ReplyTo                InputReplyTo `tl:"flag:0"`
	Message                string
	RandomID               int64
	ReplyMarkup            ReplyMarkup             `tl:"flag:2"`
	Entities               []MessageEntity         `tl:"flag:3"`
	ScheduleDate           int32                   `tl:"flag:10"`
	SendAs                 InputPeer               `tl:"flag:13"`
	QuickReplyShortcut     InputQuickReplyShortcut `tl:"flag:17"`
	Effect                 int64                   `tl:"flag:18"`
}

func (*MessagesSendMessageParams) CRC() uint32 {
	return 0x983f9745
}

func (*MessagesSendMessageParams) FlagIndex() int {
	return 0
}

// Sends a message to a chat
func (c *Client) MessagesSendMessage(params *MessagesSendMessageParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendMessage")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendMultiMediaParams struct {
	Silent                 bool `tl:"flag:5,encoded_in_bitflags"`
	Background             bool `tl:"flag:6,encoded_in_bitflags"`
	ClearDraft             bool `tl:"flag:7,encoded_in_bitflags"`
	Noforwards             bool `tl:"flag:14,encoded_in_bitflags"`
	UpdateStickersetsOrder bool `tl:"flag:15,encoded_in_bitflags"`
	InvertMedia            bool `tl:"flag:16,encoded_in_bitflags"`
	AllowPaidFloodskip     bool `tl:"flag:19,encoded_in_bitflags"`
	Peer                   InputPeer
	ReplyTo                InputReplyTo `tl:"flag:0"`
	MultiMedia             []*InputSingleMedia
	ScheduleDate           int32                   `tl:"flag:10"`
	SendAs                 InputPeer               `tl:"flag:13"`
	QuickReplyShortcut     InputQuickReplyShortcut `tl:"flag:17"`
	Effect                 int64                   `tl:"flag:18"`
}

func (*MessagesSendMultiMediaParams) CRC() uint32 {
	return 0x37b74355
}

func (*MessagesSendMultiMediaParams) FlagIndex() int {
	return 0
}

// Send an album or grouped media
func (c *Client) MessagesSendMultiMedia(params *MessagesSendMultiMediaParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendMultiMedia")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendPaidReactionParams struct {
	Peer     InputPeer
	MsgID    int32
	Count    int32
	RandomID int64
	Privacy  PaidReactionPrivacy `tl:"flag:0"`
}

func (*MessagesSendPaidReactionParams) CRC() uint32 {
	return 0x58bbcb50
}

func (*MessagesSendPaidReactionParams) FlagIndex() int {
	return 0
}

// Sends one or more paid Telegram Star reactions », transferring Telegram Stars » to a channel&#39;s balance.
func (c *Client) MessagesSendPaidReaction(params *MessagesSendPaidReactionParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendPaidReaction")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendQuickReplyMessagesParams struct {
	Peer       InputPeer
	ShortcutID int32
	ID         []int32
	RandomID   []int64
}

func (*MessagesSendQuickReplyMessagesParams) CRC() uint32 {
	return 0x6c750de1
}

// Send a quick reply shortcut ».
func (c *Client) MessagesSendQuickReplyMessages(peer InputPeer, shortcutID int32, id []int32, randomID []int64) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesSendQuickReplyMessagesParams{
		ID:         id,
		Peer:       peer,
		RandomID:   randomID,
		ShortcutID: shortcutID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendQuickReplyMessages")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendReactionParams struct {
	Big         bool `tl:"flag:1,encoded_in_bitflags"`
	AddToRecent bool `tl:"flag:2,encoded_in_bitflags"`
	Peer        InputPeer
	MsgID       int32
	Reaction    []Reaction `tl:"flag:0"`
}

func (*MessagesSendReactionParams) CRC() uint32 {
	return 0xd30d78d4
}

func (*MessagesSendReactionParams) FlagIndex() int {
	return 0
}

// React to message.
func (c *Client) MessagesSendReaction(params *MessagesSendReactionParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendReaction")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendScheduledMessagesParams struct {
	Peer InputPeer
	ID   []int32
}

func (*MessagesSendScheduledMessagesParams) CRC() uint32 {
	return 0xbd38850a
}

// Send scheduled messages right away
func (c *Client) MessagesSendScheduledMessages(peer InputPeer, id []int32) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesSendScheduledMessagesParams{
		ID:   id,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendScheduledMessages")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendScreenshotNotificationParams struct {
	Peer     InputPeer
	ReplyTo  InputReplyTo
	RandomID int64
}

func (*MessagesSendScreenshotNotificationParams) CRC() uint32 {
	return 0xa1405817
}

// Notify the other user in a private chat that a screenshot of the chat was taken
func (c *Client) MessagesSendScreenshotNotification(peer InputPeer, replyTo InputReplyTo, randomID int64) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesSendScreenshotNotificationParams{
		Peer:     peer,
		RandomID: randomID,
		ReplyTo:  replyTo,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendScreenshotNotification")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendVoteParams struct {
	Peer    InputPeer
	MsgID   int32
	Options [][]byte
}

func (*MessagesSendVoteParams) CRC() uint32 {
	return 0x10ea6184
}

// Vote in a poll
func (c *Client) MessagesSendVote(peer InputPeer, msgID int32, options [][]byte) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesSendVoteParams{
		MsgID:   msgID,
		Options: options,
		Peer:    peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendVote")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendWebViewDataParams struct {
	Bot        InputUser
	RandomID   int64
	ButtonText string
	Data       string
}

func (*MessagesSendWebViewDataParams) CRC() uint32 {
	return 0xdc0242c8
}

// Used by the user to relay data from an opened reply keyboard bot mini app to the bot that owns it.
func (c *Client) MessagesSendWebViewData(bot InputUser, randomID int64, buttonText, data string) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesSendWebViewDataParams{
		Bot:        bot,
		ButtonText: buttonText,
		Data:       data,
		RandomID:   randomID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendWebViewData")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSendWebViewResultMessageParams struct {
	BotQueryID string
	Result     InputBotInlineResult
}

func (*MessagesSendWebViewResultMessageParams) CRC() uint32 {
	return 0xa4314f5
}

// Terminate webview interaction started with messages.requestWebView, sending the specified message to the chat on behalf of the user.
func (c *Client) MessagesSendWebViewResultMessage(botQueryID string, result InputBotInlineResult) (*WebViewMessageSent, error) {
	responseData, err := c.MakeRequest(&MessagesSendWebViewResultMessageParams{
		BotQueryID: botQueryID,
		Result:     result,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSendWebViewResultMessage")
	}

	resp, ok := responseData.(*WebViewMessageSent)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSetBotCallbackAnswerParams struct {
	Alert     bool `tl:"flag:1,encoded_in_bitflags"`
	QueryID   int64
	Message   string `tl:"flag:0"`
	URL       string `tl:"flag:2"`
	CacheTime int32
}

func (*MessagesSetBotCallbackAnswerParams) CRC() uint32 {
	return 0xd58f130a
}

func (*MessagesSetBotCallbackAnswerParams) FlagIndex() int {
	return 0
}

// Set the callback answer to a user button press (bots only)
func (c *Client) MessagesSetBotCallbackAnswer(params *MessagesSetBotCallbackAnswerParams) (bool, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesSetBotCallbackAnswer")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSetBotPrecheckoutResultsParams struct {
	Success bool `tl:"flag:1,encoded_in_bitflags"`
	QueryID int64
	Error   string `tl:"flag:0"`
}

func (*MessagesSetBotPrecheckoutResultsParams) CRC() uint32 {
	return 0x9c2dd95
}

func (*MessagesSetBotPrecheckoutResultsParams) FlagIndex() int {
	return 0
}

/*
Once the user has confirmed their payment and shipping details, the bot receives an updateBotPrecheckoutQuery update.<br>
Use this method to respond to such pre-checkout queries.<br>
<strong>Note</strong>: Telegram must receive an answer within 10 seconds after the pre-checkout query was sent.
*/
func (c *Client) MessagesSetBotPrecheckoutResults(success bool, queryID int64, error string) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesSetBotPrecheckoutResultsParams{
		Error:   error,
		QueryID: queryID,
		Success: success,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesSetBotPrecheckoutResults")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSetBotShippingResultsParams struct {
	QueryID         int64
	Error           string            `tl:"flag:0"`
	ShippingOptions []*ShippingOption `tl:"flag:1"`
}

func (*MessagesSetBotShippingResultsParams) CRC() uint32 {
	return 0xe5f672fa
}

func (*MessagesSetBotShippingResultsParams) FlagIndex() int {
	return 0
}

// If you sent an invoice requesting a shipping address and the parameter is_flexible was specified, the bot will receive an updateBotShippingQuery update. Use this method to reply to shipping queries.
func (c *Client) MessagesSetBotShippingResults(queryID int64, error string, shippingOptions []*ShippingOption) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesSetBotShippingResultsParams{
		Error:           error,
		QueryID:         queryID,
		ShippingOptions: shippingOptions,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesSetBotShippingResults")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSetChatAvailableReactionsParams struct {
	Peer               InputPeer
	AvailableReactions ChatReactions
	ReactionsLimit     int32 `tl:"flag:0"`
	PaidEnabled        bool  `tl:"flag:1"`
}

func (*MessagesSetChatAvailableReactionsParams) CRC() uint32 {
	return 0x864b2581
}

func (*MessagesSetChatAvailableReactionsParams) FlagIndex() int {
	return 0
}

// Change the set of message reactions » that can be used in a certain group, supergroup or channel
func (c *Client) MessagesSetChatAvailableReactions(peer InputPeer, availableReactions ChatReactions, reactionsLimit int32, paidEnabled bool) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesSetChatAvailableReactionsParams{
		AvailableReactions: availableReactions,
		PaidEnabled:        paidEnabled,
		Peer:               peer,
		ReactionsLimit:     reactionsLimit,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSetChatAvailableReactions")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSetChatThemeParams struct {
	Peer     InputPeer
	Emoticon string
}

func (*MessagesSetChatThemeParams) CRC() uint32 {
	return 0xe63be13f
}

// Change the chat theme of a certain chat
func (c *Client) MessagesSetChatTheme(peer InputPeer, emoticon string) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesSetChatThemeParams{
		Emoticon: emoticon,
		Peer:     peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSetChatTheme")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSetChatWallPaperParams struct {
	ForBoth   bool `tl:"flag:3,encoded_in_bitflags"`
	Revert    bool `tl:"flag:4,encoded_in_bitflags"`
	Peer      InputPeer
	Wallpaper InputWallPaper     `tl:"flag:0"`
	Settings  *WallPaperSettings `tl:"flag:2"`
	ID        int32              `tl:"flag:1"`
}

func (*MessagesSetChatWallPaperParams) CRC() uint32 {
	return 0x8ffacae1
}

func (*MessagesSetChatWallPaperParams) FlagIndex() int {
	return 0
}

// Set a custom wallpaper » in a specific private chat with another user.
func (c *Client) MessagesSetChatWallPaper(params *MessagesSetChatWallPaperParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSetChatWallPaper")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSetDefaultHistoryTtlParams struct {
	Period int32
}

func (*MessagesSetDefaultHistoryTtlParams) CRC() uint32 {
	return 0x9eb51445
}

// Changes the default value of the Time-To-Live setting, applied to all new chats.
func (c *Client) MessagesSetDefaultHistoryTtl(period int32) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesSetDefaultHistoryTtlParams{Period: period})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesSetDefaultHistoryTtl")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSetDefaultReactionParams struct {
	Reaction Reaction
}

func (*MessagesSetDefaultReactionParams) CRC() uint32 {
	return 0x4f47a016
}

// Change default emoji reaction to use in the quick reaction menu: the value is synced across devices and can be fetched using <a href="/method/help.getConfig">help.getConfig, `reactions_default` field</a>.
func (c *Client) MessagesSetDefaultReaction(reaction Reaction) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesSetDefaultReactionParams{Reaction: reaction})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesSetDefaultReaction")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSetEncryptedTypingParams struct {
	Peer   *InputEncryptedChat
	Typing bool
}

func (*MessagesSetEncryptedTypingParams) CRC() uint32 {
	return 0x791451ed
}

// Send typing event by the current user to a secret chat.
func (c *Client) MessagesSetEncryptedTyping(peer *InputEncryptedChat, typing bool) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesSetEncryptedTypingParams{
		Peer:   peer,
		Typing: typing,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesSetEncryptedTyping")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSetGameScoreParams struct {
	EditMessage bool `tl:"flag:0,encoded_in_bitflags"`
	Force       bool `tl:"flag:1,encoded_in_bitflags"`
	Peer        InputPeer
	ID          int32
	UserID      InputUser
	Score       int32
}

func (*MessagesSetGameScoreParams) CRC() uint32 {
	return 0x8ef8ecc0
}

func (*MessagesSetGameScoreParams) FlagIndex() int {
	return 0
}

// Use this method to set the score of the specified user in a game sent as a normal message (bots only).
func (c *Client) MessagesSetGameScore(params *MessagesSetGameScoreParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSetGameScore")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSetHistoryTtlParams struct {
	Peer   InputPeer
	Period int32
}

func (*MessagesSetHistoryTtlParams) CRC() uint32 {
	return 0xb80e5fe4
}

// Set maximum Time-To-Live of all messages in the specified chat
func (c *Client) MessagesSetHistoryTtl(peer InputPeer, period int32) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesSetHistoryTtlParams{
		Peer:   peer,
		Period: period,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesSetHistoryTtl")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSetInlineBotResultsParams struct {
	Gallery       bool `tl:"flag:0,encoded_in_bitflags"`
	Private       bool `tl:"flag:1,encoded_in_bitflags"`
	QueryID       int64
	Results       []InputBotInlineResult
	CacheTime     int32
	NextOffset    string             `tl:"flag:2"`
	SwitchPm      *InlineBotSwitchPm `tl:"flag:3"`
	SwitchWebview *InlineBotWebView  `tl:"flag:4"`
}

func (*MessagesSetInlineBotResultsParams) CRC() uint32 {
	return 0xbb12a419
}

func (*MessagesSetInlineBotResultsParams) FlagIndex() int {
	return 0
}

// Answer an inline query, for bots only
func (c *Client) MessagesSetInlineBotResults(params *MessagesSetInlineBotResultsParams) (bool, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesSetInlineBotResults")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSetInlineGameScoreParams struct {
	EditMessage bool `tl:"flag:0,encoded_in_bitflags"`
	Force       bool `tl:"flag:1,encoded_in_bitflags"`
	ID          InputBotInlineMessageID
	UserID      InputUser
	Score       int32
}

func (*MessagesSetInlineGameScoreParams) CRC() uint32 {
	return 0x15ad9f64
}

func (*MessagesSetInlineGameScoreParams) FlagIndex() int {
	return 0
}

// Use this method to set the score of the specified user in a game sent as an inline message (bots only).
func (c *Client) MessagesSetInlineGameScore(params *MessagesSetInlineGameScoreParams) (bool, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesSetInlineGameScore")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSetTypingParams struct {
	Peer     InputPeer
	TopMsgID int32 `tl:"flag:0"`
	Action   SendMessageAction
}

func (*MessagesSetTypingParams) CRC() uint32 {
	return 0x58943ee2
}

func (*MessagesSetTypingParams) FlagIndex() int {
	return 0
}

// Sends a current user typing event (see SendMessageAction for all event types) to a conversation partner or group.
func (c *Client) MessagesSetTyping(peer InputPeer, topMsgID int32, action SendMessageAction) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesSetTypingParams{
		Action:   action,
		Peer:     peer,
		TopMsgID: topMsgID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesSetTyping")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesSetWebViewResultParams struct {
	QueryID int64
}

func (*MessagesSetWebViewResultParams) CRC() uint32 {
	return 0xe41cd11d
}

func (c *Client) MessagesSetWebViewResult(queryID int64) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesSetWebViewResultParams{QueryID: queryID})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesSetWebViewResult")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesStartBotParams struct {
	Bot        InputUser
	Peer       InputPeer
	RandomID   int64
	StartParam string
}

func (*MessagesStartBotParams) CRC() uint32 {
	return 0xe6df7378
}

// Start a conversation with a bot using a deep linking parameter
func (c *Client) MessagesStartBot(bot InputUser, peer InputPeer, randomID int64, startParam string) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesStartBotParams{
		Bot:        bot,
		Peer:       peer,
		RandomID:   randomID,
		StartParam: startParam,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesStartBot")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesStartHistoryImportParams struct {
	Peer     InputPeer
	ImportID int64
}

func (*MessagesStartHistoryImportParams) CRC() uint32 {
	return 0xb43df344
}

/*
Complete the history import process, importing all messages into the chat.<br>
To be called only after initializing the import with messages.initHistoryImport and uploading all files using messages.uploadImportedMedia.
*/
func (c *Client) MessagesStartHistoryImport(peer InputPeer, importID int64) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesStartHistoryImportParams{
		ImportID: importID,
		Peer:     peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesStartHistoryImport")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesToggleBotInAttachMenuParams struct {
	WriteAllowed bool `tl:"flag:0,encoded_in_bitflags"`
	Bot          InputUser
	Enabled      bool
}

func (*MessagesToggleBotInAttachMenuParams) CRC() uint32 {
	return 0x69f59d69
}

func (*MessagesToggleBotInAttachMenuParams) FlagIndex() int {
	return 0
}

// Enable or disable web bot attachment menu »
func (c *Client) MessagesToggleBotInAttachMenu(writeAllowed bool, bot InputUser, enabled bool) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesToggleBotInAttachMenuParams{
		Bot:          bot,
		Enabled:      enabled,
		WriteAllowed: writeAllowed,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesToggleBotInAttachMenu")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesToggleDialogFilterTagsParams struct {
	Enabled bool
}

func (*MessagesToggleDialogFilterTagsParams) CRC() uint32 {
	return 0xfd2dda49
}

// Enable or disable folder tags ».
func (c *Client) MessagesToggleDialogFilterTags(enabled bool) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesToggleDialogFilterTagsParams{Enabled: enabled})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesToggleDialogFilterTags")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesToggleDialogPinParams struct {
	Pinned bool `tl:"flag:0,encoded_in_bitflags"`
	Peer   InputDialogPeer
}

func (*MessagesToggleDialogPinParams) CRC() uint32 {
	return 0xa731e257
}

func (*MessagesToggleDialogPinParams) FlagIndex() int {
	return 0
}

// Pin/unpin a dialog
func (c *Client) MessagesToggleDialogPin(pinned bool, peer InputDialogPeer) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesToggleDialogPinParams{
		Peer:   peer,
		Pinned: pinned,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesToggleDialogPin")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesToggleNoForwardsParams struct {
	Peer    InputPeer
	Enabled bool
}

func (*MessagesToggleNoForwardsParams) CRC() uint32 {
	return 0xb11eafa2
}

// Enable or disable content protection on a channel or chat
func (c *Client) MessagesToggleNoForwards(peer InputPeer, enabled bool) (Updates, error) {
	responseData, err := c.MakeRequest(&MessagesToggleNoForwardsParams{
		Enabled: enabled,
		Peer:    peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesToggleNoForwards")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesTogglePaidReactionPrivacyParams struct {
	Peer    InputPeer
	MsgID   int32
	Privacy PaidReactionPrivacy
}

func (*MessagesTogglePaidReactionPrivacyParams) CRC() uint32 {
	return 0x435885b5
}

// Changes the privacy of already sent paid reactions on a specific message.
func (c *Client) MessagesTogglePaidReactionPrivacy(peer InputPeer, msgID int32, privacy PaidReactionPrivacy) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesTogglePaidReactionPrivacyParams{
		MsgID:   msgID,
		Peer:    peer,
		Privacy: privacy,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesTogglePaidReactionPrivacy")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesTogglePeerTranslationsParams struct {
	Disabled bool `tl:"flag:0,encoded_in_bitflags"`
	Peer     InputPeer
}

func (*MessagesTogglePeerTranslationsParams) CRC() uint32 {
	return 0xe47cb579
}

func (*MessagesTogglePeerTranslationsParams) FlagIndex() int {
	return 0
}

// Show or hide the real-time chat translation popup for a certain chat
func (c *Client) MessagesTogglePeerTranslations(disabled bool, peer InputPeer) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesTogglePeerTranslationsParams{
		Disabled: disabled,
		Peer:     peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesTogglePeerTranslations")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesToggleSavedDialogPinParams struct {
	Pinned bool `tl:"flag:0,encoded_in_bitflags"`
	Peer   InputDialogPeer
}

func (*MessagesToggleSavedDialogPinParams) CRC() uint32 {
	return 0xac81bbde
}

func (*MessagesToggleSavedDialogPinParams) FlagIndex() int {
	return 0
}

// Pin or unpin a saved message dialog ».
func (c *Client) MessagesToggleSavedDialogPin(pinned bool, peer InputDialogPeer) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesToggleSavedDialogPinParams{
		Peer:   peer,
		Pinned: pinned,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesToggleSavedDialogPin")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesToggleStickerSetsParams struct {
	Uninstall   bool `tl:"flag:0,encoded_in_bitflags"`
	Archive     bool `tl:"flag:1,encoded_in_bitflags"`
	Unarchive   bool `tl:"flag:2,encoded_in_bitflags"`
	Stickersets []InputStickerSet
}

func (*MessagesToggleStickerSetsParams) CRC() uint32 {
	return 0xb5052fea
}

func (*MessagesToggleStickerSetsParams) FlagIndex() int {
	return 0
}

// Apply changes to multiple stickersets
func (c *Client) MessagesToggleStickerSets(uninstall, archive, unarchive bool, stickersets []InputStickerSet) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesToggleStickerSetsParams{
		Archive:     archive,
		Stickersets: stickersets,
		Unarchive:   unarchive,
		Uninstall:   uninstall,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesToggleStickerSets")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesTranscribeAudioParams struct {
	Peer  InputPeer
	MsgID int32
}

func (*MessagesTranscribeAudioParams) CRC() uint32 {
	return 0x269e9a49
}

// Transcribe voice message
func (c *Client) MessagesTranscribeAudio(peer InputPeer, msgID int32) (*MessagesTranscribedAudio, error) {
	responseData, err := c.MakeRequest(&MessagesTranscribeAudioParams{
		MsgID: msgID,
		Peer:  peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesTranscribeAudio")
	}

	resp, ok := responseData.(*MessagesTranscribedAudio)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesTranslateTextParams struct {
	Peer   InputPeer           `tl:"flag:0"`
	ID     []int32             `tl:"flag:0"`
	Text   []*TextWithEntities `tl:"flag:1"`
	ToLang string
}

func (*MessagesTranslateTextParams) CRC() uint32 {
	return 0x63183030
}

func (*MessagesTranslateTextParams) FlagIndex() int {
	return 0
}

// Translate a given text.
func (c *Client) MessagesTranslateText(peer InputPeer, id []int32, text []*TextWithEntities, toLang string) (*MessagesTranslateResult, error) {
	responseData, err := c.MakeRequest(&MessagesTranslateTextParams{
		ID:     id,
		Peer:   peer,
		Text:   text,
		ToLang: toLang,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesTranslateText")
	}

	resp, ok := responseData.(*MessagesTranslateResult)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesUninstallStickerSetParams struct {
	Stickerset InputStickerSet
}

func (*MessagesUninstallStickerSetParams) CRC() uint32 {
	return 0xf96e55de
}

// Uninstall a stickerset
func (c *Client) MessagesUninstallStickerSet(stickerset InputStickerSet) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesUninstallStickerSetParams{Stickerset: stickerset})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesUninstallStickerSet")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesUnpinAllMessagesParams struct {
	Peer     InputPeer
	TopMsgID int32 `tl:"flag:0"`
}

func (*MessagesUnpinAllMessagesParams) CRC() uint32 {
	return 0xee22b9a8
}

func (*MessagesUnpinAllMessagesParams) FlagIndex() int {
	return 0
}

// Unpin all pinned messages
func (c *Client) MessagesUnpinAllMessages(peer InputPeer, topMsgID int32) (*MessagesAffectedHistory, error) {
	responseData, err := c.MakeRequest(&MessagesUnpinAllMessagesParams{
		Peer:     peer,
		TopMsgID: topMsgID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesUnpinAllMessages")
	}

	resp, ok := responseData.(*MessagesAffectedHistory)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesUpdateDialogFilterParams struct {
	ID     int32
	Filter DialogFilter `tl:"flag:0"`
}

func (*MessagesUpdateDialogFilterParams) CRC() uint32 {
	return 0x1ad4a04a
}

func (*MessagesUpdateDialogFilterParams) FlagIndex() int {
	return 0
}

// Update folder
func (c *Client) MessagesUpdateDialogFilter(id int32, filter DialogFilter) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesUpdateDialogFilterParams{
		Filter: filter,
		ID:     id,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesUpdateDialogFilter")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesUpdateDialogFiltersOrderParams struct {
	Order []int32
}

func (*MessagesUpdateDialogFiltersOrderParams) CRC() uint32 {
	return 0xc563c1e4
}

// Reorder folders
func (c *Client) MessagesUpdateDialogFiltersOrder(order []int32) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesUpdateDialogFiltersOrderParams{Order: order})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesUpdateDialogFiltersOrder")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesUpdatePinnedMessageParams struct {
	Silent    bool `tl:"flag:0,encoded_in_bitflags"`
	Unpin     bool `tl:"flag:1,encoded_in_bitflags"`
	PmOneside bool `tl:"flag:2,encoded_in_bitflags"`
	Peer      InputPeer
	ID        int32
}

func (*MessagesUpdatePinnedMessageParams) CRC() uint32 {
	return 0xd2aaf7ec
}

func (*MessagesUpdatePinnedMessageParams) FlagIndex() int {
	return 0
}

// Pin a message
func (c *Client) MessagesUpdatePinnedMessage(params *MessagesUpdatePinnedMessageParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesUpdatePinnedMessage")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesUpdateSavedReactionTagParams struct {
	Reaction Reaction
	Title    string `tl:"flag:0"`
}

func (*MessagesUpdateSavedReactionTagParams) CRC() uint32 {
	return 0x60297dec
}

func (*MessagesUpdateSavedReactionTagParams) FlagIndex() int {
	return 0
}

// Update the description of a saved message tag ».
func (c *Client) MessagesUpdateSavedReactionTag(reaction Reaction, title string) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesUpdateSavedReactionTagParams{
		Reaction: reaction,
		Title:    title,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesUpdateSavedReactionTag")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesUploadEncryptedFileParams struct {
	Peer *InputEncryptedChat
	File InputEncryptedFile
}

func (*MessagesUploadEncryptedFileParams) CRC() uint32 {
	return 0x5057c497
}

// Upload encrypted file and associate it to a secret chat
func (c *Client) MessagesUploadEncryptedFile(peer *InputEncryptedChat, file InputEncryptedFile) (EncryptedFile, error) {
	responseData, err := c.MakeRequest(&MessagesUploadEncryptedFileParams{
		File: file,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesUploadEncryptedFile")
	}

	resp, ok := responseData.(EncryptedFile)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesUploadImportedMediaParams struct {
	Peer     InputPeer
	ImportID int64
	FileName string
	Media    InputMedia
}

func (*MessagesUploadImportedMediaParams) CRC() uint32 {
	return 0x2a862092
}

// Upload a media file associated with an imported chat, click here for more info ».
func (c *Client) MessagesUploadImportedMedia(peer InputPeer, importID int64, fileName string, media InputMedia) (MessageMedia, error) {
	responseData, err := c.MakeRequest(&MessagesUploadImportedMediaParams{
		FileName: fileName,
		ImportID: importID,
		Media:    media,
		Peer:     peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesUploadImportedMedia")
	}

	resp, ok := responseData.(MessageMedia)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesUploadMediaParams struct {
	BusinessConnectionID string `tl:"flag:0"`
	Peer                 InputPeer
	Media                InputMedia
}

func (*MessagesUploadMediaParams) CRC() uint32 {
	return 0x14967978
}

func (*MessagesUploadMediaParams) FlagIndex() int {
	return 0
}

// Upload a file and associate it to a chat (without actually sending it to the chat)
func (c *Client) MessagesUploadMedia(businessConnectionID string, peer InputPeer, media InputMedia) (MessageMedia, error) {
	responseData, err := c.MakeRequest(&MessagesUploadMediaParams{
		BusinessConnectionID: businessConnectionID,
		Media:                media,
		Peer:                 peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending MessagesUploadMedia")
	}

	resp, ok := responseData.(MessageMedia)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type MessagesViewSponsoredMessageParams struct {
	Peer     InputPeer
	RandomID []byte
}

func (*MessagesViewSponsoredMessageParams) CRC() uint32 {
	return 0x673ad8f1
}

// Mark a specific sponsored message » as read
func (c *Client) MessagesViewSponsoredMessage(peer InputPeer, randomID []byte) (bool, error) {
	responseData, err := c.MakeRequest(&MessagesViewSponsoredMessageParams{
		Peer:     peer,
		RandomID: randomID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending MessagesViewSponsoredMessage")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsApplyGiftCodeParams struct {
	Slug string
}

func (*PaymentsApplyGiftCodeParams) CRC() uint32 {
	return 0xf6e26854
}

// Apply a Telegram Premium giftcode »
func (c *Client) PaymentsApplyGiftCode(slug string) (Updates, error) {
	responseData, err := c.MakeRequest(&PaymentsApplyGiftCodeParams{Slug: slug})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsApplyGiftCode")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsAssignAppStoreTransactionParams struct {
	Receipt []byte
	Purpose InputStorePaymentPurpose
}

func (*PaymentsAssignAppStoreTransactionParams) CRC() uint32 {
	return 0x80ed747d
}

// Informs server about a purchase made through the App Store: for official applications only.
func (c *Client) PaymentsAssignAppStoreTransaction(receipt []byte, purpose InputStorePaymentPurpose) (Updates, error) {
	responseData, err := c.MakeRequest(&PaymentsAssignAppStoreTransactionParams{
		Purpose: purpose,
		Receipt: receipt,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsAssignAppStoreTransaction")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsAssignPlayMarketTransactionParams struct {
	Receipt *DataJson
	Purpose InputStorePaymentPurpose
}

func (*PaymentsAssignPlayMarketTransactionParams) CRC() uint32 {
	return 0xdffd50d3
}

// Informs server about a purchase made through the Play Store: for official applications only.
func (c *Client) PaymentsAssignPlayMarketTransaction(receipt *DataJson, purpose InputStorePaymentPurpose) (Updates, error) {
	responseData, err := c.MakeRequest(&PaymentsAssignPlayMarketTransactionParams{
		Purpose: purpose,
		Receipt: receipt,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsAssignPlayMarketTransaction")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsBotCancelStarsSubscriptionParams struct {
	Restore  bool `tl:"flag:0,encoded_in_bitflags"`
	UserID   InputUser
	ChargeID string
}

func (*PaymentsBotCancelStarsSubscriptionParams) CRC() uint32 {
	return 0x6dfa0622
}

func (*PaymentsBotCancelStarsSubscriptionParams) FlagIndex() int {
	return 0
}

// Cancel a bot subscription
func (c *Client) PaymentsBotCancelStarsSubscription(restore bool, userID InputUser, chargeID string) (bool, error) {
	responseData, err := c.MakeRequest(&PaymentsBotCancelStarsSubscriptionParams{
		ChargeID: chargeID,
		Restore:  restore,
		UserID:   userID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending PaymentsBotCancelStarsSubscription")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsCanPurchasePremiumParams struct {
	Purpose InputStorePaymentPurpose
}

func (*PaymentsCanPurchasePremiumParams) CRC() uint32 {
	return 0x9fc19eb6
}

// Checks whether Telegram Premium purchase is possible. Must be called before in-store Premium purchase, official apps only.
func (c *Client) PaymentsCanPurchasePremium(purpose InputStorePaymentPurpose) (bool, error) {
	responseData, err := c.MakeRequest(&PaymentsCanPurchasePremiumParams{Purpose: purpose})
	if err != nil {
		return false, errors.Wrap(err, "sending PaymentsCanPurchasePremium")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsChangeStarsSubscriptionParams struct {
	Peer           InputPeer
	SubscriptionID string
	Canceled       bool `tl:"flag:0"`
}

func (*PaymentsChangeStarsSubscriptionParams) CRC() uint32 {
	return 0xc7770878
}

func (*PaymentsChangeStarsSubscriptionParams) FlagIndex() int {
	return 0
}

// Activate or deactivate a Telegram Star subscription ».
func (c *Client) PaymentsChangeStarsSubscription(peer InputPeer, subscriptionID string, canceled bool) (bool, error) {
	responseData, err := c.MakeRequest(&PaymentsChangeStarsSubscriptionParams{
		Canceled:       canceled,
		Peer:           peer,
		SubscriptionID: subscriptionID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending PaymentsChangeStarsSubscription")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsCheckGiftCodeParams struct {
	Slug string
}

func (*PaymentsCheckGiftCodeParams) CRC() uint32 {
	return 0x8e51b4c1
}

// Obtain information about a Telegram Premium giftcode »
func (c *Client) PaymentsCheckGiftCode(slug string) (*PaymentsCheckedGiftCode, error) {
	responseData, err := c.MakeRequest(&PaymentsCheckGiftCodeParams{Slug: slug})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsCheckGiftCode")
	}

	resp, ok := responseData.(*PaymentsCheckedGiftCode)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsClearSavedInfoParams struct {
	Credentials bool `tl:"flag:0,encoded_in_bitflags"`
	Info        bool `tl:"flag:1,encoded_in_bitflags"`
}

func (*PaymentsClearSavedInfoParams) CRC() uint32 {
	return 0xd83d70c1
}

func (*PaymentsClearSavedInfoParams) FlagIndex() int {
	return 0
}

// Clear saved payment information
func (c *Client) PaymentsClearSavedInfo(credentials, info bool) (bool, error) {
	responseData, err := c.MakeRequest(&PaymentsClearSavedInfoParams{
		Credentials: credentials,
		Info:        info,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending PaymentsClearSavedInfo")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsConnectStarRefBotParams struct {
	Peer InputPeer
	Bot  InputUser
}

func (*PaymentsConnectStarRefBotParams) CRC() uint32 {
	return 0x7ed5348a
}

// Join a bot's affiliate program, becoming an affiliate »
func (c *Client) PaymentsConnectStarRefBot(peer InputPeer, bot InputUser) (*PaymentsConnectedStarRefBots, error) {
	responseData, err := c.MakeRequest(&PaymentsConnectStarRefBotParams{
		Bot:  bot,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsConnectStarRefBot")
	}

	resp, ok := responseData.(*PaymentsConnectedStarRefBots)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsConvertStarGiftParams struct {
	Stargift InputSavedStarGift
}

func (*PaymentsConvertStarGiftParams) CRC() uint32 {
	return 0x74bf076b
}

// Convert a received gift » into Telegram Stars: this will permanently destroy the gift, converting it into starGift.`convert_stars` Telegram Stars, added to the user's balance.
func (c *Client) PaymentsConvertStarGift(stargift InputSavedStarGift) (bool, error) {
	responseData, err := c.MakeRequest(&PaymentsConvertStarGiftParams{Stargift: stargift})
	if err != nil {
		return false, errors.Wrap(err, "sending PaymentsConvertStarGift")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsEditConnectedStarRefBotParams struct {
	Revoked bool `tl:"flag:0,encoded_in_bitflags"`
	Peer    InputPeer
	Link    string
}

func (*PaymentsEditConnectedStarRefBotParams) CRC() uint32 {
	return 0xe4fca4a3
}

func (*PaymentsEditConnectedStarRefBotParams) FlagIndex() int {
	return 0
}

// Leave a bot's affiliate program »
func (c *Client) PaymentsEditConnectedStarRefBot(revoked bool, peer InputPeer, link string) (*PaymentsConnectedStarRefBots, error) {
	responseData, err := c.MakeRequest(&PaymentsEditConnectedStarRefBotParams{
		Link:    link,
		Peer:    peer,
		Revoked: revoked,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsEditConnectedStarRefBot")
	}

	resp, ok := responseData.(*PaymentsConnectedStarRefBots)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsExportInvoiceParams struct {
	InvoiceMedia InputMedia
}

func (*PaymentsExportInvoiceParams) CRC() uint32 {
	return 0xf91b065
}

// Generate an invoice deep link
func (c *Client) PaymentsExportInvoice(invoiceMedia InputMedia) (*PaymentsExportedInvoice, error) {
	responseData, err := c.MakeRequest(&PaymentsExportInvoiceParams{InvoiceMedia: invoiceMedia})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsExportInvoice")
	}

	resp, ok := responseData.(*PaymentsExportedInvoice)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsFulfillStarsSubscriptionParams struct {
	Peer           InputPeer
	SubscriptionID string
}

func (*PaymentsFulfillStarsSubscriptionParams) CRC() uint32 {
	return 0xcc5bebb3
}

// Re-join a private channel associated to an active Telegram Star subscription ».
func (c *Client) PaymentsFulfillStarsSubscription(peer InputPeer, subscriptionID string) (bool, error) {
	responseData, err := c.MakeRequest(&PaymentsFulfillStarsSubscriptionParams{
		Peer:           peer,
		SubscriptionID: subscriptionID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending PaymentsFulfillStarsSubscription")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetBankCardDataParams struct {
	Number string
}

func (*PaymentsGetBankCardDataParams) CRC() uint32 {
	return 0x2e79d779
}

// Get info about a credit card
func (c *Client) PaymentsGetBankCardData(number string) (*PaymentsBankCardData, error) {
	responseData, err := c.MakeRequest(&PaymentsGetBankCardDataParams{Number: number})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetBankCardData")
	}

	resp, ok := responseData.(*PaymentsBankCardData)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetConnectedStarRefBotParams struct {
	Peer InputPeer
	Bot  InputUser
}

func (*PaymentsGetConnectedStarRefBotParams) CRC() uint32 {
	return 0xb7d998f0
}

// Fetch info about a specific bot affiliation »
func (c *Client) PaymentsGetConnectedStarRefBot(peer InputPeer, bot InputUser) (*PaymentsConnectedStarRefBots, error) {
	responseData, err := c.MakeRequest(&PaymentsGetConnectedStarRefBotParams{
		Bot:  bot,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetConnectedStarRefBot")
	}

	resp, ok := responseData.(*PaymentsConnectedStarRefBots)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetConnectedStarRefBotsParams struct {
	Peer       InputPeer
	OffsetDate int32  `tl:"flag:2"`
	OffsetLink string `tl:"flag:2"`
	Limit      int32
}

func (*PaymentsGetConnectedStarRefBotsParams) CRC() uint32 {
	return 0x5869a553
}

func (*PaymentsGetConnectedStarRefBotsParams) FlagIndex() int {
	return 0
}

// Fetch all affiliations we have created for a certain peer
func (c *Client) PaymentsGetConnectedStarRefBots(peer InputPeer, offsetDate int32, offsetLink string, limit int32) (*PaymentsConnectedStarRefBots, error) {
	responseData, err := c.MakeRequest(&PaymentsGetConnectedStarRefBotsParams{
		Limit:      limit,
		OffsetDate: offsetDate,
		OffsetLink: offsetLink,
		Peer:       peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetConnectedStarRefBots")
	}

	resp, ok := responseData.(*PaymentsConnectedStarRefBots)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetGiveawayInfoParams struct {
	Peer  InputPeer
	MsgID int32
}

func (*PaymentsGetGiveawayInfoParams) CRC() uint32 {
	return 0xf4239425
}

// Obtain information about a Telegram Premium giveaway ».
func (c *Client) PaymentsGetGiveawayInfo(peer InputPeer, msgID int32) (PaymentsGiveawayInfo, error) {
	responseData, err := c.MakeRequest(&PaymentsGetGiveawayInfoParams{
		MsgID: msgID,
		Peer:  peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetGiveawayInfo")
	}

	resp, ok := responseData.(PaymentsGiveawayInfo)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetPaymentFormParams struct {
	Invoice     InputInvoice
	ThemeParams *DataJson `tl:"flag:0"`
}

func (*PaymentsGetPaymentFormParams) CRC() uint32 {
	return 0x37148dbb
}

func (*PaymentsGetPaymentFormParams) FlagIndex() int {
	return 0
}

// Get a payment form
func (c *Client) PaymentsGetPaymentForm(invoice InputInvoice, themeParams *DataJson) (PaymentsPaymentForm, error) {
	responseData, err := c.MakeRequest(&PaymentsGetPaymentFormParams{
		Invoice:     invoice,
		ThemeParams: themeParams,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetPaymentForm")
	}

	resp, ok := responseData.(PaymentsPaymentForm)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetPaymentReceiptParams struct {
	Peer  InputPeer
	MsgID int32
}

func (*PaymentsGetPaymentReceiptParams) CRC() uint32 {
	return 0x2478d1cc
}

// Get payment receipt
func (c *Client) PaymentsGetPaymentReceipt(peer InputPeer, msgID int32) (PaymentsPaymentReceipt, error) {
	responseData, err := c.MakeRequest(&PaymentsGetPaymentReceiptParams{
		MsgID: msgID,
		Peer:  peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetPaymentReceipt")
	}

	resp, ok := responseData.(PaymentsPaymentReceipt)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetPremiumGiftCodeOptionsParams struct {
	BoostPeer InputPeer `tl:"flag:0"`
}

func (*PaymentsGetPremiumGiftCodeOptionsParams) CRC() uint32 {
	return 0x2757ba54
}

func (*PaymentsGetPremiumGiftCodeOptionsParams) FlagIndex() int {
	return 0
}

// Obtain a list of Telegram Premium giveaway/gift code » options.
func (c *Client) PaymentsGetPremiumGiftCodeOptions(boostPeer InputPeer) ([]*PremiumGiftCodeOption, error) {
	responseData, err := c.MakeRequest(&PaymentsGetPremiumGiftCodeOptionsParams{BoostPeer: boostPeer})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetPremiumGiftCodeOptions")
	}

	resp, ok := responseData.([]*PremiumGiftCodeOption)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetSavedInfoParams struct{}

func (*PaymentsGetSavedInfoParams) CRC() uint32 {
	return 0x227d824b
}

// Get saved payment information
func (c *Client) PaymentsGetSavedInfo() (*PaymentsSavedInfo, error) {
	responseData, err := c.MakeRequest(&PaymentsGetSavedInfoParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetSavedInfo")
	}

	resp, ok := responseData.(*PaymentsSavedInfo)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetSavedStarGiftParams struct {
	Stargift []InputSavedStarGift
}

func (*PaymentsGetSavedStarGiftParams) CRC() uint32 {
	return 0xb455a106
}

func (c *Client) PaymentsGetSavedStarGift(stargift []InputSavedStarGift) (*PaymentsSavedStarGifts, error) {
	responseData, err := c.MakeRequest(&PaymentsGetSavedStarGiftParams{Stargift: stargift})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetSavedStarGift")
	}

	resp, ok := responseData.(*PaymentsSavedStarGifts)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetSavedStarGiftsParams struct {
	ExcludeUnsaved   bool `tl:"flag:0,encoded_in_bitflags"`
	ExcludeSaved     bool `tl:"flag:1,encoded_in_bitflags"`
	ExcludeUnlimited bool `tl:"flag:2,encoded_in_bitflags"`
	ExcludeLimited   bool `tl:"flag:3,encoded_in_bitflags"`
	ExcludeUnique    bool `tl:"flag:4,encoded_in_bitflags"`
	SortByValue      bool `tl:"flag:5,encoded_in_bitflags"`
	Peer             InputPeer
	Offset           string
	Limit            int32
}

func (*PaymentsGetSavedStarGiftsParams) CRC() uint32 {
	return 0x23830de9
}

func (*PaymentsGetSavedStarGiftsParams) FlagIndex() int {
	return 0
}

func (c *Client) PaymentsGetSavedStarGifts(params *PaymentsGetSavedStarGiftsParams) (*PaymentsSavedStarGifts, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetSavedStarGifts")
	}

	resp, ok := responseData.(*PaymentsSavedStarGifts)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetStarGiftUpgradePreviewParams struct {
	GiftID int64
}

func (*PaymentsGetStarGiftUpgradePreviewParams) CRC() uint32 {
	return 0x9c9abcb1
}

func (c *Client) PaymentsGetStarGiftUpgradePreview(giftID int64) (*PaymentsStarGiftUpgradePreview, error) {
	responseData, err := c.MakeRequest(&PaymentsGetStarGiftUpgradePreviewParams{GiftID: giftID})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetStarGiftUpgradePreview")
	}

	resp, ok := responseData.(*PaymentsStarGiftUpgradePreview)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetStarGiftWithdrawalURLParams struct {
	Stargift InputSavedStarGift
	Password InputCheckPasswordSRP
}

func (*PaymentsGetStarGiftWithdrawalURLParams) CRC() uint32 {
	return 0xd06e93a8
}

func (c *Client) PaymentsGetStarGiftWithdrawalURL(stargift InputSavedStarGift, password InputCheckPasswordSRP) (*PaymentsStarGiftWithdrawalURL, error) {
	responseData, err := c.MakeRequest(&PaymentsGetStarGiftWithdrawalURLParams{
		Password: password,
		Stargift: stargift,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetStarGiftWithdrawalURL")
	}

	resp, ok := responseData.(*PaymentsStarGiftWithdrawalURL)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetStarGiftsParams struct {
	Hash int32
}

func (*PaymentsGetStarGiftsParams) CRC() uint32 {
	return 0xc4563590
}

// Get a list of available gifts, see here » for more info.
func (c *Client) PaymentsGetStarGifts(hash int32) (PaymentsStarGifts, error) {
	responseData, err := c.MakeRequest(&PaymentsGetStarGiftsParams{Hash: hash})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetStarGifts")
	}

	resp, ok := responseData.(PaymentsStarGifts)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetStarsGiftOptionsParams struct {
	UserID InputUser `tl:"flag:0"`
}

func (*PaymentsGetStarsGiftOptionsParams) CRC() uint32 {
	return 0xd3c96bc8
}

func (*PaymentsGetStarsGiftOptionsParams) FlagIndex() int {
	return 0
}

// Obtain a list of Telegram Stars gift options » as starsGiftOption constructors.
func (c *Client) PaymentsGetStarsGiftOptions(userID InputUser) ([]*StarsGiftOption, error) {
	responseData, err := c.MakeRequest(&PaymentsGetStarsGiftOptionsParams{UserID: userID})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetStarsGiftOptions")
	}

	resp, ok := responseData.([]*StarsGiftOption)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetStarsGiveawayOptionsParams struct{}

func (*PaymentsGetStarsGiveawayOptionsParams) CRC() uint32 {
	return 0xbd1efd3e
}

// Fetch a list of star giveaway options ».
func (c *Client) PaymentsGetStarsGiveawayOptions() ([]*StarsGiveawayOption, error) {
	responseData, err := c.MakeRequest(&PaymentsGetStarsGiveawayOptionsParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetStarsGiveawayOptions")
	}

	resp, ok := responseData.([]*StarsGiveawayOption)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetStarsRevenueAdsAccountURLParams struct {
	Peer InputPeer
}

func (*PaymentsGetStarsRevenueAdsAccountURLParams) CRC() uint32 {
	return 0xd1d7efc5
}

// Returns a URL for a Telegram Ad platform account that can be used to set up advertisements for channel/bot in `peer`, paid using the Telegram Stars owned by the specified `peer`, see here » for more info.
func (c *Client) PaymentsGetStarsRevenueAdsAccountURL(peer InputPeer) (*PaymentsStarsRevenueAdsAccountURL, error) {
	responseData, err := c.MakeRequest(&PaymentsGetStarsRevenueAdsAccountURLParams{Peer: peer})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetStarsRevenueAdsAccountURL")
	}

	resp, ok := responseData.(*PaymentsStarsRevenueAdsAccountURL)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetStarsRevenueStatsParams struct {
	Dark bool `tl:"flag:0,encoded_in_bitflags"`
	Peer InputPeer
}

func (*PaymentsGetStarsRevenueStatsParams) CRC() uint32 {
	return 0xd91ffad6
}

func (*PaymentsGetStarsRevenueStatsParams) FlagIndex() int {
	return 0
}

// Get Telegram Star revenue statistics ».
func (c *Client) PaymentsGetStarsRevenueStats(dark bool, peer InputPeer) (*PaymentsStarsRevenueStats, error) {
	responseData, err := c.MakeRequest(&PaymentsGetStarsRevenueStatsParams{
		Dark: dark,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetStarsRevenueStats")
	}

	resp, ok := responseData.(*PaymentsStarsRevenueStats)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetStarsRevenueWithdrawalURLParams struct {
	Peer     InputPeer
	Stars    int64
	Password InputCheckPasswordSRP
}

func (*PaymentsGetStarsRevenueWithdrawalURLParams) CRC() uint32 {
	return 0x13bbe8b3
}

// Withdraw funds from a channel or bot's star balance ».
func (c *Client) PaymentsGetStarsRevenueWithdrawalURL(peer InputPeer, stars int64, password InputCheckPasswordSRP) (*PaymentsStarsRevenueWithdrawalURL, error) {
	responseData, err := c.MakeRequest(&PaymentsGetStarsRevenueWithdrawalURLParams{
		Password: password,
		Peer:     peer,
		Stars:    stars,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetStarsRevenueWithdrawalURL")
	}

	resp, ok := responseData.(*PaymentsStarsRevenueWithdrawalURL)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetStarsStatusParams struct {
	Peer InputPeer
}

func (*PaymentsGetStarsStatusParams) CRC() uint32 {
	return 0x104fcfa7
}

// Get the current Telegram Stars balance of the current account (with peer=inputPeerSelf), or the stars balance of the bot specified in `peer`.
func (c *Client) PaymentsGetStarsStatus(peer InputPeer) (*PaymentsStarsStatus, error) {
	responseData, err := c.MakeRequest(&PaymentsGetStarsStatusParams{Peer: peer})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetStarsStatus")
	}

	resp, ok := responseData.(*PaymentsStarsStatus)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetStarsSubscriptionsParams struct {
	MissingBalance bool `tl:"flag:0,encoded_in_bitflags"`
	Peer           InputPeer
	Offset         string
}

func (*PaymentsGetStarsSubscriptionsParams) CRC() uint32 {
	return 0x32512c5
}

func (*PaymentsGetStarsSubscriptionsParams) FlagIndex() int {
	return 0
}

// Obtain a list of active, expired or cancelled Telegram Star subscriptions ».
func (c *Client) PaymentsGetStarsSubscriptions(missingBalance bool, peer InputPeer, offset string) (*PaymentsStarsStatus, error) {
	responseData, err := c.MakeRequest(&PaymentsGetStarsSubscriptionsParams{
		MissingBalance: missingBalance,
		Offset:         offset,
		Peer:           peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetStarsSubscriptions")
	}

	resp, ok := responseData.(*PaymentsStarsStatus)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetStarsTopupOptionsParams struct{}

func (*PaymentsGetStarsTopupOptionsParams) CRC() uint32 {
	return 0xc00ec7d3
}

// Obtain a list of Telegram Stars topup options » as starsTopupOption constructors.
func (c *Client) PaymentsGetStarsTopupOptions() ([]*StarsTopupOption, error) {
	responseData, err := c.MakeRequest(&PaymentsGetStarsTopupOptionsParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetStarsTopupOptions")
	}

	resp, ok := responseData.([]*StarsTopupOption)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetStarsTransactionsParams struct {
	Inbound        bool   `tl:"flag:0,encoded_in_bitflags"`
	Outbound       bool   `tl:"flag:1,encoded_in_bitflags"`
	Ascending      bool   `tl:"flag:2,encoded_in_bitflags"`
	SubscriptionID string `tl:"flag:3"`
	Peer           InputPeer
	Offset         string
	Limit          int32
}

func (*PaymentsGetStarsTransactionsParams) CRC() uint32 {
	return 0x69da4557
}

func (*PaymentsGetStarsTransactionsParams) FlagIndex() int {
	return 0
}

// Fetch Telegram Stars transactions.
func (c *Client) PaymentsGetStarsTransactions(params *PaymentsGetStarsTransactionsParams) (*PaymentsStarsStatus, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetStarsTransactions")
	}

	resp, ok := responseData.(*PaymentsStarsStatus)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetStarsTransactionsByIDParams struct {
	Peer InputPeer
	ID   []*InputStarsTransaction
}

func (*PaymentsGetStarsTransactionsByIDParams) CRC() uint32 {
	return 0x27842d2e
}

// Obtain info about Telegram Star transactions » using specific transaction IDs.
func (c *Client) PaymentsGetStarsTransactionsByID(peer InputPeer, id []*InputStarsTransaction) (*PaymentsStarsStatus, error) {
	responseData, err := c.MakeRequest(&PaymentsGetStarsTransactionsByIDParams{
		ID:   id,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetStarsTransactionsByID")
	}

	resp, ok := responseData.(*PaymentsStarsStatus)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetSuggestedStarRefBotsParams struct {
	OrderByRevenue bool `tl:"flag:0,encoded_in_bitflags"`
	OrderByDate    bool `tl:"flag:1,encoded_in_bitflags"`
	Peer           InputPeer
	Offset         string
	Limit          int32
}

func (*PaymentsGetSuggestedStarRefBotsParams) CRC() uint32 {
	return 0xd6b48f7
}

func (*PaymentsGetSuggestedStarRefBotsParams) FlagIndex() int {
	return 0
}

// Obtain a list of suggested mini apps with available affiliate programs
func (c *Client) PaymentsGetSuggestedStarRefBots(params *PaymentsGetSuggestedStarRefBotsParams) (*PaymentsSuggestedStarRefBots, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetSuggestedStarRefBots")
	}

	resp, ok := responseData.(*PaymentsSuggestedStarRefBots)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsGetUniqueStarGiftParams struct {
	Slug string
}

func (*PaymentsGetUniqueStarGiftParams) CRC() uint32 {
	return 0xa1974d72
}

func (c *Client) PaymentsGetUniqueStarGift(slug string) (*PaymentsUniqueStarGift, error) {
	responseData, err := c.MakeRequest(&PaymentsGetUniqueStarGiftParams{Slug: slug})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsGetUniqueStarGift")
	}

	resp, ok := responseData.(*PaymentsUniqueStarGift)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsLaunchPrepaidGiveawayParams struct {
	Peer       InputPeer
	GiveawayID int64
	Purpose    InputStorePaymentPurpose
}

func (*PaymentsLaunchPrepaidGiveawayParams) CRC() uint32 {
	return 0x5ff58f20
}

// Launch a prepaid giveaway ».
func (c *Client) PaymentsLaunchPrepaidGiveaway(peer InputPeer, giveawayID int64, purpose InputStorePaymentPurpose) (Updates, error) {
	responseData, err := c.MakeRequest(&PaymentsLaunchPrepaidGiveawayParams{
		GiveawayID: giveawayID,
		Peer:       peer,
		Purpose:    purpose,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsLaunchPrepaidGiveaway")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsRefundStarsChargeParams struct {
	UserID   InputUser
	ChargeID string
}

func (*PaymentsRefundStarsChargeParams) CRC() uint32 {
	return 0x25ae8f4a
}

// Refund a Telegram Stars transaction, see here » for more info.
func (c *Client) PaymentsRefundStarsCharge(userID InputUser, chargeID string) (Updates, error) {
	responseData, err := c.MakeRequest(&PaymentsRefundStarsChargeParams{
		ChargeID: chargeID,
		UserID:   userID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsRefundStarsCharge")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsRequestRecurringPaymentParams struct {
	UserID              InputUser
	RecurringInitCharge string
	InvoiceMedia        InputMedia
}

func (*PaymentsRequestRecurringPaymentParams) CRC() uint32 {
	return 0x146e958d
}

func (c *Client) PaymentsRequestRecurringPayment(userID InputUser, recurringInitCharge string, invoiceMedia InputMedia) (Updates, error) {
	responseData, err := c.MakeRequest(&PaymentsRequestRecurringPaymentParams{
		InvoiceMedia:        invoiceMedia,
		RecurringInitCharge: recurringInitCharge,
		UserID:              userID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsRequestRecurringPayment")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsSaveStarGiftParams struct {
	Unsave   bool `tl:"flag:0,encoded_in_bitflags"`
	Stargift InputSavedStarGift
}

func (*PaymentsSaveStarGiftParams) CRC() uint32 {
	return 0x2a2a697c
}

func (*PaymentsSaveStarGiftParams) FlagIndex() int {
	return 0
}

// Display or remove a received gift » from our profile.
func (c *Client) PaymentsSaveStarGift(unsave bool, stargift InputSavedStarGift) (bool, error) {
	responseData, err := c.MakeRequest(&PaymentsSaveStarGiftParams{
		Stargift: stargift,
		Unsave:   unsave,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending PaymentsSaveStarGift")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsSendPaymentFormParams struct {
	FormID           int64
	Invoice          InputInvoice
	RequestedInfoID  string `tl:"flag:0"`
	ShippingOptionID string `tl:"flag:1"`
	Credentials      InputPaymentCredentials
	TipAmount        int64 `tl:"flag:2"`
}

func (*PaymentsSendPaymentFormParams) CRC() uint32 {
	return 0x2d03522f
}

func (*PaymentsSendPaymentFormParams) FlagIndex() int {
	return 0
}

// Send compiled payment form
func (c *Client) PaymentsSendPaymentForm(params *PaymentsSendPaymentFormParams) (PaymentsPaymentResult, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsSendPaymentForm")
	}

	resp, ok := responseData.(PaymentsPaymentResult)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsSendStarsFormParams struct {
	FormID  int64
	Invoice InputInvoice
}

func (*PaymentsSendStarsFormParams) CRC() uint32 {
	return 0x7998c914
}

// Make a payment using Telegram Stars, see here » for more info.
func (c *Client) PaymentsSendStarsForm(formID int64, invoice InputInvoice) (PaymentsPaymentResult, error) {
	responseData, err := c.MakeRequest(&PaymentsSendStarsFormParams{
		FormID:  formID,
		Invoice: invoice,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsSendStarsForm")
	}

	resp, ok := responseData.(PaymentsPaymentResult)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsToggleChatStarGiftNotificationsParams struct {
	Enabled bool `tl:"flag:0,encoded_in_bitflags"`
	Peer    InputPeer
}

func (*PaymentsToggleChatStarGiftNotificationsParams) CRC() uint32 {
	return 0x60eaefa1
}

func (*PaymentsToggleChatStarGiftNotificationsParams) FlagIndex() int {
	return 0
}

func (c *Client) PaymentsToggleChatStarGiftNotifications(enabled bool, peer InputPeer) (bool, error) {
	responseData, err := c.MakeRequest(&PaymentsToggleChatStarGiftNotificationsParams{
		Enabled: enabled,
		Peer:    peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending PaymentsToggleChatStarGiftNotifications")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsTransferStarGiftParams struct {
	Stargift InputSavedStarGift
	ToID     InputPeer
}

func (*PaymentsTransferStarGiftParams) CRC() uint32 {
	return 0x7f18176a
}

func (c *Client) PaymentsTransferStarGift(stargift InputSavedStarGift, toID InputPeer) (Updates, error) {
	responseData, err := c.MakeRequest(&PaymentsTransferStarGiftParams{
		Stargift: stargift,
		ToID:     toID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsTransferStarGift")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsUpgradeStarGiftParams struct {
	KeepOriginalDetails bool `tl:"flag:0,encoded_in_bitflags"`
	Stargift            InputSavedStarGift
}

func (*PaymentsUpgradeStarGiftParams) CRC() uint32 {
	return 0xaed6e4f5
}

func (*PaymentsUpgradeStarGiftParams) FlagIndex() int {
	return 0
}

func (c *Client) PaymentsUpgradeStarGift(keepOriginalDetails bool, stargift InputSavedStarGift) (Updates, error) {
	responseData, err := c.MakeRequest(&PaymentsUpgradeStarGiftParams{
		KeepOriginalDetails: keepOriginalDetails,
		Stargift:            stargift,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsUpgradeStarGift")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PaymentsValidateRequestedInfoParams struct {
	Save    bool `tl:"flag:0,encoded_in_bitflags"`
	Invoice InputInvoice
	Info    *PaymentRequestedInfo
}

func (*PaymentsValidateRequestedInfoParams) CRC() uint32 {
	return 0xb6c8f12b
}

func (*PaymentsValidateRequestedInfoParams) FlagIndex() int {
	return 0
}

// Submit requested order information for validation
func (c *Client) PaymentsValidateRequestedInfo(save bool, invoice InputInvoice, info *PaymentRequestedInfo) (*PaymentsValidatedRequestedInfo, error) {
	responseData, err := c.MakeRequest(&PaymentsValidateRequestedInfoParams{
		Info:    info,
		Invoice: invoice,
		Save:    save,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PaymentsValidateRequestedInfo")
	}

	resp, ok := responseData.(*PaymentsValidatedRequestedInfo)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneAcceptCallParams struct {
	Peer     *InputPhoneCall
	GB       []byte
	Protocol *PhoneCallProtocol
}

func (*PhoneAcceptCallParams) CRC() uint32 {
	return 0x3bd2b4a0
}

// Accept incoming call
func (c *Client) PhoneAcceptCall(peer *InputPhoneCall, gB []byte, protocol *PhoneCallProtocol) (*PhonePhoneCall, error) {
	responseData, err := c.MakeRequest(&PhoneAcceptCallParams{
		GB:       gB,
		Peer:     peer,
		Protocol: protocol,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneAcceptCall")
	}

	resp, ok := responseData.(*PhonePhoneCall)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneCheckGroupCallParams struct {
	Call    *InputGroupCall
	Sources []int32
}

func (*PhoneCheckGroupCallParams) CRC() uint32 {
	return 0xb59cf977
}

/*
Check whether the group call Server Forwarding Unit is currently receiving the streams with the specified WebRTC source IDs.<br>
Returns an intersection of the source IDs specified in `sources`, and the source IDs currently being forwarded by the SFU.
*/
func (c *Client) PhoneCheckGroupCall(call *InputGroupCall, sources []int32) ([]int32, error) {
	responseData, err := c.MakeRequest(&PhoneCheckGroupCallParams{
		Call:    call,
		Sources: sources,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneCheckGroupCall")
	}

	resp, ok := responseData.([]int32)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneConfirmCallParams struct {
	Peer           *InputPhoneCall
	GA             []byte
	KeyFingerprint int64
	Protocol       *PhoneCallProtocol
}

func (*PhoneConfirmCallParams) CRC() uint32 {
	return 0x2efe1722
}

// Complete phone call E2E encryption key exchange »
func (c *Client) PhoneConfirmCall(peer *InputPhoneCall, gA []byte, keyFingerprint int64, protocol *PhoneCallProtocol) (*PhonePhoneCall, error) {
	responseData, err := c.MakeRequest(&PhoneConfirmCallParams{
		GA:             gA,
		KeyFingerprint: keyFingerprint,
		Peer:           peer,
		Protocol:       protocol,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneConfirmCall")
	}

	resp, ok := responseData.(*PhonePhoneCall)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneCreateConferenceCallParams struct {
	Peer           *InputPhoneCall
	KeyFingerprint int64
}

func (*PhoneCreateConferenceCallParams) CRC() uint32 {
	return 0xdfc909ab
}

func (c *Client) PhoneCreateConferenceCall(peer *InputPhoneCall, keyFingerprint int64) (*PhonePhoneCall, error) {
	responseData, err := c.MakeRequest(&PhoneCreateConferenceCallParams{
		KeyFingerprint: keyFingerprint,
		Peer:           peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneCreateConferenceCall")
	}

	resp, ok := responseData.(*PhonePhoneCall)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneCreateGroupCallParams struct {
	RtmpStream   bool `tl:"flag:2,encoded_in_bitflags"`
	Peer         InputPeer
	RandomID     int32
	Title        string `tl:"flag:0"`
	ScheduleDate int32  `tl:"flag:1"`
}

func (*PhoneCreateGroupCallParams) CRC() uint32 {
	return 0x48cdc6d8
}

func (*PhoneCreateGroupCallParams) FlagIndex() int {
	return 0
}

// Create a group call or livestream
func (c *Client) PhoneCreateGroupCall(params *PhoneCreateGroupCallParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneCreateGroupCall")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneDiscardCallParams struct {
	Video        bool `tl:"flag:0,encoded_in_bitflags"`
	Peer         *InputPhoneCall
	Duration     int32
	Reason       PhoneCallDiscardReason
	ConnectionID int64
}

func (*PhoneDiscardCallParams) CRC() uint32 {
	return 0xb2cbc1c0
}

func (*PhoneDiscardCallParams) FlagIndex() int {
	return 0
}

// Refuse or end running call
func (c *Client) PhoneDiscardCall(params *PhoneDiscardCallParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneDiscardCall")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneDiscardGroupCallParams struct {
	Call *InputGroupCall
}

func (*PhoneDiscardGroupCallParams) CRC() uint32 {
	return 0x7a777135
}

// Terminate a group call
func (c *Client) PhoneDiscardGroupCall(call *InputGroupCall) (Updates, error) {
	responseData, err := c.MakeRequest(&PhoneDiscardGroupCallParams{Call: call})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneDiscardGroupCall")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneEditGroupCallParticipantParams struct {
	Call               *InputGroupCall
	Participant        InputPeer
	Muted              bool  `tl:"flag:0"`
	Volume             int32 `tl:"flag:1"`
	RaiseHand          bool  `tl:"flag:2"`
	VideoStopped       bool  `tl:"flag:3"`
	VideoPaused        bool  `tl:"flag:4"`
	PresentationPaused bool  `tl:"flag:5"`
}

func (*PhoneEditGroupCallParticipantParams) CRC() uint32 {
	return 0xa5273abf
}

func (*PhoneEditGroupCallParticipantParams) FlagIndex() int {
	return 0
}

// Edit information about a given group call participant
func (c *Client) PhoneEditGroupCallParticipant(params *PhoneEditGroupCallParticipantParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneEditGroupCallParticipant")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneEditGroupCallTitleParams struct {
	Call  *InputGroupCall
	Title string
}

func (*PhoneEditGroupCallTitleParams) CRC() uint32 {
	return 0x1ca6ac0a
}

// Edit the title of a group call or livestream
func (c *Client) PhoneEditGroupCallTitle(call *InputGroupCall, title string) (Updates, error) {
	responseData, err := c.MakeRequest(&PhoneEditGroupCallTitleParams{
		Call:  call,
		Title: title,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneEditGroupCallTitle")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneExportGroupCallInviteParams struct {
	CanSelfUnmute bool `tl:"flag:0,encoded_in_bitflags"`
	Call          *InputGroupCall
}

func (*PhoneExportGroupCallInviteParams) CRC() uint32 {
	return 0xe6aa647f
}

func (*PhoneExportGroupCallInviteParams) FlagIndex() int {
	return 0
}

// Get an invite link for a group call or livestream
func (c *Client) PhoneExportGroupCallInvite(canSelfUnmute bool, call *InputGroupCall) (*PhoneExportedGroupCallInvite, error) {
	responseData, err := c.MakeRequest(&PhoneExportGroupCallInviteParams{
		Call:          call,
		CanSelfUnmute: canSelfUnmute,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneExportGroupCallInvite")
	}

	resp, ok := responseData.(*PhoneExportedGroupCallInvite)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneGetCallConfigParams struct{}

func (*PhoneGetCallConfigParams) CRC() uint32 {
	return 0x55451fa9
}

// Get phone call configuration to be passed to libtgvoip's shared config
func (c *Client) PhoneGetCallConfig() (*DataJson, error) {
	responseData, err := c.MakeRequest(&PhoneGetCallConfigParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneGetCallConfig")
	}

	resp, ok := responseData.(*DataJson)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneGetGroupCallParams struct {
	Call  *InputGroupCall
	Limit int32
}

func (*PhoneGetGroupCallParams) CRC() uint32 {
	return 0x41845db
}

// Get info about a group call
func (c *Client) PhoneGetGroupCall(call *InputGroupCall, limit int32) (*PhoneGroupCall, error) {
	responseData, err := c.MakeRequest(&PhoneGetGroupCallParams{
		Call:  call,
		Limit: limit,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneGetGroupCall")
	}

	resp, ok := responseData.(*PhoneGroupCall)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneGetGroupCallJoinAsParams struct {
	Peer InputPeer
}

func (*PhoneGetGroupCallJoinAsParams) CRC() uint32 {
	return 0xef7c213a
}

// Get a list of peers that can be used to join a group call, presenting yourself as a specific user/channel.
func (c *Client) PhoneGetGroupCallJoinAs(peer InputPeer) (*PhoneJoinAsPeers, error) {
	responseData, err := c.MakeRequest(&PhoneGetGroupCallJoinAsParams{Peer: peer})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneGetGroupCallJoinAs")
	}

	resp, ok := responseData.(*PhoneJoinAsPeers)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneGetGroupCallStreamChannelsParams struct {
	Call *InputGroupCall
}

func (*PhoneGetGroupCallStreamChannelsParams) CRC() uint32 {
	return 0x1ab21940
}

/*
Get info about RTMP streams in a group call or livestream.<br>
This method should be invoked to the same group/channel-related DC used for downloading livestream chunks.<br>
As usual, the media DC is preferred, if available.
*/
func (c *Client) PhoneGetGroupCallStreamChannels(call *InputGroupCall) (*PhoneGroupCallStreamChannels, error) {
	responseData, err := c.MakeRequest(&PhoneGetGroupCallStreamChannelsParams{Call: call})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneGetGroupCallStreamChannels")
	}

	resp, ok := responseData.(*PhoneGroupCallStreamChannels)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneGetGroupCallStreamRtmpURLParams struct {
	Peer   InputPeer
	Revoke bool
}

func (*PhoneGetGroupCallStreamRtmpURLParams) CRC() uint32 {
	return 0xdeb3abbf
}

// Get RTMP URL and stream key for RTMP livestreams. Can be used even before creating the actual RTMP livestream with phone.createGroupCall (the `rtmp_stream` flag must be set).
func (c *Client) PhoneGetGroupCallStreamRtmpURL(peer InputPeer, revoke bool) (*PhoneGroupCallStreamRtmpURL, error) {
	responseData, err := c.MakeRequest(&PhoneGetGroupCallStreamRtmpURLParams{
		Peer:   peer,
		Revoke: revoke,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneGetGroupCallStreamRtmpURL")
	}

	resp, ok := responseData.(*PhoneGroupCallStreamRtmpURL)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneGetGroupParticipantsParams struct {
	Call    *InputGroupCall
	Ids     []InputPeer
	Sources []int32
	Offset  string
	Limit   int32
}

func (*PhoneGetGroupParticipantsParams) CRC() uint32 {
	return 0xc558d8ab
}

// Get group call participants
func (c *Client) PhoneGetGroupParticipants(call *InputGroupCall, ids []InputPeer, sources []int32, offset string, limit int32) (*PhoneGroupParticipants, error) {
	responseData, err := c.MakeRequest(&PhoneGetGroupParticipantsParams{
		Call:    call,
		Ids:     ids,
		Limit:   limit,
		Offset:  offset,
		Sources: sources,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneGetGroupParticipants")
	}

	resp, ok := responseData.(*PhoneGroupParticipants)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneInviteToGroupCallParams struct {
	Call  *InputGroupCall
	Users []InputUser
}

func (*PhoneInviteToGroupCallParams) CRC() uint32 {
	return 0x7b393160
}

// Invite a set of users to a group call.
func (c *Client) PhoneInviteToGroupCall(call *InputGroupCall, users []InputUser) (Updates, error) {
	responseData, err := c.MakeRequest(&PhoneInviteToGroupCallParams{
		Call:  call,
		Users: users,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneInviteToGroupCall")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneJoinGroupCallParams struct {
	Muted          bool `tl:"flag:0,encoded_in_bitflags"`
	VideoStopped   bool `tl:"flag:2,encoded_in_bitflags"`
	Call           *InputGroupCall
	JoinAs         InputPeer
	InviteHash     string `tl:"flag:1"`
	KeyFingerprint int64  `tl:"flag:3"`
	Params         *DataJson
}

func (*PhoneJoinGroupCallParams) CRC() uint32 {
	return 0xd61e1df3
}

func (*PhoneJoinGroupCallParams) FlagIndex() int {
	return 0
}

// Join a group call
func (c *Client) PhoneJoinGroupCall(params *PhoneJoinGroupCallParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneJoinGroupCall")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneJoinGroupCallPresentationParams struct {
	Call   *InputGroupCall
	Params *DataJson
}

func (*PhoneJoinGroupCallPresentationParams) CRC() uint32 {
	return 0xcbea6bc4
}

// Start screen sharing in a call
func (c *Client) PhoneJoinGroupCallPresentation(call *InputGroupCall, params *DataJson) (Updates, error) {
	responseData, err := c.MakeRequest(&PhoneJoinGroupCallPresentationParams{
		Call:   call,
		Params: params,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneJoinGroupCallPresentation")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneLeaveGroupCallParams struct {
	Call   *InputGroupCall
	Source int32
}

func (*PhoneLeaveGroupCallParams) CRC() uint32 {
	return 0x500377f9
}

// Leave a group call
func (c *Client) PhoneLeaveGroupCall(call *InputGroupCall, source int32) (Updates, error) {
	responseData, err := c.MakeRequest(&PhoneLeaveGroupCallParams{
		Call:   call,
		Source: source,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneLeaveGroupCall")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneLeaveGroupCallPresentationParams struct {
	Call *InputGroupCall
}

func (*PhoneLeaveGroupCallPresentationParams) CRC() uint32 {
	return 0x1c50d144
}

// Stop screen sharing in a group call
func (c *Client) PhoneLeaveGroupCallPresentation(call *InputGroupCall) (Updates, error) {
	responseData, err := c.MakeRequest(&PhoneLeaveGroupCallPresentationParams{Call: call})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneLeaveGroupCallPresentation")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneReceivedCallParams struct {
	Peer *InputPhoneCall
}

func (*PhoneReceivedCallParams) CRC() uint32 {
	return 0x17d54f61
}

// Optional: notify the server that the user is currently busy in a call: this will automatically refuse all incoming phone calls until the current phone call is ended.
func (c *Client) PhoneReceivedCall(peer *InputPhoneCall) (bool, error) {
	responseData, err := c.MakeRequest(&PhoneReceivedCallParams{Peer: peer})
	if err != nil {
		return false, errors.Wrap(err, "sending PhoneReceivedCall")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneRequestCallParams struct {
	Video          bool `tl:"flag:0,encoded_in_bitflags"`
	UserID         InputUser
	ConferenceCall *InputGroupCall `tl:"flag:1"`
	RandomID       int32
	GAHash         []byte
	Protocol       *PhoneCallProtocol
}

func (*PhoneRequestCallParams) CRC() uint32 {
	return 0xa6c4600c
}

func (*PhoneRequestCallParams) FlagIndex() int {
	return 0
}

// Start a telegram phone call
func (c *Client) PhoneRequestCall(params *PhoneRequestCallParams) (*PhonePhoneCall, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneRequestCall")
	}

	resp, ok := responseData.(*PhonePhoneCall)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneSaveCallDebugParams struct {
	Peer  *InputPhoneCall
	Debug *DataJson
}

func (*PhoneSaveCallDebugParams) CRC() uint32 {
	return 0x277add7e
}

// Send phone call debug data to server
func (c *Client) PhoneSaveCallDebug(peer *InputPhoneCall, debug *DataJson) (bool, error) {
	responseData, err := c.MakeRequest(&PhoneSaveCallDebugParams{
		Debug: debug,
		Peer:  peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending PhoneSaveCallDebug")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneSaveCallLogParams struct {
	Peer *InputPhoneCall
	File InputFile
}

func (*PhoneSaveCallLogParams) CRC() uint32 {
	return 0x41248786
}

// Save phone call debug information
func (c *Client) PhoneSaveCallLog(peer *InputPhoneCall, file InputFile) (bool, error) {
	responseData, err := c.MakeRequest(&PhoneSaveCallLogParams{
		File: file,
		Peer: peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending PhoneSaveCallLog")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneSaveDefaultGroupCallJoinAsParams struct {
	Peer   InputPeer
	JoinAs InputPeer
}

func (*PhoneSaveDefaultGroupCallJoinAsParams) CRC() uint32 {
	return 0x575e1f8c
}

// Set the default peer that will be used to join a group call in a specific dialog.
func (c *Client) PhoneSaveDefaultGroupCallJoinAs(peer, joinAs InputPeer) (bool, error) {
	responseData, err := c.MakeRequest(&PhoneSaveDefaultGroupCallJoinAsParams{
		JoinAs: joinAs,
		Peer:   peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending PhoneSaveDefaultGroupCallJoinAs")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneSendSignalingDataParams struct {
	Peer *InputPhoneCall
	Data []byte
}

func (*PhoneSendSignalingDataParams) CRC() uint32 {
	return 0xff7a9383
}

// Send VoIP signaling data
func (c *Client) PhoneSendSignalingData(peer *InputPhoneCall, data []byte) (bool, error) {
	responseData, err := c.MakeRequest(&PhoneSendSignalingDataParams{
		Data: data,
		Peer: peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending PhoneSendSignalingData")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneSetCallRatingParams struct {
	UserInitiative bool `tl:"flag:0,encoded_in_bitflags"`
	Peer           *InputPhoneCall
	Rating         int32
	Comment        string
}

func (*PhoneSetCallRatingParams) CRC() uint32 {
	return 0x59ead627
}

func (*PhoneSetCallRatingParams) FlagIndex() int {
	return 0
}

// Rate a call, returns info about the rating message sent to the official VoIP bot.
func (c *Client) PhoneSetCallRating(userInitiative bool, peer *InputPhoneCall, rating int32, comment string) (Updates, error) {
	responseData, err := c.MakeRequest(&PhoneSetCallRatingParams{
		Comment:        comment,
		Peer:           peer,
		Rating:         rating,
		UserInitiative: userInitiative,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneSetCallRating")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneStartScheduledGroupCallParams struct {
	Call *InputGroupCall
}

func (*PhoneStartScheduledGroupCallParams) CRC() uint32 {
	return 0x5680e342
}

// Start a scheduled group call.
func (c *Client) PhoneStartScheduledGroupCall(call *InputGroupCall) (Updates, error) {
	responseData, err := c.MakeRequest(&PhoneStartScheduledGroupCallParams{Call: call})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneStartScheduledGroupCall")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneToggleGroupCallRecordParams struct {
	Start         bool `tl:"flag:0,encoded_in_bitflags"`
	Video         bool `tl:"flag:2,encoded_in_bitflags"`
	Call          *InputGroupCall
	Title         string `tl:"flag:1"`
	VideoPortrait bool   `tl:"flag:2"`
}

func (*PhoneToggleGroupCallRecordParams) CRC() uint32 {
	return 0xf128c708
}

func (*PhoneToggleGroupCallRecordParams) FlagIndex() int {
	return 0
}

// Start or stop recording a group call: the recorded audio and video streams will be automatically sent to `Saved messages` (the chat with ourselves).
func (c *Client) PhoneToggleGroupCallRecord(params *PhoneToggleGroupCallRecordParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneToggleGroupCallRecord")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneToggleGroupCallSettingsParams struct {
	ResetInviteHash bool `tl:"flag:1,encoded_in_bitflags"`
	Call            *InputGroupCall
	JoinMuted       bool `tl:"flag:0"`
}

func (*PhoneToggleGroupCallSettingsParams) CRC() uint32 {
	return 0x74bbb43d
}

func (*PhoneToggleGroupCallSettingsParams) FlagIndex() int {
	return 0
}

// Change group call settings
func (c *Client) PhoneToggleGroupCallSettings(resetInviteHash bool, call *InputGroupCall, joinMuted bool) (Updates, error) {
	responseData, err := c.MakeRequest(&PhoneToggleGroupCallSettingsParams{
		Call:            call,
		JoinMuted:       joinMuted,
		ResetInviteHash: resetInviteHash,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneToggleGroupCallSettings")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhoneToggleGroupCallStartSubscriptionParams struct {
	Call       *InputGroupCall
	Subscribed bool
}

func (*PhoneToggleGroupCallStartSubscriptionParams) CRC() uint32 {
	return 0x219c34e6
}

// Subscribe or unsubscribe to a scheduled group call
func (c *Client) PhoneToggleGroupCallStartSubscription(call *InputGroupCall, subscribed bool) (Updates, error) {
	responseData, err := c.MakeRequest(&PhoneToggleGroupCallStartSubscriptionParams{
		Call:       call,
		Subscribed: subscribed,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhoneToggleGroupCallStartSubscription")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhotosDeletePhotosParams struct {
	ID []InputPhoto
}

func (*PhotosDeletePhotosParams) CRC() uint32 {
	return 0x87cf7f2f
}

// Deletes profile photos. The method returns a list of successfully deleted photo IDs.
func (c *Client) PhotosDeletePhotos(id []InputPhoto) ([]int64, error) {
	responseData, err := c.MakeRequest(&PhotosDeletePhotosParams{ID: id})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhotosDeletePhotos")
	}

	resp, ok := responseData.([]int64)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhotosGetUserPhotosParams struct {
	UserID InputUser
	Offset int32
	MaxID  int64
	Limit  int32
}

func (*PhotosGetUserPhotosParams) CRC() uint32 {
	return 0x91cd32a8
}

// Returns the list of user photos.
func (c *Client) PhotosGetUserPhotos(userID InputUser, offset int32, maxID int64, limit int32) (PhotosPhotos, error) {
	responseData, err := c.MakeRequest(&PhotosGetUserPhotosParams{
		Limit:  limit,
		MaxID:  maxID,
		Offset: offset,
		UserID: userID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhotosGetUserPhotos")
	}

	resp, ok := responseData.(PhotosPhotos)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhotosUpdateProfilePhotoParams struct {
	Fallback bool      `tl:"flag:0,encoded_in_bitflags"`
	Bot      InputUser `tl:"flag:1"`
	ID       InputPhoto
}

func (*PhotosUpdateProfilePhotoParams) CRC() uint32 {
	return 0x9e82039
}

func (*PhotosUpdateProfilePhotoParams) FlagIndex() int {
	return 0
}

// Installs a previously uploaded photo as a profile photo.
func (c *Client) PhotosUpdateProfilePhoto(fallback bool, bot InputUser, id InputPhoto) (*PhotosPhoto, error) {
	responseData, err := c.MakeRequest(&PhotosUpdateProfilePhotoParams{
		Bot:      bot,
		Fallback: fallback,
		ID:       id,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PhotosUpdateProfilePhoto")
	}

	resp, ok := responseData.(*PhotosPhoto)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhotosUploadContactProfilePhotoParams struct {
	Suggest          bool `tl:"flag:3,encoded_in_bitflags"`
	Save             bool `tl:"flag:4,encoded_in_bitflags"`
	UserID           InputUser
	File             InputFile `tl:"flag:0"`
	Video            InputFile `tl:"flag:1"`
	VideoStartTs     float64   `tl:"flag:2"`
	VideoEmojiMarkup VideoSize `tl:"flag:5"`
}

func (*PhotosUploadContactProfilePhotoParams) CRC() uint32 {
	return 0xe14c4a71
}

func (*PhotosUploadContactProfilePhotoParams) FlagIndex() int {
	return 0
}

// Upload a custom profile picture for a contact, or suggest a new profile picture to a contact.
func (c *Client) PhotosUploadContactProfilePhoto(params *PhotosUploadContactProfilePhotoParams) (*PhotosPhoto, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending PhotosUploadContactProfilePhoto")
	}

	resp, ok := responseData.(*PhotosPhoto)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PhotosUploadProfilePhotoParams struct {
	Fallback         bool      `tl:"flag:3,encoded_in_bitflags"`
	Bot              InputUser `tl:"flag:5"`
	File             InputFile `tl:"flag:0"`
	Video            InputFile `tl:"flag:1"`
	VideoStartTs     float64   `tl:"flag:2"`
	VideoEmojiMarkup VideoSize `tl:"flag:4"`
}

func (*PhotosUploadProfilePhotoParams) CRC() uint32 {
	return 0x388a3b5
}

func (*PhotosUploadProfilePhotoParams) FlagIndex() int {
	return 0
}

// Updates current user profile photo.
func (c *Client) PhotosUploadProfilePhoto(params *PhotosUploadProfilePhotoParams) (*PhotosPhoto, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending PhotosUploadProfilePhoto")
	}

	resp, ok := responseData.(*PhotosPhoto)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PremiumApplyBoostParams struct {
	Slots []int32 `tl:"flag:0"`
	Peer  InputPeer
}

func (*PremiumApplyBoostParams) CRC() uint32 {
	return 0x6b7da746
}

func (*PremiumApplyBoostParams) FlagIndex() int {
	return 0
}

// Apply one or more boosts » to a peer.
func (c *Client) PremiumApplyBoost(slots []int32, peer InputPeer) (*PremiumMyBoosts, error) {
	responseData, err := c.MakeRequest(&PremiumApplyBoostParams{
		Peer:  peer,
		Slots: slots,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PremiumApplyBoost")
	}

	resp, ok := responseData.(*PremiumMyBoosts)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PremiumGetBoostsListParams struct {
	Gifts  bool `tl:"flag:0,encoded_in_bitflags"`
	Peer   InputPeer
	Offset string
	Limit  int32
}

func (*PremiumGetBoostsListParams) CRC() uint32 {
	return 0x60f67660
}

func (*PremiumGetBoostsListParams) FlagIndex() int {
	return 0
}

// Obtains info about the boosts that were applied to a certain channel or supergroup (admins only)
func (c *Client) PremiumGetBoostsList(gifts bool, peer InputPeer, offset string, limit int32) (*PremiumBoostsList, error) {
	responseData, err := c.MakeRequest(&PremiumGetBoostsListParams{
		Gifts:  gifts,
		Limit:  limit,
		Offset: offset,
		Peer:   peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PremiumGetBoostsList")
	}

	resp, ok := responseData.(*PremiumBoostsList)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PremiumGetBoostsStatusParams struct {
	Peer InputPeer
}

func (*PremiumGetBoostsStatusParams) CRC() uint32 {
	return 0x42f1f61
}

// Gets the current number of boosts of a channel/supergroup.
func (c *Client) PremiumGetBoostsStatus(peer InputPeer) (*PremiumBoostsStatus, error) {
	responseData, err := c.MakeRequest(&PremiumGetBoostsStatusParams{Peer: peer})
	if err != nil {
		return nil, errors.Wrap(err, "sending PremiumGetBoostsStatus")
	}

	resp, ok := responseData.(*PremiumBoostsStatus)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PremiumGetMyBoostsParams struct{}

func (*PremiumGetMyBoostsParams) CRC() uint32 {
	return 0xbe77b4a
}

// Obtain which peers are we currently boosting, and how many boost slots we have left.
func (c *Client) PremiumGetMyBoosts() (*PremiumMyBoosts, error) {
	responseData, err := c.MakeRequest(&PremiumGetMyBoostsParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending PremiumGetMyBoosts")
	}

	resp, ok := responseData.(*PremiumMyBoosts)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type PremiumGetUserBoostsParams struct {
	Peer   InputPeer
	UserID InputUser
}

func (*PremiumGetUserBoostsParams) CRC() uint32 {
	return 0x39854d1f
}

// Returns the lists of boost that were applied to a channel/supergroup by a specific user (admins only)
func (c *Client) PremiumGetUserBoosts(peer InputPeer, userID InputUser) (*PremiumBoostsList, error) {
	responseData, err := c.MakeRequest(&PremiumGetUserBoostsParams{
		Peer:   peer,
		UserID: userID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending PremiumGetUserBoosts")
	}

	resp, ok := responseData.(*PremiumBoostsList)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type SmsjobsFinishJobParams struct {
	JobID string
	Error string `tl:"flag:0"`
}

func (*SmsjobsFinishJobParams) CRC() uint32 {
	return 0x4f1ebf24
}

func (*SmsjobsFinishJobParams) FlagIndex() int {
	return 0
}

// Finish an SMS job (official clients only).
func (c *Client) SmsjobsFinishJob(jobID, error string) (bool, error) {
	responseData, err := c.MakeRequest(&SmsjobsFinishJobParams{
		Error: error,
		JobID: jobID,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending SmsjobsFinishJob")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type SmsjobsGetSmsJobParams struct {
	JobID string
}

func (*SmsjobsGetSmsJobParams) CRC() uint32 {
	return 0x778d902f
}

// Get info about an SMS job (official clients only).
func (c *Client) SmsjobsGetSmsJob(jobID string) (*SmsJob, error) {
	responseData, err := c.MakeRequest(&SmsjobsGetSmsJobParams{JobID: jobID})
	if err != nil {
		return nil, errors.Wrap(err, "sending SmsjobsGetSmsJob")
	}

	resp, ok := responseData.(*SmsJob)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type SmsjobsGetStatusParams struct{}

func (*SmsjobsGetStatusParams) CRC() uint32 {
	return 0x10a698e8
}

// Get SMS jobs status (official clients only).
func (c *Client) SmsjobsGetStatus() (*SmsjobsStatus, error) {
	responseData, err := c.MakeRequest(&SmsjobsGetStatusParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending SmsjobsGetStatus")
	}

	resp, ok := responseData.(*SmsjobsStatus)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type SmsjobsIsEligibleToJoinParams struct{}

func (*SmsjobsIsEligibleToJoinParams) CRC() uint32 {
	return 0xedc39d0
}

// Check if we can process SMS jobs (official clients only).
func (c *Client) SmsjobsIsEligibleToJoin() (*SmsjobsEligibleToJoin, error) {
	responseData, err := c.MakeRequest(&SmsjobsIsEligibleToJoinParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending SmsjobsIsEligibleToJoin")
	}

	resp, ok := responseData.(*SmsjobsEligibleToJoin)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type SmsjobsJoinParams struct{}

func (*SmsjobsJoinParams) CRC() uint32 {
	return 0xa74ece2d
}

// Enable SMS jobs (official clients only).
func (c *Client) SmsjobsJoin() (bool, error) {
	responseData, err := c.MakeRequest(&SmsjobsJoinParams{})
	if err != nil {
		return false, errors.Wrap(err, "sending SmsjobsJoin")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type SmsjobsLeaveParams struct{}

func (*SmsjobsLeaveParams) CRC() uint32 {
	return 0x9898ad73
}

// Disable SMS jobs (official clients only).
func (c *Client) SmsjobsLeave() (bool, error) {
	responseData, err := c.MakeRequest(&SmsjobsLeaveParams{})
	if err != nil {
		return false, errors.Wrap(err, "sending SmsjobsLeave")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type SmsjobsUpdateSettingsParams struct {
	AllowInternational bool `tl:"flag:0,encoded_in_bitflags"`
}

func (*SmsjobsUpdateSettingsParams) CRC() uint32 {
	return 0x93fa0bf
}

func (*SmsjobsUpdateSettingsParams) FlagIndex() int {
	return 0
}

// Update SMS job settings (official clients only).
func (c *Client) SmsjobsUpdateSettings(allowInternational bool) (bool, error) {
	responseData, err := c.MakeRequest(&SmsjobsUpdateSettingsParams{AllowInternational: allowInternational})
	if err != nil {
		return false, errors.Wrap(err, "sending SmsjobsUpdateSettings")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StatsGetBroadcastRevenueStatsParams struct {
	Dark bool `tl:"flag:0,encoded_in_bitflags"`
	Peer InputPeer
}

func (*StatsGetBroadcastRevenueStatsParams) CRC() uint32 {
	return 0xf788ee19
}

func (*StatsGetBroadcastRevenueStatsParams) FlagIndex() int {
	return 0
}

// Get channel ad revenue statistics ».
func (c *Client) StatsGetBroadcastRevenueStats(dark bool, peer InputPeer) (*StatsBroadcastRevenueStats, error) {
	responseData, err := c.MakeRequest(&StatsGetBroadcastRevenueStatsParams{
		Dark: dark,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StatsGetBroadcastRevenueStats")
	}

	resp, ok := responseData.(*StatsBroadcastRevenueStats)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StatsGetBroadcastRevenueTransactionsParams struct {
	Peer   InputPeer
	Offset int32
	Limit  int32
}

func (*StatsGetBroadcastRevenueTransactionsParams) CRC() uint32 {
	return 0x70990b6d
}

// Fetch channel ad revenue transaction history ».
func (c *Client) StatsGetBroadcastRevenueTransactions(peer InputPeer, offset, limit int32) (*StatsBroadcastRevenueTransactions, error) {
	responseData, err := c.MakeRequest(&StatsGetBroadcastRevenueTransactionsParams{
		Limit:  limit,
		Offset: offset,
		Peer:   peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StatsGetBroadcastRevenueTransactions")
	}

	resp, ok := responseData.(*StatsBroadcastRevenueTransactions)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StatsGetBroadcastRevenueWithdrawalURLParams struct {
	Peer     InputPeer
	Password InputCheckPasswordSRP
}

func (*StatsGetBroadcastRevenueWithdrawalURLParams) CRC() uint32 {
	return 0x9df4faad
}

// Withdraw funds from a channel's ad revenue balance ».
func (c *Client) StatsGetBroadcastRevenueWithdrawalURL(peer InputPeer, password InputCheckPasswordSRP) (*StatsBroadcastRevenueWithdrawalURL, error) {
	responseData, err := c.MakeRequest(&StatsGetBroadcastRevenueWithdrawalURLParams{
		Password: password,
		Peer:     peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StatsGetBroadcastRevenueWithdrawalURL")
	}

	resp, ok := responseData.(*StatsBroadcastRevenueWithdrawalURL)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StatsGetBroadcastStatsParams struct {
	Dark    bool `tl:"flag:0,encoded_in_bitflags"`
	Channel InputChannel
}

func (*StatsGetBroadcastStatsParams) CRC() uint32 {
	return 0xab42441a
}

func (*StatsGetBroadcastStatsParams) FlagIndex() int {
	return 0
}

// Get channel statistics
func (c *Client) StatsGetBroadcastStats(dark bool, channel InputChannel) (*StatsBroadcastStats, error) {
	responseData, err := c.MakeRequest(&StatsGetBroadcastStatsParams{
		Channel: channel,
		Dark:    dark,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StatsGetBroadcastStats")
	}

	resp, ok := responseData.(*StatsBroadcastStats)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StatsGetMegagroupStatsParams struct {
	Dark    bool `tl:"flag:0,encoded_in_bitflags"`
	Channel InputChannel
}

func (*StatsGetMegagroupStatsParams) CRC() uint32 {
	return 0xdcdf8607
}

func (*StatsGetMegagroupStatsParams) FlagIndex() int {
	return 0
}

// Get supergroup statistics
func (c *Client) StatsGetMegagroupStats(dark bool, channel InputChannel) (*StatsMegagroupStats, error) {
	responseData, err := c.MakeRequest(&StatsGetMegagroupStatsParams{
		Channel: channel,
		Dark:    dark,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StatsGetMegagroupStats")
	}

	resp, ok := responseData.(*StatsMegagroupStats)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StatsGetMessagePublicForwardsParams struct {
	Channel InputChannel
	MsgID   int32
	Offset  string
	Limit   int32
}

func (*StatsGetMessagePublicForwardsParams) CRC() uint32 {
	return 0x5f150144
}

/*
Obtains a list of messages, indicating to which other public channels was a channel message forwarded.<br>
Will return a list of messages with `peer_id` equal to the public channel to which this message was forwarded.
*/
func (c *Client) StatsGetMessagePublicForwards(channel InputChannel, msgID int32, offset string, limit int32) (*StatsPublicForwards, error) {
	responseData, err := c.MakeRequest(&StatsGetMessagePublicForwardsParams{
		Channel: channel,
		Limit:   limit,
		MsgID:   msgID,
		Offset:  offset,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StatsGetMessagePublicForwards")
	}

	resp, ok := responseData.(*StatsPublicForwards)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StatsGetMessageStatsParams struct {
	Dark    bool `tl:"flag:0,encoded_in_bitflags"`
	Channel InputChannel
	MsgID   int32
}

func (*StatsGetMessageStatsParams) CRC() uint32 {
	return 0xb6e0a3f5
}

func (*StatsGetMessageStatsParams) FlagIndex() int {
	return 0
}

// Get message statistics
func (c *Client) StatsGetMessageStats(dark bool, channel InputChannel, msgID int32) (*StatsMessageStats, error) {
	responseData, err := c.MakeRequest(&StatsGetMessageStatsParams{
		Channel: channel,
		Dark:    dark,
		MsgID:   msgID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StatsGetMessageStats")
	}

	resp, ok := responseData.(*StatsMessageStats)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StatsGetStoryPublicForwardsParams struct {
	Peer   InputPeer
	ID     int32
	Offset string
	Limit  int32
}

func (*StatsGetStoryPublicForwardsParams) CRC() uint32 {
	return 0xa6437ef6
}

// Obtain forwards of a story as a message to public chats and reposts by public channels.
func (c *Client) StatsGetStoryPublicForwards(peer InputPeer, id int32, offset string, limit int32) (*StatsPublicForwards, error) {
	responseData, err := c.MakeRequest(&StatsGetStoryPublicForwardsParams{
		ID:     id,
		Limit:  limit,
		Offset: offset,
		Peer:   peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StatsGetStoryPublicForwards")
	}

	resp, ok := responseData.(*StatsPublicForwards)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StatsGetStoryStatsParams struct {
	Dark bool `tl:"flag:0,encoded_in_bitflags"`
	Peer InputPeer
	ID   int32
}

func (*StatsGetStoryStatsParams) CRC() uint32 {
	return 0x374fef40
}

func (*StatsGetStoryStatsParams) FlagIndex() int {
	return 0
}

// Get statistics for a certain story.
func (c *Client) StatsGetStoryStats(dark bool, peer InputPeer, id int32) (*StatsStoryStats, error) {
	responseData, err := c.MakeRequest(&StatsGetStoryStatsParams{
		Dark: dark,
		ID:   id,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StatsGetStoryStats")
	}

	resp, ok := responseData.(*StatsStoryStats)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StatsLoadAsyncGraphParams struct {
	Token string
	X     int64 `tl:"flag:0"`
}

func (*StatsLoadAsyncGraphParams) CRC() uint32 {
	return 0x621d5fa0
}

func (*StatsLoadAsyncGraphParams) FlagIndex() int {
	return 0
}

// Load channel statistics graph asynchronously
func (c *Client) StatsLoadAsyncGraph(token string, x int64) (StatsGraph, error) {
	responseData, err := c.MakeRequest(&StatsLoadAsyncGraphParams{
		Token: token,
		X:     x,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StatsLoadAsyncGraph")
	}

	resp, ok := responseData.(StatsGraph)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StickersAddStickerToSetParams struct {
	Stickerset InputStickerSet
	Sticker    *InputStickerSetItem
}

func (*StickersAddStickerToSetParams) CRC() uint32 {
	return 0x8653febe
}

// Add a sticker to a stickerset. The sticker set must have been created by the current user/bot.
func (c *Client) StickersAddStickerToSet(stickerset InputStickerSet, sticker *InputStickerSetItem) (MessagesStickerSet, error) {
	responseData, err := c.MakeRequest(&StickersAddStickerToSetParams{
		Sticker:    sticker,
		Stickerset: stickerset,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StickersAddStickerToSet")
	}

	resp, ok := responseData.(MessagesStickerSet)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StickersChangeStickerParams struct {
	Sticker    InputDocument
	Emoji      string      `tl:"flag:0"`
	MaskCoords *MaskCoords `tl:"flag:1"`
	Keywords   string      `tl:"flag:2"`
}

func (*StickersChangeStickerParams) CRC() uint32 {
	return 0xf5537ebc
}

func (*StickersChangeStickerParams) FlagIndex() int {
	return 0
}

// Update the keywords, emojis or mask coordinates of a sticker.
func (c *Client) StickersChangeSticker(sticker InputDocument, emoji string, maskCoords *MaskCoords, keywords string) (MessagesStickerSet, error) {
	responseData, err := c.MakeRequest(&StickersChangeStickerParams{
		Emoji:      emoji,
		Keywords:   keywords,
		MaskCoords: maskCoords,
		Sticker:    sticker,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StickersChangeSticker")
	}

	resp, ok := responseData.(MessagesStickerSet)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StickersChangeStickerPositionParams struct {
	Sticker  InputDocument
	Position int32
}

func (*StickersChangeStickerPositionParams) CRC() uint32 {
	return 0xffb6d4ca
}

// Changes the absolute position of a sticker in the set to which it belongs. The sticker set must have been created by the current user/bot.
func (c *Client) StickersChangeStickerPosition(sticker InputDocument, position int32) (MessagesStickerSet, error) {
	responseData, err := c.MakeRequest(&StickersChangeStickerPositionParams{
		Position: position,
		Sticker:  sticker,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StickersChangeStickerPosition")
	}

	resp, ok := responseData.(MessagesStickerSet)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StickersCheckShortNameParams struct {
	ShortName string
}

func (*StickersCheckShortNameParams) CRC() uint32 {
	return 0x284b3639
}

// Check whether the given short name is available
func (c *Client) StickersCheckShortName(shortName string) (bool, error) {
	responseData, err := c.MakeRequest(&StickersCheckShortNameParams{ShortName: shortName})
	if err != nil {
		return false, errors.Wrap(err, "sending StickersCheckShortName")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StickersCreateStickerSetParams struct {
	Masks     bool `tl:"flag:0,encoded_in_bitflags"`
	Emojis    bool `tl:"flag:5,encoded_in_bitflags"`
	TextColor bool `tl:"flag:6,encoded_in_bitflags"`
	UserID    InputUser
	Title     string
	ShortName string
	Thumb     InputDocument `tl:"flag:2"`
	Stickers  []*InputStickerSetItem
	Software  string `tl:"flag:3"`
}

func (*StickersCreateStickerSetParams) CRC() uint32 {
	return 0x9021ab67
}

func (*StickersCreateStickerSetParams) FlagIndex() int {
	return 0
}

// Create a stickerset.
func (c *Client) StickersCreateStickerSet(params *StickersCreateStickerSetParams) (MessagesStickerSet, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending StickersCreateStickerSet")
	}

	resp, ok := responseData.(MessagesStickerSet)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StickersDeleteStickerSetParams struct {
	Stickerset InputStickerSet
}

func (*StickersDeleteStickerSetParams) CRC() uint32 {
	return 0x87704394
}

// Deletes a stickerset we created.
func (c *Client) StickersDeleteStickerSet(stickerset InputStickerSet) (bool, error) {
	responseData, err := c.MakeRequest(&StickersDeleteStickerSetParams{Stickerset: stickerset})
	if err != nil {
		return false, errors.Wrap(err, "sending StickersDeleteStickerSet")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StickersRemoveStickerFromSetParams struct {
	Sticker InputDocument
}

func (*StickersRemoveStickerFromSetParams) CRC() uint32 {
	return 0xf7760f51
}

// Remove a sticker from the set where it belongs. The sticker set must have been created by the current user/bot.
func (c *Client) StickersRemoveStickerFromSet(sticker InputDocument) (MessagesStickerSet, error) {
	responseData, err := c.MakeRequest(&StickersRemoveStickerFromSetParams{Sticker: sticker})
	if err != nil {
		return nil, errors.Wrap(err, "sending StickersRemoveStickerFromSet")
	}

	resp, ok := responseData.(MessagesStickerSet)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StickersRenameStickerSetParams struct {
	Stickerset InputStickerSet
	Title      string
}

func (*StickersRenameStickerSetParams) CRC() uint32 {
	return 0x124b1c00
}

// Renames a stickerset.
func (c *Client) StickersRenameStickerSet(stickerset InputStickerSet, title string) (MessagesStickerSet, error) {
	responseData, err := c.MakeRequest(&StickersRenameStickerSetParams{
		Stickerset: stickerset,
		Title:      title,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StickersRenameStickerSet")
	}

	resp, ok := responseData.(MessagesStickerSet)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StickersReplaceStickerParams struct {
	Sticker    InputDocument
	NewSticker *InputStickerSetItem
}

func (*StickersReplaceStickerParams) CRC() uint32 {
	return 0x4696459a
}

// Replace a sticker in a stickerset ».
func (c *Client) StickersReplaceSticker(sticker InputDocument, newSticker *InputStickerSetItem) (MessagesStickerSet, error) {
	responseData, err := c.MakeRequest(&StickersReplaceStickerParams{
		NewSticker: newSticker,
		Sticker:    sticker,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StickersReplaceSticker")
	}

	resp, ok := responseData.(MessagesStickerSet)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StickersSetStickerSetThumbParams struct {
	Stickerset      InputStickerSet
	Thumb           InputDocument `tl:"flag:0"`
	ThumbDocumentID int64         `tl:"flag:1"`
}

func (*StickersSetStickerSetThumbParams) CRC() uint32 {
	return 0xa76a5392
}

func (*StickersSetStickerSetThumbParams) FlagIndex() int {
	return 0
}

// Set stickerset thumbnail
func (c *Client) StickersSetStickerSetThumb(stickerset InputStickerSet, thumb InputDocument, thumbDocumentID int64) (MessagesStickerSet, error) {
	responseData, err := c.MakeRequest(&StickersSetStickerSetThumbParams{
		Stickerset:      stickerset,
		Thumb:           thumb,
		ThumbDocumentID: thumbDocumentID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StickersSetStickerSetThumb")
	}

	resp, ok := responseData.(MessagesStickerSet)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StickersSuggestShortNameParams struct {
	Title string
}

func (*StickersSuggestShortNameParams) CRC() uint32 {
	return 0x4dafc503
}

// Suggests a short name for a given stickerpack name
func (c *Client) StickersSuggestShortName(title string) (*StickersSuggestedShortName, error) {
	responseData, err := c.MakeRequest(&StickersSuggestShortNameParams{Title: title})
	if err != nil {
		return nil, errors.Wrap(err, "sending StickersSuggestShortName")
	}

	resp, ok := responseData.(*StickersSuggestedShortName)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesActivateStealthModeParams struct {
	Past   bool `tl:"flag:0,encoded_in_bitflags"`
	Future bool `tl:"flag:1,encoded_in_bitflags"`
}

func (*StoriesActivateStealthModeParams) CRC() uint32 {
	return 0x57bbd166
}

func (*StoriesActivateStealthModeParams) FlagIndex() int {
	return 0
}

// Activates stories stealth mode, see here » for more info.
func (c *Client) StoriesActivateStealthMode(past, future bool) (Updates, error) {
	responseData, err := c.MakeRequest(&StoriesActivateStealthModeParams{
		Future: future,
		Past:   past,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesActivateStealthMode")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesCanSendStoryParams struct {
	Peer InputPeer
}

func (*StoriesCanSendStoryParams) CRC() uint32 {
	return 0xc7dfdfdd
}

// Check whether we can post stories as the specified peer.
func (c *Client) StoriesCanSendStory(peer InputPeer) (bool, error) {
	responseData, err := c.MakeRequest(&StoriesCanSendStoryParams{Peer: peer})
	if err != nil {
		return false, errors.Wrap(err, "sending StoriesCanSendStory")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesDeleteStoriesParams struct {
	Peer InputPeer
	ID   []int32
}

func (*StoriesDeleteStoriesParams) CRC() uint32 {
	return 0xae59db5f
}

// Deletes some posted stories.
func (c *Client) StoriesDeleteStories(peer InputPeer, id []int32) ([]int32, error) {
	responseData, err := c.MakeRequest(&StoriesDeleteStoriesParams{
		ID:   id,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesDeleteStories")
	}

	resp, ok := responseData.([]int32)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesEditStoryParams struct {
	Peer         InputPeer
	ID           int32
	Media        InputMedia         `tl:"flag:0"`
	MediaAreas   []MediaArea        `tl:"flag:3"`
	Caption      string             `tl:"flag:1"`
	Entities     []MessageEntity    `tl:"flag:1"`
	PrivacyRules []InputPrivacyRule `tl:"flag:2"`
}

func (*StoriesEditStoryParams) CRC() uint32 {
	return 0xb583ba46
}

func (*StoriesEditStoryParams) FlagIndex() int {
	return 0
}

// Edit an uploaded story
func (c *Client) StoriesEditStory(params *StoriesEditStoryParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesEditStory")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesExportStoryLinkParams struct {
	Peer InputPeer
	ID   int32
}

func (*StoriesExportStoryLinkParams) CRC() uint32 {
	return 0x7b8def20
}

// Generate a story deep link for a specific story
func (c *Client) StoriesExportStoryLink(peer InputPeer, id int32) (*ExportedStoryLink, error) {
	responseData, err := c.MakeRequest(&StoriesExportStoryLinkParams{
		ID:   id,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesExportStoryLink")
	}

	resp, ok := responseData.(*ExportedStoryLink)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesGetAllReadPeerStoriesParams struct{}

func (*StoriesGetAllReadPeerStoriesParams) CRC() uint32 {
	return 0x9b5ae7f9
}

// Obtain the latest read story ID for all peers when first logging in, returned as a list of updateReadStories updates, see here » for more info.
func (c *Client) StoriesGetAllReadPeerStories() (Updates, error) {
	responseData, err := c.MakeRequest(&StoriesGetAllReadPeerStoriesParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesGetAllReadPeerStories")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesGetAllStoriesParams struct {
	Next   bool   `tl:"flag:1,encoded_in_bitflags"`
	Hidden bool   `tl:"flag:2,encoded_in_bitflags"`
	State  string `tl:"flag:0"`
}

func (*StoriesGetAllStoriesParams) CRC() uint32 {
	return 0xeeb0d625
}

func (*StoriesGetAllStoriesParams) FlagIndex() int {
	return 0
}

// Fetch the List of active (or active and hidden) stories, see here » for more info on watching stories.
func (c *Client) StoriesGetAllStories(next, hidden bool, state string) (StoriesAllStories, error) {
	responseData, err := c.MakeRequest(&StoriesGetAllStoriesParams{
		Hidden: hidden,
		Next:   next,
		State:  state,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesGetAllStories")
	}

	resp, ok := responseData.(StoriesAllStories)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesGetChatsToSendParams struct{}

func (*StoriesGetChatsToSendParams) CRC() uint32 {
	return 0xa56a8b60
}

// Obtain a list of channels where the user can post stories
func (c *Client) StoriesGetChatsToSend() (MessagesChats, error) {
	responseData, err := c.MakeRequest(&StoriesGetChatsToSendParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesGetChatsToSend")
	}

	resp, ok := responseData.(MessagesChats)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesGetPeerMaxIDsParams struct {
	ID []InputPeer
}

func (*StoriesGetPeerMaxIDsParams) CRC() uint32 {
	return 0x535983c3
}

// Get the IDs of the maximum read stories for a set of peers.
func (c *Client) StoriesGetPeerMaxIDs(id []InputPeer) ([]int32, error) {
	responseData, err := c.MakeRequest(&StoriesGetPeerMaxIDsParams{ID: id})
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesGetPeerMaxIDs")
	}

	resp, ok := responseData.([]int32)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesGetPeerStoriesParams struct {
	Peer InputPeer
}

func (*StoriesGetPeerStoriesParams) CRC() uint32 {
	return 0x2c4ada50
}

// Fetch the full active story list of a specific peer.
func (c *Client) StoriesGetPeerStories(peer InputPeer) (*StoriesPeerStories, error) {
	responseData, err := c.MakeRequest(&StoriesGetPeerStoriesParams{Peer: peer})
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesGetPeerStories")
	}

	resp, ok := responseData.(*StoriesPeerStories)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesGetPinnedStoriesParams struct {
	Peer     InputPeer
	OffsetID int32
	Limit    int32
}

func (*StoriesGetPinnedStoriesParams) CRC() uint32 {
	return 0x5821a5dc
}

// Fetch the stories pinned on a peer's profile.
func (c *Client) StoriesGetPinnedStories(peer InputPeer, offsetID, limit int32) (*StoriesStories, error) {
	responseData, err := c.MakeRequest(&StoriesGetPinnedStoriesParams{
		Limit:    limit,
		OffsetID: offsetID,
		Peer:     peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesGetPinnedStories")
	}

	resp, ok := responseData.(*StoriesStories)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesGetStoriesArchiveParams struct {
	Peer     InputPeer
	OffsetID int32
	Limit    int32
}

func (*StoriesGetStoriesArchiveParams) CRC() uint32 {
	return 0xb4352016
}

// Fetch the story archive » of a peer we control.
func (c *Client) StoriesGetStoriesArchive(peer InputPeer, offsetID, limit int32) (*StoriesStories, error) {
	responseData, err := c.MakeRequest(&StoriesGetStoriesArchiveParams{
		Limit:    limit,
		OffsetID: offsetID,
		Peer:     peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesGetStoriesArchive")
	}

	resp, ok := responseData.(*StoriesStories)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesGetStoriesByIDParams struct {
	Peer InputPeer
	ID   []int32
}

func (*StoriesGetStoriesByIDParams) CRC() uint32 {
	return 0x5774ca74
}

// Obtain full info about a set of stories by their IDs.
func (c *Client) StoriesGetStoriesByID(peer InputPeer, id []int32) (*StoriesStories, error) {
	responseData, err := c.MakeRequest(&StoriesGetStoriesByIDParams{
		ID:   id,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesGetStoriesByID")
	}

	resp, ok := responseData.(*StoriesStories)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesGetStoriesViewsParams struct {
	Peer InputPeer
	ID   []int32
}

func (*StoriesGetStoriesViewsParams) CRC() uint32 {
	return 0x28e16cc8
}

// Obtain info about the view count, forward count, reactions and recent viewers of one or more stories.
func (c *Client) StoriesGetStoriesViews(peer InputPeer, id []int32) (*StoriesStoryViews, error) {
	responseData, err := c.MakeRequest(&StoriesGetStoriesViewsParams{
		ID:   id,
		Peer: peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesGetStoriesViews")
	}

	resp, ok := responseData.(*StoriesStoryViews)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesGetStoryReactionsListParams struct {
	ForwardsFirst bool `tl:"flag:2,encoded_in_bitflags"`
	Peer          InputPeer
	ID            int32
	Reaction      Reaction `tl:"flag:0"`
	Offset        string   `tl:"flag:1"`
	Limit         int32
}

func (*StoriesGetStoryReactionsListParams) CRC() uint32 {
	return 0xb9b2881f
}

func (*StoriesGetStoryReactionsListParams) FlagIndex() int {
	return 0
}

// Get the reaction and interaction list of a story posted to a channel, along with the sender of each reaction.
func (c *Client) StoriesGetStoryReactionsList(params *StoriesGetStoryReactionsListParams) (*StoriesStoryReactionsList, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesGetStoryReactionsList")
	}

	resp, ok := responseData.(*StoriesStoryReactionsList)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesGetStoryViewsListParams struct {
	JustContacts   bool `tl:"flag:0,encoded_in_bitflags"`
	ReactionsFirst bool `tl:"flag:2,encoded_in_bitflags"`
	ForwardsFirst  bool `tl:"flag:3,encoded_in_bitflags"`
	Peer           InputPeer
	Q              string `tl:"flag:1"`
	ID             int32
	Offset         string
	Limit          int32
}

func (*StoriesGetStoryViewsListParams) CRC() uint32 {
	return 0x7ed23c57
}

func (*StoriesGetStoryViewsListParams) FlagIndex() int {
	return 0
}

// Obtain the list of users that have viewed a specific story we posted
func (c *Client) StoriesGetStoryViewsList(params *StoriesGetStoryViewsListParams) (*StoriesStoryViewsList, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesGetStoryViewsList")
	}

	resp, ok := responseData.(*StoriesStoryViewsList)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesIncrementStoryViewsParams struct {
	Peer InputPeer
	ID   []int32
}

func (*StoriesIncrementStoryViewsParams) CRC() uint32 {
	return 0xb2028afb
}

// Increment the view counter of one or more stories.
func (c *Client) StoriesIncrementStoryViews(peer InputPeer, id []int32) (bool, error) {
	responseData, err := c.MakeRequest(&StoriesIncrementStoryViewsParams{
		ID:   id,
		Peer: peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending StoriesIncrementStoryViews")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesReadStoriesParams struct {
	Peer  InputPeer
	MaxID int32
}

func (*StoriesReadStoriesParams) CRC() uint32 {
	return 0xa556dac8
}

// Mark all stories up to a certain ID as read, for a given peer; will emit an updateReadStories update to all logged-in sessions.
func (c *Client) StoriesReadStories(peer InputPeer, maxID int32) ([]int32, error) {
	responseData, err := c.MakeRequest(&StoriesReadStoriesParams{
		MaxID: maxID,
		Peer:  peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesReadStories")
	}

	resp, ok := responseData.([]int32)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesReportParams struct {
	Peer    InputPeer
	ID      []int32
	Option  []byte
	Message string
}

func (*StoriesReportParams) CRC() uint32 {
	return 0x19d8eb45
}

// Report a story.
func (c *Client) StoriesReport(peer InputPeer, id []int32, option []byte, message string) (ReportResult, error) {
	responseData, err := c.MakeRequest(&StoriesReportParams{
		ID:      id,
		Message: message,
		Option:  option,
		Peer:    peer,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesReport")
	}

	resp, ok := responseData.(ReportResult)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesSearchPostsParams struct {
	Hashtag string    `tl:"flag:0"`
	Area    MediaArea `tl:"flag:1"`
	Peer    InputPeer `tl:"flag:2"`
	Offset  string
	Limit   int32
}

func (*StoriesSearchPostsParams) CRC() uint32 {
	return 0xd1810907
}

func (*StoriesSearchPostsParams) FlagIndex() int {
	return 0
}

// Globally search for stories using a hashtag or a location media area, see here » for more info on the full flow.
func (c *Client) StoriesSearchPosts(params *StoriesSearchPostsParams) (*StoriesFoundStories, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesSearchPosts")
	}

	resp, ok := responseData.(*StoriesFoundStories)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesSendReactionParams struct {
	AddToRecent bool `tl:"flag:0,encoded_in_bitflags"`
	Peer        InputPeer
	StoryID     int32
	Reaction    Reaction
}

func (*StoriesSendReactionParams) CRC() uint32 {
	return 0x7fd736b2
}

func (*StoriesSendReactionParams) FlagIndex() int {
	return 0
}

// React to a story.
func (c *Client) StoriesSendReaction(addToRecent bool, peer InputPeer, storyID int32, reaction Reaction) (Updates, error) {
	responseData, err := c.MakeRequest(&StoriesSendReactionParams{
		AddToRecent: addToRecent,
		Peer:        peer,
		Reaction:    reaction,
		StoryID:     storyID,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesSendReaction")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesSendStoryParams struct {
	Pinned       bool `tl:"flag:2,encoded_in_bitflags"`
	Noforwards   bool `tl:"flag:4,encoded_in_bitflags"`
	FwdModified  bool `tl:"flag:7,encoded_in_bitflags"`
	Peer         InputPeer
	Media        InputMedia
	MediaAreas   []MediaArea     `tl:"flag:5"`
	Caption      string          `tl:"flag:0"`
	Entities     []MessageEntity `tl:"flag:1"`
	PrivacyRules []InputPrivacyRule
	RandomID     int64
	Period       int32     `tl:"flag:3"`
	FwdFromID    InputPeer `tl:"flag:6"`
	FwdFromStory int32     `tl:"flag:6"`
}

func (*StoriesSendStoryParams) CRC() uint32 {
	return 0xe4e6694b
}

func (*StoriesSendStoryParams) FlagIndex() int {
	return 0
}

// Uploads a Telegram Story.
func (c *Client) StoriesSendStory(params *StoriesSendStoryParams) (Updates, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesSendStory")
	}

	resp, ok := responseData.(Updates)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesToggleAllStoriesHiddenParams struct {
	Hidden bool
}

func (*StoriesToggleAllStoriesHiddenParams) CRC() uint32 {
	return 0x7c2557c4
}

// Hide the active stories of a specific peer, preventing them from being displayed on the action bar on the homescreen.
func (c *Client) StoriesToggleAllStoriesHidden(hidden bool) (bool, error) {
	responseData, err := c.MakeRequest(&StoriesToggleAllStoriesHiddenParams{Hidden: hidden})
	if err != nil {
		return false, errors.Wrap(err, "sending StoriesToggleAllStoriesHidden")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesTogglePeerStoriesHiddenParams struct {
	Peer   InputPeer
	Hidden bool
}

func (*StoriesTogglePeerStoriesHiddenParams) CRC() uint32 {
	return 0xbd0415c4
}

// Hide the active stories of a user, preventing them from being displayed on the action bar on the homescreen, see here » for more info.
func (c *Client) StoriesTogglePeerStoriesHidden(peer InputPeer, hidden bool) (bool, error) {
	responseData, err := c.MakeRequest(&StoriesTogglePeerStoriesHiddenParams{
		Hidden: hidden,
		Peer:   peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending StoriesTogglePeerStoriesHidden")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesTogglePinnedParams struct {
	Peer   InputPeer
	ID     []int32
	Pinned bool
}

func (*StoriesTogglePinnedParams) CRC() uint32 {
	return 0x9a75a1ef
}

// Pin or unpin one or more stories
func (c *Client) StoriesTogglePinned(peer InputPeer, id []int32, pinned bool) ([]int32, error) {
	responseData, err := c.MakeRequest(&StoriesTogglePinnedParams{
		ID:     id,
		Peer:   peer,
		Pinned: pinned,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending StoriesTogglePinned")
	}

	resp, ok := responseData.([]int32)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type StoriesTogglePinnedToTopParams struct {
	Peer InputPeer
	ID   []int32
}

func (*StoriesTogglePinnedToTopParams) CRC() uint32 {
	return 0xb297e9b
}

// Pin some stories to the top of the profile, see here » for more info.
func (c *Client) StoriesTogglePinnedToTop(peer InputPeer, id []int32) (bool, error) {
	responseData, err := c.MakeRequest(&StoriesTogglePinnedToTopParams{
		ID:   id,
		Peer: peer,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending StoriesTogglePinnedToTop")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type UpdatesGetChannelDifferenceParams struct {
	Force   bool `tl:"flag:0,encoded_in_bitflags"`
	Channel InputChannel
	Filter  ChannelMessagesFilter
	Pts     int32
	Limit   int32
}

func (*UpdatesGetChannelDifferenceParams) CRC() uint32 {
	return 0x3173d78
}

func (*UpdatesGetChannelDifferenceParams) FlagIndex() int {
	return 0
}

// Returns the difference between the current state of updates of a certain channel and transmitted.
func (c *Client) UpdatesGetChannelDifference(params *UpdatesGetChannelDifferenceParams) (UpdatesChannelDifference, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending UpdatesGetChannelDifference")
	}

	resp, ok := responseData.(UpdatesChannelDifference)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type UpdatesGetDifferenceParams struct {
	Pts           int32
	PtsLimit      int32 `tl:"flag:1"`
	PtsTotalLimit int32 `tl:"flag:0"`
	Date          int32
	Qts           int32
	QtsLimit      int32 `tl:"flag:2"`
}

func (*UpdatesGetDifferenceParams) CRC() uint32 {
	return 0x19c2f763
}

func (*UpdatesGetDifferenceParams) FlagIndex() int {
	return 0
}

// Get new updates.
func (c *Client) UpdatesGetDifference(params *UpdatesGetDifferenceParams) (UpdatesDifference, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending UpdatesGetDifference")
	}

	resp, ok := responseData.(UpdatesDifference)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type UpdatesGetStateParams struct{}

func (*UpdatesGetStateParams) CRC() uint32 {
	return 0xedd4882a
}

// Returns a current state of updates.
func (c *Client) UpdatesGetState() (*UpdatesState, error) {
	responseData, err := c.MakeRequest(&UpdatesGetStateParams{})
	if err != nil {
		return nil, errors.Wrap(err, "sending UpdatesGetState")
	}

	resp, ok := responseData.(*UpdatesState)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type UploadGetCdnFileParams struct {
	FileToken []byte
	Offset    int64
	Limit     int32
}

func (*UploadGetCdnFileParams) CRC() uint32 {
	return 0x395f69da
}

// Download a CDN file.
func (c *Client) UploadGetCdnFile(fileToken []byte, offset int64, limit int32) (UploadCdnFile, error) {
	responseData, err := c.MakeRequest(&UploadGetCdnFileParams{
		FileToken: fileToken,
		Limit:     limit,
		Offset:    offset,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending UploadGetCdnFile")
	}

	resp, ok := responseData.(UploadCdnFile)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type UploadGetCdnFileHashesParams struct {
	FileToken []byte
	Offset    int64
}

func (*UploadGetCdnFileHashesParams) CRC() uint32 {
	return 0x91dc3f31
}

// Get SHA256 hashes for verifying downloaded CDN files
func (c *Client) UploadGetCdnFileHashes(fileToken []byte, offset int64) ([]*FileHash, error) {
	responseData, err := c.MakeRequest(&UploadGetCdnFileHashesParams{
		FileToken: fileToken,
		Offset:    offset,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending UploadGetCdnFileHashes")
	}

	resp, ok := responseData.([]*FileHash)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type UploadGetFileParams struct {
	Precise      bool `tl:"flag:0,encoded_in_bitflags"`
	CdnSupported bool `tl:"flag:1,encoded_in_bitflags"`
	Location     InputFileLocation
	Offset       int64
	Limit        int32
}

func (*UploadGetFileParams) CRC() uint32 {
	return 0xbe5335be
}

func (*UploadGetFileParams) FlagIndex() int {
	return 0
}

// Returns content of a whole file or its part.
func (c *Client) UploadGetFile(params *UploadGetFileParams) (UploadFile, error) {
	responseData, err := c.MakeRequest(params)
	if err != nil {
		return nil, errors.Wrap(err, "sending UploadGetFile")
	}

	resp, ok := responseData.(UploadFile)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type UploadGetFileHashesParams struct {
	Location InputFileLocation
	Offset   int64
}

func (*UploadGetFileHashesParams) CRC() uint32 {
	return 0x9156982a
}

// Get SHA256 hashes for verifying downloaded files
func (c *Client) UploadGetFileHashes(location InputFileLocation, offset int64) ([]*FileHash, error) {
	responseData, err := c.MakeRequest(&UploadGetFileHashesParams{
		Location: location,
		Offset:   offset,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending UploadGetFileHashes")
	}

	resp, ok := responseData.([]*FileHash)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type UploadGetWebFileParams struct {
	Location InputWebFileLocation
	Offset   int32
	Limit    int32
}

func (*UploadGetWebFileParams) CRC() uint32 {
	return 0x24e6818d
}

// Returns content of a web file, by proxying the request through telegram, see the webfile docs for more info.
func (c *Client) UploadGetWebFile(location InputWebFileLocation, offset, limit int32) (*UploadWebFile, error) {
	responseData, err := c.MakeRequest(&UploadGetWebFileParams{
		Limit:    limit,
		Location: location,
		Offset:   offset,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending UploadGetWebFile")
	}

	resp, ok := responseData.(*UploadWebFile)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type UploadReuploadCdnFileParams struct {
	FileToken    []byte
	RequestToken []byte
}

func (*UploadReuploadCdnFileParams) CRC() uint32 {
	return 0x9b2754a8
}

// Request a reupload of a certain file to a CDN DC.
func (c *Client) UploadReuploadCdnFile(fileToken, requestToken []byte) ([]*FileHash, error) {
	responseData, err := c.MakeRequest(&UploadReuploadCdnFileParams{
		FileToken:    fileToken,
		RequestToken: requestToken,
	})
	if err != nil {
		return nil, errors.Wrap(err, "sending UploadReuploadCdnFile")
	}

	resp, ok := responseData.([]*FileHash)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type UploadSaveBigFilePartParams struct {
	FileID         int64
	FilePart       int32
	FileTotalParts int32
	Bytes          []byte
}

func (*UploadSaveBigFilePartParams) CRC() uint32 {
	return 0xde7b673d
}

// Saves a part of a large file (over 10 MB in size) to be later passed to one of the methods.
func (c *Client) UploadSaveBigFilePart(fileID int64, filePart, fileTotalParts int32, bytes []byte) (bool, error) {
	responseData, err := c.MakeRequest(&UploadSaveBigFilePartParams{
		Bytes:          bytes,
		FileID:         fileID,
		FilePart:       filePart,
		FileTotalParts: fileTotalParts,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending UploadSaveBigFilePart")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type UploadSaveFilePartParams struct {
	FileID   int64
	FilePart int32
	Bytes    []byte
}

func (*UploadSaveFilePartParams) CRC() uint32 {
	return 0xb304a621
}

// Saves a part of file for further sending to one of the methods.
func (c *Client) UploadSaveFilePart(fileID int64, filePart int32, bytes []byte) (bool, error) {
	responseData, err := c.MakeRequest(&UploadSaveFilePartParams{
		Bytes:    bytes,
		FileID:   fileID,
		FilePart: filePart,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending UploadSaveFilePart")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type UsersGetFullUserParams struct {
	ID InputUser
}

func (*UsersGetFullUserParams) CRC() uint32 {
	return 0xb60f5918
}

// Returns extended user info by ID.
func (c *Client) UsersGetFullUser(id InputUser) (*UsersUserFull, error) {
	responseData, err := c.MakeRequest(&UsersGetFullUserParams{ID: id})
	if err != nil {
		return nil, errors.Wrap(err, "sending UsersGetFullUser")
	}

	resp, ok := responseData.(*UsersUserFull)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type UsersGetIsPremiumRequiredToContactParams struct {
	ID []InputUser
}

func (*UsersGetIsPremiumRequiredToContactParams) CRC() uint32 {
	return 0xa622aa10
}

// Check whether we can write to the specified user (this method can only be called by non-Premium users), see here » for more info on the full flow.
func (c *Client) UsersGetIsPremiumRequiredToContact(id []InputUser) (bool, error) {
	responseData, err := c.MakeRequest(&UsersGetIsPremiumRequiredToContactParams{ID: id})
	if err != nil {
		return false, errors.Wrap(err, "sending UsersGetIsPremiumRequiredToContact")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type UsersGetUsersParams struct {
	ID []InputUser
}

func (*UsersGetUsersParams) CRC() uint32 {
	return 0xd91a548
}

// Returns basic user info according to their identifiers.
func (c *Client) UsersGetUsers(id []InputUser) ([]User, error) {
	responseData, err := c.MakeRequest(&UsersGetUsersParams{ID: id})
	if err != nil {
		return nil, errors.Wrap(err, "sending UsersGetUsers")
	}

	resp, ok := responseData.([]User)
	if !ok {
		if responseData == nil {
			return nil, errors.New("[USER_ID_INVALID] The user ID is invalid")
		}

		if _, ok := responseData.([]*UserObj); ok { // Temp Fix till Problem is Identified
			var users []User = make([]User, len(responseData.([]*UserObj)))
			for i, user := range responseData.([]*UserObj) {
				users[i] = user
			}

			return users, nil
		}

		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}

type UsersSetSecureValueErrorsParams struct {
	ID     InputUser
	Errors []SecureValueError
}

func (*UsersSetSecureValueErrorsParams) CRC() uint32 {
	return 0x90c894b5
}

// Notify the user that the sent passport data contains some errors The user will not be able to re-submit their Passport data to you until the errors are fixed (the contents of the field for which you returned the error must change).
func (c *Client) UsersSetSecureValueErrors(id InputUser, errorsw []SecureValueError) (bool, error) {
	responseData, err := c.MakeRequest(&UsersSetSecureValueErrorsParams{
		Errors: errorsw,
		ID:     id,
	})
	if err != nil {
		return false, errors.Wrap(err, "sending UsersSetSecureValueErrors")
	}

	resp, ok := responseData.(bool)
	if !ok {
		panic("got invalid response type: " + reflect.TypeOf(responseData).String())
	}
	return resp, nil
}
